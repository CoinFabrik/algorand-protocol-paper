\documentclass[10pt,a4paper]{article}

\usepackage[utf8]{inputenc} % para poder usar tildes en archivos UTF-8
\usepackage[english]{babel}
\usepackage{a4wide}
\usepackage{hyperref}
\usepackage{float}

\usepackage{amsmath, amssymb} 

% algorithmics
\usepackage[noend]{algpseudocode}
\usepackage{algorithm}
\algnewcommand{\IfThenElse}[3]{% \IfThenElse{<if>}{<then>}{<else>}
    \State \algorithmicif\ #1\ 
    \algorithmicthen\ #2\ 
    \algorithmicelse\ #3}
\algnewcommand{\IfThen}[2]{% \IfThenElse{<if>}{<then>}
    \State \algorithmicif\ #1\ \algorithmicthen\ #2}
%\pgfplotsset{compat=1.16}

% index of words
\usepackage{imakeidx}
\makeindex

\usepackage[fulladjust]{marginnote}
%\renewcommand{\marginpar}[1]{\marginpar{\raggedleft\small #1}}

\setlength{\parskip}{4pt}%
\setlength{\parindent}{0pt}%



\begin{document}


% ---------------------------------------------------------------------------------------
\author{Argimiro, CoinFabrik}
\title{Algorand Protocol Description}

\maketitle
\tableofcontents


\begin{abstract}
    Algorand is a pure proof-of-stake blockchain protocol, designed by Silvio Micali,
    that has been implemented and deployed since 2019. Micali and co-authors designed 
    the basic blocks of the protocol and implementors published some design details.
    None of these cover the full protocol and many details are left undefined, moreover,
    many protocol decisions have changed from design to implementation. The security
    implications of this design should be studied. In our attempt to provide such a 
    study we have analyzed the source code for the node and probed the blockchain for 
    answers. To our account this is the first and only complete description of the 
    protocol. 
\end{abstract}
% ---------------------------------------------------------------------------------------
\begin{section}{Introduction}
We aim to describe how the Algorand protocol works. 
This document is meant to reflect how the Algorand mainnet is behaving
today. 
To our knowledge, there is no accurate and up-to-date technical description 
of the protocol. 

While we are aquainted with Algorand's seminal papers and documentation 
(\cite{DBLP:conf/sosp/GiladHMVZ17}, \cite{DBLP:journals/corr/Micali16} and
\href{https://github.com/algorandfoundation/specs}{Algorand's official specifications})
this document is based on the code running in Algorand's mainnet, and the reference
implementation maintained by Algorand inc. To this end, we relied in the sourcecode
for the node in the \href{https://github.com/algorand/go-algorand/}{reference implementation}
and probed the network when information was unclear or unavailable.
At the time of this writing the protocol is at {\tt ConsensusV38} (version 38)
which is specified in the file {\tt go-algorand/protocol/consensus.go} by the
constant {\tt ConsensusCurrentVersion}. 

Algorand is a proof-of-stake blockchain cryptocurrency protocol 
using a decentralized By\-zan\-tine Agreement protocol that leverages 
pure proof of stake for consensus. 
Protocol parties are represented by accounts, which may represent users
or smart contracts. 

The Algorand blockchain is operated by nodes. Users register their accounts 
in nodes. It is the nodes which call the actions. 
When an account sends a transaction, it sends it to a node. 

The structure of a node is simple: 
it has a consensus algorithm,
a virtual machine (the Algorand Virtual Machine or AVM) and networking
capabilities.
%XXX.

%no siempre se validan en la AVM, solo cuando hay codigo asociado (smart signatures, smart contracts)
Basically, the node receives transactions in its transaction pool,
validates their signature and processes them (in no protocol-imposed order), leveraging the
AVM if there was bytecode associated to them, with the goal of an eventual commitment of the transactions
to a block in the Ledger and the subsequent observation of their consequences in the state of the network.

The node maintains a ledger, which encodes the protocol status,
that is modified via consensus.
In particular, this ledger encodes how many {\sf ALGO tokens}\index{ALGO token} 
(the native token) holds each account.

Blocks encode status updates in the ledger. Starting on the genesis\index{blocks}
block (round 0) that encodes the first state of the network, 
on each round the participation nodes vote on what will the next
block be. 
Mainnet runs one blockchain that is univocally identified by the ID of
the genesis block (i.e. a hash value).

Algorand blockchain is designed so that the voting power is proportional
to the stake (in {\sf ALGO}) held by the accounts associated to the node.
In practice, not all accounts are registered live, so the voting power
is proportional to the tokens held by (the subset) of online accounts.
At the genesis of the Algorand blockchain, 10Bn {\sf ALGO} were minted. 
As of September 2022, circulating supply is approximately 6.9b {\sf ALGO}, 
distributed through different forms as ecosystem support and community
incentives.
The remaining {\sf ALGO} tokens are held by the Foundation in secure wallets 
assigned to 
Community and Governance Rewards (\%53), 
Ecosystem Support (\%36), and 
Foundation endowment (\%11).

In the following document we present a detailed pseudocode interpretation 
of the program run by an Algorand node managing at least one online (i.e., 
participating) account. We attempt to explain the different states the node x
can be in, as well as all kinds of events that cause transitions and network 
output. This work will provide a basis for an Algorand blockchain simulator 
currently in development.

\end{section}
% ---------------------------------------------------------------------
% ---------------------------------------------------------------------
\begin{section}{Strutcture}
The Algorand protocol is implemented in a network over the Internet, where nodes 
implementing a service form a peer-to-peer (p2p) network: they listen to other nodes 
and to transactions sent by clients, generate blocks, vote and continue to 
write and maintain the blockchain.

% ---------------------------------------------------------------------
\begin{subsection}{Nodes}
Actually, Algorand protocol establishes two kinds of nodes: 
{\bf relay nodes}\index{relay nodes} and {\bf participation nodes}\index{participation nodes}.

Relay nodes are responsible for relaying messages coming from other relay nodes
and the messages they receive from participation nodes. 
A relay node will queue (multiplex) both kinds of messages.\marginpar{meter grafico generado por Gero}
Relay nodes also keep a complete copy of the ledger and 
do not participate in consensus; they also run a service 
answering to participation nodes about this data and 
updating this data on block confirmation.\marginpar{sabemos algo de como funciona esto??}
Relay nodes are permissioned. They must be {\em whitelisted} by 
Algorand Foundation and this whitelist is hardcoded into the source 
code of participation and relay nodes.
We shall not go in further detail about relay nodes.

Each participation node may connect to one relay node: their addresses and keys
are hardcoded into the code of participation nodes (a list of the public key's 
hashes is included in the code).
A participation node service runs the following.
\begin{itemize}
    \item A timer which may receive a $\mathsf{reset()}$ order or a $\mathsf{time()}$
        order. It will record the current time when reset is called (e.g., by querying
        the OS where the node runs) and will report the elapsed time since the last reset
        in the latter case.
    \item A transaction pool that receive signed transactions from Algorand addresses.
    \item An Algorand Virtual Machine (AVM for short), which can process TEAL bytecode
        from applications or attached to smart signatures (see \ref{sect:avm} for more details). 
    \item A p2p and a websocket network interface.
    \item Ledger and balances.\marginpar{ver bien donde y como explicamos este componente}
    \item An implementation of the consensus algorithm, with a player state machine module and
        an asynchronous cryptographic computation module. This is explained in Section~\ref{sect:main}
        in greater detail.
\end{itemize}

Participation nodes are non-archival in nature, meaning they do not keep\index{archival node}\index{non-archival node}
the whole ledger in memory at all times. 
At the time of this writing, participation nodes keep the latest 1,000 blocks.
Any queries that require nonavailable data are made through the relay node 
they are connected to.

Basically, the transaction pool receives transactions\marginpar{Pensemos 
que parte de esto es AssembleBlock()? Me hace ruido q en assemble block dice que prioriza x fee}
from clients (see Sect.~\ref{sect:cliandkeys}) and keeps them in the order as they are 
received, it allows the AVM to poll this pool, receiving one transaction at a time in
the order they are received. 
The pool size is limited, e.g, the node will keep the first 1,000 transactions it receives 
and ignore the rest.
These transactions are processed by the node as follows.
\begin{itemize}
    \item The node records the transactions as they arrive in an ordered list\footnote{Note
        however that this is how the reference implementation works, however neither the implementation
        nor the protocol will enforce an order, so that a node could order transactions arbitrarily 
        into a new block and the block would not be rejected during voting.}.
    \item The node verifies the signature of the transaction (i.e., the transaction has an 
        address as its source, this address also identifies a public key that may be used to 
        verify the signature); if it is a logicsig, it is verified; if it is an app call, then
        the run is simulated.
    \item At some point, the node starts assembling the block. It will now rerun all transactions
        (but no logicsigs) the transaction is interpreted by the AVM. It will either succeed or
        fail. If it succeeds, it may alter the ledger and balances for the next block. These 
        changes are recorded. Changes to the balances and ledger are temporary recorded and
        checked for inconsistencies (e.g., local to the block creation)
    \item Once a timeout is reached, the node will collect all the changes into a block 
        proposal. 
\end{itemize}

During consensus, a node that receives a block proposal it will validate same as above.

Once consensus accepted a block proposal, it needs to run all transactions again
but now modifies the ledger and balances. \marginpar{lo deberiamos bajar a la sect MAIN}
\end{subsection}    
% ---------------------------------------------------------------------    
\begin{subsection}{Network}\label{sect:network}
A network is formed of two kinds of nodes: {\sf relay nodes}\index{relay nodes}
and {\sf participation nodes}\index{participation nodes}. 
Both nodes operate on servers that are connected to the internet and run publicly
available code from \href{https://github.com/algorand/go-algorand}{Algorand's code repository}.

When a participation node boots, it establishes a peer-to-peer (P2P) 
channel with at least one relay (4 on average), using a phone book which is included
as part of the source code of the node. 
Relay nodes manage a significantly higher number of connections, as they 
are responsible for keeping a high throughput.

Network messages between the nodes are broadcast through P2P connections that are
established and kept going, while transactions are received utilizing a websocket 
protocol.
Each account may register to a participation node, e.g., in order to vote.
Participation nodes keep a list of online accounts, and while each account should
register in at most one participation node, this is not enforced.

\end{subsection}
% ------------------------------------------------------------------------
\begin{subsection}{Accounts}\label{sect:accounts}
An Algorand account is a protocol entity represented by a 58-bytes address
associated to an ED25519 public key (see Section~\ref{sect:cliandkeys}).
For example, a user may generate an ED25519 key pair and derive the address
from the public key. On the other hand, when a contact is deployed, it is
deployed in an address for which the private key is not known.
There is a bijection between addresses and public keys: the address is 
derived from the public key by adding a 4-bytes checksum and encoding the result
in base32; the inverse is computed by simply decoding and dropping the last 4 
bytes.

An account need not register to a node in order to send transactions.

Accounts are managed by participation nodes. Accounts should be registered in at least one participation
node only, however this is not enforced.
In order for an account to participate in consensus, it needs to switch its status to ``online''
(see Sect.~\ref{sect:cliandkeys}). 
That is achieved by sending a special {\tt keyreg} transaction,\index{{\tt keyreg} transaction}
which registers a participation key for the account.% and creates a two-level ephemeral key tree.
%It is important to note that the registered account will only start participating in consensus
%$\delta_b$ rounds after the key registration transaction is approved.
%Any account participating in consensus does so with their full balance. There is no risk
%associated to participation, nor there are any rewards for running a node.
    
\end{subsection}
% ------------------------------------------------------------------------
\begin{subsection}{The Algorand Virtual Machine}\label{sect:avm}
    
    \begin{quote} 
        {\em``The Algorand virtual machine (AVM) runs on every node in the Algorand blockchain. 
    This virtual machine contains a stack engine that evaluates smart contracts and smart 
    signatures against the transactions they're called with. These programs either fail 
    and reject the transaction or succeed and apply changes according to the logic and 
    contents of the transactions.''} From \href{https://developer.algorand.org/docs/get-details/dapps/avm/}{Algorand.org}
    \end{quote}
    
The AVM receives signed transactions that may or may not alter the 
state of the blockchain and interprets TEAL, or the Transaction Execution 
Approval Language, an assembly-like language designed by Algorand 
for the blockchain.

It is a stack based machine and constitutes a safe isolated environment.

\end{subsection}
% --------------------------------------------------------------------------------------
\begin{subsection}{User Interface and Cryptrographic Algorithms}\label{sect:cliandkeys}
    Algorand distributes a command-line interface (CLI) called GOAL\footnote{https://developer.algorand.org/docs/clis/goal/goal/} 
    that allows users to interact with the protocol. The CLI supports a series of commands 
    that allow users to generate  wallets, keys, sing and send transactions to 
    a node and more.\index{CLI interface}
    When the CLI command involves the network (e.g., transactions), the CLI
    sends a message to a relay node over the Internet, and nodes will decide
    how to process this transaction.

    There are currently seven transaction types on Algorand:
        Payment, 
        Key Registration, 
        Asset Configuration, 
        Asset Freeze, 
        Asset Transfer, 
        Application Call, 
        State Proof).
    A participation node keeps a transaction pool. 
    Whenever a transaction arrives, 
        its signature is verified (if this is a smart signature, then it is checked against the AVM); those
        which do not pass are discarded, and the result of computation is cached for those which do pass.
    It checks that current round is inside the first valid (round) and last valid (round) included in the
        transaction fields.
    It also checks if the account holds ALGO to pay fees. Then, there are other checks which depend on the
        transaction type and go as follows.
    It checks that the genesis hash included in the transaction is the same as the one configured in the node.
    If this is a payment transaction, it checks that the sender has sufficient funds for transfer and fee.
    If this is a key  registration transaction, it checks the current round is inside the first valid (round) 
        and last valid (round) defined in key registration transaction fields for the validity of the key.
    If this is an asset configuration or asset freeze transaction, it also checks whether the sender is set 
        as the manager for this asset, and that this asset is not frozen among other checks.
    If this is an asset transfer transaction, it depends on several details; we do provide some relevant 
        cases which include an opt in, in which a user technically ``transfers an asset'' to themselves and in this
        case it is only checked that the asset ID exists, 
        a standard asset transfer in which it is checked that the receiver has opted in to this asset ID and the 
        receiver holds enough ALGOs to receive the asset, that the sender has enough ALGO to pay for the transfer.
    If this is an application call, it runs the code against the AVM and may either discard the transaction or 
        accept it (balance or state changes are not applied at this time).
    If this is a state proof transaction, checks that the last attesting round is bigger than the current 
        round for the node, and it also checks the structure of the state proof message.
    Readers interested in more details should check the specifications (\cite{algorand:specs}).
    Finally, the transaction is stored in the transaction pool. 

    {\centering * * *\par}

    Algorand protocols make use of two hash functions of the SHA-2 family
    as defined in \cite{NIST.FIPS.180-4}: SHA256 and SHA512/256.
    
    A cryptographic singing scheme defines a triplet of algorithms $(\mathsf{Generate}(\,),\mathsf{Sign}(\,),\mathsf{Verify}(\,))$. 
    These include a key-generation algorithm $\mathsf{Generate}(\,)$ that takes a random string and
    returns a public and secret key; a signing procedure $\mathsf{Sign}(\,)$ which takes a private key 
    and a packet of data of arbitrary length and outputs a signature (a bit-string of fixed length); and
    a verification algorithm $\mathsf{Verify}(\,)$ which takes the public key, some data of arbitrary 
    length and a signature and outputs a boolean value.
    A {\tt true} output certifies that the signature is valid, and a {\tt false} output implies the 
    signature is invalid.
    When using cryptographic signatures, Algorand uses the ED25519 elliptic-curve cryptographic 
    signatures standard which implements elliptic-curve Diffie-Hellman algorithm over the curve 
    {\tt Curve25519} (\cite{Bernstein:2006}). It uses 256-bits keys. 

    A verifiable random function (VRF for short) scheme includes a key generation algorithm
    that outputs a pair of secret and public keys, an algorithm that given the secret key and 
    a value produces a pseudorandom output and a {\em proof} (object), and 
    a verification algorithm, which given the output and proof, verifies that the result is correct (see 
    \cite{MicaliRabinVadhan:1999}).

    The Algorand Protocol uses three types of cryptographic keys: 
    root or spending keys,
    voting or participation keys and
    selection keys.

    Spending and participation both use ED25519 cryptographic signatures as follows. 
    Accounts sign their transactions (e.g., via the CLI) before sending them to a node, and 
    the node will verify the signature before accepting the transaction (since the transaction
    must include the address it is destined to, and the public key can be derived from the
    address, the node does not need to hold the public keys in advance). 

    The Algorand protocol allows for a process called ``rekeying'', in which case 
    the owner of a private key can authorize a new key to sign transactions on behalf of this account
    (and disable the older one).

    At different points in the protocol a provably random account selection needs to happen. 
    This selection process is done with the VRF scheme. Basically, all accounts may generate one
    random number per stake they have and only those accounts generating a random number 
    smaller than a threshold are selected. The selected accounts will provide the random number
    and proof generated by the VRF scheme to others, who can verify the validity of the random
    number and check it is below the threshold in order to allow the selection. This threshold
    is a constant defined in the protocol and has been tuned in order for the number of accounts
    selected fall close to a target.

    Participation and VRF keys are generated on demand in the node by issuing a key generation command-line
    interface (CLI) call.
    Keys are not permanent: the key generation command takes an address, a range of rounds and a 64-bit 
    integer key-dilution parameter.

    Participation keys are used to sign all {\bf consensus messages} (or messages of the consensus type),
    which are messages broadcasted (or received from other nodes and relayed) to the other nodes, and which 
    contain votes, proposals or bundles.
    In order to participate in consensus on round $r$, an account needs to have an entry in the $\mathsf{BT}$ 
    with a valid participation root public key and at least one valid subkey and one valid ephemeral key.
    %(generated through the goal addpartkey command).

    To achieve forward security (\cite{Gunther:1990}), they are organized in a tree scheme, as follows.
    Consider a two level tree structure, with a root node, $n$ nodes in the first level and $n*k$ nodes in the
    second level, where each node holds a 32 byte string representing a type of public participation key. 
    In the case of first level nodes, they also keep a signature of the public subkey concatenated with 
    a corresponding batch index $0 \leq i \leq n$,
    using a $\mathsf{Sign}(.)$ procedure with the private root participation key.
    In the case of leaf nodes, they also keep a signature of the public ephemeral key concatenated with its round of validity,
    using the parent private subkey.
    Previous to online account registration, a user issues a command to the node prompting generation of a root 
    participation key, a batch of subkeys of size $n$, and a sub-batch of ephemeral participation keys of size $k$.
    Then, the root node of the tree holds the root participation key, the first level nodes hold the $n$ sub-keys
    (signed by the root key), and the first node in the first level is the parent branch of $k$ nodes holding
    ephemeral participation keys, signed by the parent branch sub-key, as leaves.
    These leaf key pairs are considered ephemeral because they are by design valid for one round only and are deleted when their
    one round validity interval has passed.
    The private root participation key is deleted after signing all sub-batches during key generation,
    and each one of the sub-keys private counterparts will be deleted after computation and signature of each ephemeral batch.
    Once a batch has run out (when reaching round $r^\prime$, where the round of validity for the last key in the batch
    is $r^\prime - 1$), the tree is pruned; their parent branch is deleted, and a new batch of $k$ ephemerals
    is generated for the next subkey in the tree.
    When signing messages for consensus in round $r$, the next available computed ephemeral leaf key is used.
    When verifying this signature, a node will verify the signature of the message against the public ephemeral key, 
    then verify the signature of the ephemeral key itself by the master sub-key, and finally verify this sub-key's
    signature using the root participation key.
    % The participation keys tree is kept up to date by a key deletion thread that runs in parallel constantly.

     GRAFICO ORDENAR PENSandDO EN COMO SE GENERAN LAS KEYS, COMO SE FIRMA Y COMO SE VERIFICA, Y COMO SE DESCARTAN.

    The batch size $k$ is passed as a field in the key generation command line interface call named 
    $keyDillution$, an unsigned 64-bit integer which defaults to the square root of the round range 
    (rounded down to the nearest integer) when not specified, e.g. for a 3 million round range a $1712$ 
    batch of subkeys is generated,  along with a first sub-batch of $1712$ ephemeral keys.
    In order to change an account status from offline to online, a ``keyreg'' transaction needs the 
    root public participation key as a valid field in order to succeed.

    %https://github.com/algorand/go-algorand/blob/9af066b4e9fc43329d23faa5735f16f2543c4687/crypto/onetimesig.go

Selection keys used for committee membership selection and verification (see Sections \ref{}).\marginpar{add labels}
Private selection keys are kept secret by the node, while public selection keys are kept inside 
account records (in the $\mathsf{BT}$).
They are created and registered on a CLI key generation call, after participation key generation.
VRF keys are needed in order for an account to vote, as they will be
used to compute committee membership credentials, and to verify said credentials by nodes receiving consensus messages.
More specifically, in order to participate in consensus on round $r$, an account needs to have an entry in $\mathsf{BT}$
with valid VRF public keys for the lookback round $r-\delta_s(1+\delta_r)$.
They make use of an Algorand fork of the Sodium C library \marginpar{citar libsodium y el fork}, implementing VRF signing, verification and
key generation functions.
    In the following work, these cryptographic functions are abstracted as $\mathsf{VRF_{prove}}(.)$, $\mathsf{VRF_{verify}}(.)$, $\mathsf{VRF_{generate}}(.)$
    and the helper function $\mathsf{VRF_{proofToHash}}(.)$.
    Refer to the provided repository for implementation details.

    Participation (root, subkey and ephemeral) private keys and VRF private keys for a given account are kept as secrets by the node
    in which the account registered to participate in consensus.

    %https://github.com/algorand/go-algorand/blob/9af066b4e9fc43329d23faa5735f16f2543c4687/crypto/vrf.go

    We define a $\mathsf{secrets}(I, r^\prime)$ helper function, which takes a user address and
    a valid round number (that is lesser or equal to $r$), and is able to retrieve private VRF keys
    and private ephemeral participation keys (and living private participation subkeys) for a given user $I$ 
    and a valid round number $r^\prime$ when applicable. Note that past round ephemeral private keys are not recoverable
    by design. 
    As a precondition it is assumed that in any call to $\mathsf{secrets(.)}$,
    the keys being retrieved were registered and valid for $I$ in the round $r^\prime$, and $I$ generated them
    in the node making the call (the user with address $I$ has an entry in the local $\mathsf{Accounts}$ array).
    \marginpar{Ver si no conviene directamente borrar el Accounts array, aclarar esto mas arriba y simplificar notacion}


    Hablar de logicsigs y smart signatures, multisigs etc.

\end{subsection}
% --------------------------------------------------------------------------------------
\begin{subsection}{Node as a State Machine}
A network participation node can be modeled as a state machine.
In this section we will define all primitives and data structures necessary to define the state
of a node; the rest of the work will be spent on describing the rules and interrelations that
make nodes transition from and into different states.

Online accounts are registered to a node. This node takes care of voting for these accounts.
Hence, the state for these accounts, is the state of the node. As many accounts may be 
registered in one node, the node will manage the participation for all of these accounts 
concurrently.

The {\sf state of a node} \index{node's state}\index{state of a node}
is given by the {\sf execution state} which is defined as the 3-tuple of nonnegative integers $(r, p, s)$, 
a set of observed proposals, $P$, 
a set of observed votes, $V$, 
a Ledger $\mathsf{L}$ and 
a balance table $\mathsf{BT}$.
% falta el pinned vote, el tiempo, el ultimo estado...
Explicitly, we define the state of a node, $S$, as a tuple of values, 
$$
S = (r, p, s, V, P, \bar{v}, \bar{s}, \mathsf{L}, \mathsf{BT})
$$ 
where
\begin{itemize}
    \item 
    $r\in\mathbb{Z}_{\ge 0}$ is the current {\sf round} and recorded as a 64-bits integer. \index{round}
    The round variable start as $r=0$, when the genesis block is generated. The round and other
    execution state parameters (p and s) change during protocol execution, they are either increased
    or reset, by the Algorithms \ref{algo:main}, \ref{algo:start-new-round} and \ref{algo:start-new-period}.
    
    \item 
    $p\in\mathbb{Z}_{\ge 0}$ is the current {\sf period} within the round and recorded as \index{period}
    a 64-bits integer. When the round starts, $p$ is set to 0 ($p=0$).
    
    \item 
    $s\in\mathbb{Z}, 0\le s\le 256$ is the current {\sf step} within the round\index{step} 
    and recorded as a 64-bits integer. When the round starts, $s$ is set to 0 ($s=0$). 
    We often use the labels of Table \ref{table:s} to identify step numbers.
    
    \item
    $\mathsf{V}$ is the set of all valid {\sf observed votes}\index{observed votes} and 
    {\sf equivocation votes}\index{equivocation votes} in the current execution state
    $(r,p,s)$. It is initialized as the empty set $V=\emptyset$.
    
    \item
    $\mathsf{P}$ is the set of all valid {\sf observed proposals}\index{observed proposals}
    in the current execution state $(r,p,s)$ and it is also initialized as the empty set.
    
    \item
    $\bar{v}$ is the {\sf pinned proposal value} and it is initialized to $\bar{v}=\bot$.\index{pinned proposal value}
    
    \item
    $\bar{s}\in\mathbb{Z}_{\ge 0}$, a 64-bits integer, is the {\sf last finished step}
    and it is initialized to $\bar{s}=0$.\index{last finished step}
    
    \item
    $\mathsf{L}$ is the {\sf ledger}, a structure that holds a sequence of states comprising the common
    information established by the current instantiation of the Algorand protocol.\marginpar{Revisar abajo y mejorar}
    \footnote{Note that, thanks to the genesis hash and previous 
    hash components, a ledger state unambiguously defines the whole history of state changes.}. 
    
    \item
    $\mathsf{BT}$ is the current balance table \index{balance table} that includes 
      the ALGO owned by each account, 
      the ASA owned by each account (when an account opts-in to an ASA, an entry is created within his records for
        this ASA--and he must have a minimum balance for this to happen),
      the local storage for all the applications that the account has opted in (same as above, he needs a minumum
        ALGO balance for this),
      the global storage for this account--in case it belongs to a smart contract,
      the consensus participation status of this account (e.g., if this account is online and voting or not),
      in case the account is online and voting, it also includes
        the public VRF key (selection key),
        a public participation key, 
        a set of public batch participation keys, 
        and a set of public sub-batch ephemeral keys.
        In the rest of this work, we represent the balance table as a two-dimensional mapping where the
        first coordinate is the round for which we want account data (excluding rounds in the future; that
        is for all $0 \leq r\prime \leq r$ at any given moment)
        and the second coordinate is the address of the specific account.
        This mapping makes all historical information accesible. Implementations usually cache certain past
        values for performance, but in general historical data for a round $r\prime = r-k$ with $k>0$ and all 
        existing accounts is available by traversing the ledger in reverse order and undoing all changes outlined 
        in the last $k$ blocks.
        For completeness, given an address $I$ for an account that does not exist as of round $r$,
        $\mathsf{BT}[r][I] = \bot$.
        % (0,\emptyset,\emptyset,\emptyset,0,...)$, 
        % a valid empty record for account $I$. 
        % created ad-hoc, while $\mathsf{BT}[r-k][I] = \bot, \forall k>0$.

    \item
    $\mathsf{TP}$ is the node's transaction pool, represented as a priority queue, supporting
    a $\mathsf{head(.)}$ function to get the next element to unqueue, an $\mathsf{iterator}(.)$
    helper function to construct and return an iterator into the queue and be able to retrieve all
    queued elements in priority order.
    It also supports an $\mathsf{UpdateTP}(TP,e)$ procedure, which takes a valid payset from a block $e$
    and correctly unqueues all transactions included in the intersection $e_{payset} \cap TP$, and then
    drops all elements that have been invalidated by round advancement.\marginpar{No lo entiendo bien}

    \item 
    The current time $\mathtt{time}$ in seconds, and the elapsed time since the last
    time reset was called.
\end{itemize}
The first 7 values are the {\sf consensus state parameters},\index{consensus state parameters}
whereas $\mathsf{L}$ and $\mathsf{BT}$ are {\sf ledger state parameters}.\index{ledger state parameters}

Let $r$ and $p$ be unsigned 64-bits integers representing the round and period number respectively, and 
let $s$  be an unsigned 8 bits integer representing the step number.
For convenience and readability, we define the following step name - step enumeration assignment:
\begin{equation}\label{table:s}
\left\{    
    \begin{array}{ll}
        \mathsf{proposal}&\mbox{if }s=0 \\
        \mathsf{soft}&\mbox{if }s=1 \\
        \mathsf{cert}&\mbox{if }s=2\\
        \mathsf{next}_{s-3}&\mbox{if }s\in [3, 252]\\
        \mathsf{late}&\mbox{if }s=253\\
        \mathsf{redo}&\mbox{if }s=254\\
        \mathsf{down}&\mbox{if }s=255
    \end{array}
\right.
\end{equation}

% ledger
A Ledger is identified by a string called the genesis identifier, as well as a genesis hash that cryptographically 
commits to the starting state of the ledger.
Besides the already defined round number $r$, which indexes into the Ledger's sequence of states,
a Ledger's state is defined by the following components:
\begin{itemize}
    \item Genesis identifier and genesis hash, unambiguously defining the ledger 
    to which the state belongs.
    \item Protocol version and update state.
    \item Timestamp (in milliseconds since genesis block), identifying when the state was first proposed.
    \item A 64-byte seed, source of randomness for the consensus algorithm.
    \item The current reward state, which describes the policy at which incentives
    are distributed to participants.
    \item The current box state, which holds mappings from (app id, name) tuples
    to box contents of arbitrary bytes.
\end{itemize}

% balance
%Redefinicion de lo de arriba. TODO: doble-check de que no falte nada arriba que se menciona aca

% A {\sf balance table}\index{balance table}, $BT$, is a mapping of addresses to 
% account records where an {\sf account record}\index{account record} comprises 
%  a 64-bits unsigned integer raw balance, 
%  a 3-state flag status (can be ``online'', ``offline'', or ``non-participating''),
%  its registered voting keys (more info on subsection~\ref{sect:Keys}, keys) and 
%  two 64-bits unsigned integers $r_{start}$ and $r_{last}$, which represent the 
%    validity interval (in rounds)\marginpar{Pero la part key donde esta guardada?}
%    for the participation key (which acts as the root voting key for the Merkle 
%    tree).\marginpar{Cu\'al merkle t. no se definio!}

% A node may query the current state of a particular account by indexing the balance 
% table by address, or it might query a previous round's account state by adding a 
% round indexing. 
% Note that past account states are always computable by iterating over the Ledger
% sequence of blocks and reverting transaction updates. Internally however, certain
% past records might be cached and maintained to improve performance.

For convenience, we assume that each node maintains an account list that provide 
easy iteration access to all updated balance records for the accounts it manages 
which are flagged as online and have a valid participation key and VRF key
registered on this node.
This array is named $A$ from now on, and each entry $a\in A$ has an account address 
$a_I$. %, and all the information in its mapped balance record, $BT[a_I]$.

% transaction pool
The Transaction pool, $TP$, which is a set of live unconfirmed transactions, $txn_k$, (where 
$k$ is an account's address, the creator and sender of the transaction), either
sent by accounts that are managed by the node itself or obtained from the network 
(broadcast by other nodes).
For the purpose of this article, transactions are an otherwise opaque object, with the 
attribution of modifying account records.

% block
A {\sf block} $e$ is a data structure which specifies the transition between states.
The data in a block is divided between the block header and its block body.
A block header holds the following data:
\begin{itemize}
    \item
    The block's round, which matches the round of the state it is transitioning
    into. (The block with round 0 is special in that this block specifies not
    a transition but rather the entire initial state, which is called the genesis
    state. This block is correspondingly called the genesis block).
    
    \item
    The block's genesis identifier and genesis hash, constant and decided on
    Ledger creation.
    
    \item
    The block's upgrade vote, which results in the new upgrade state. The
    block also duplicates the upgrade state of the state it transitions into.
    
    \item
    The block's timestamp, which matches the timestamp of the state it transitions into. 
    The timestamp is decided by the proposer of the block using their own internal clock. 
    To be valid, a timestamp must be greater than the last committed block's timestamp 
    and must not be more than 25 seconds away from said time.
    
    \item
    The block's seed, which matches the seed of the state it transitions into.
    
    \item
    The block's reward updates, which results in the new reward state. The
    block also duplicates the reward state of the state it transitions into.
    
    \item
    A cryptographic vector commitment, using SHA512/256 hash function,
    to the block's transaction sequence.
    
    \item
    A cryptographic vector commitment, using SHA256 hash function, to the block's
    transaction sequence (useful for compatibility with systems where SHA512/256 
    is not supported).
    
    \item
    The block's previous hash, which is the cryptographic hash of the previous
    block in the sequence. (The previous hash of the genesis block is 0).\marginpar{cual de los dos hashes? sha256 o sha512/256?}
    
    \item
    The block's transaction counter, which is the total number of transactions
    issued prior to this block. This count starts from the first block with a
    protocol version that supported the transaction counter.
    
    \item
    The block's expired participation accounts, which contains an optional slice
    of public keys of accounts. These accounts are expected to have their
    participation key expire by the end of the round (or was expired before
    the current round).
    The block's expired participation accounts slice is valid as long as the participation keys 
    of all the accounts in the slice are expired by the end of the round or
    were expired before, the accounts themselves would have been online at the end
    of the round if they were not included in the slice, and the number of elements
    in the slice is less or equal to 32. A block proposer may not include all such
    accounts in the slice and may even omit the slice completely
\end{itemize}
While a body of a block is the block's transaction sequence, which describes the sequence
of updates to the account state and box state. %\marginpar{los account records no tienen states!}
%adp: tecnicamente los local y global states son account updates, 
%los local states viven en en el account record y tenes uno por cada app 
%a la que estes opted in, los global funcionan similar para la cuenta del contrato
%los boxes los maneja como algo separado por eso estan aparte
%
% aw: pero fijate que en la definicion de account record, solo tiene keys y alguna
% cosa mas pero nada de memoria de este tipo.

% hashmap: address\mapsto 
% ( balance, 
% online/offline/nonparticipating, 
% lista de ASA IDs a los que estes optinieado y sus balances, 
% apps IDs a las que estes optineado y los local states,
% ) en el caso de que sea un smart contract es el globarl state y los boxes

Applying a valid block to a state produces a new state by updating each of its components.
A Ledger's evolution in time can then be specified as an ordered sequence of blocks.

A Proposal is a tuple $prop = (e, \pi_{seed}, p_{orig}, I_{orig})$, where
e is a full block, $\pi_{seed}$ is a VRF proof of the seed computed
on block creation, $p_{orig}$ is the period in which the block was created,
and $I_{orig}$ is the address of the block creator, the sole account that
computed the sortition seed and proof.

A proposal-value is a tuple $v = (I, p, \mathsf{H}(prop), \mathsf{H}(\mathsf{Encoding}(prop)))$ where 
$I$ is an address (the ``original proposer''), 
$p$ is a period (the ``original period''), 
and
$H(\,)$ is a cryptographic hash function (implemented as SHA512/256). 
The special proposal where all fields are the zero-string is called the bottom 
proposal $\bot$. 
It also includes the authentication information for the original proposer, that is, 
a signature and VRF proof of the proposal-value.

$\mathsf{Proposal_{value}}(I, p, prop) := (I, p, \mathsf{H}(prop), \mathsf{H}(\mathsf{Encoding}(prop))$ is the function used
by a block proposer to create a proposal-value.
% Every time the function $\mathsf{Proposal}()$ is called, both input and output are stored
% in a table. When the inverse, $Proposal_{value}()$ is called, it is implemented
% by a table lookup--and no inconsistencies on bijectivity happen by construction.

For convenience, we define the function $\mathsf{RetrieveProposal}:v\mapsto{\mathsf{RetrieveProposal}}(v)$ for a given proposal value 
$v$,  such that $\mathsf{RetrieveProposal}(v) = prop$ if, and only if, $prop$ is the proposal that, when hashed, corresponds 
to the proposal hash $\mathsf{H}(prop)$ of the proposal value $v$.

We define an auxiliary structure, $credentials$, useful in voting, with the following fields:
\begin{itemize}
    \item $sh$ is the sortition hash (64-byte string).
    \item $\pi$ is the sortition proof (32-byte string).
    \item $j$ is a 64-bit unsigned integer that represents the vote's weight.
\end{itemize}
An object of this type is output by the $\mathsf{Sortition}(.)$ procedure.

A vote $vt$, constructed as $\mathsf{Vote}(I,r,p,s,v,cred)$ is a tuple with the following members:
\begin{itemize}
    \item $I$ is a valid Algorand address (in 32-byte format).
    \item $r$ is the vote's round (64-bit integer).
    \item $p$ is the vote's period (64-bit integer).
    \item $s$ is the vote's step (8-bit integer).
    \item $v$ is the vote's proposal value.
    \item $cred$, of type $credentials$, the committee credentials of the voter.
\end{itemize}

In practice, votes are broadcast wrapped in a structure called ``Unauthenticated Vote'', 
where the $credentials$ field is added, containing only the voter's sortition proof and 
address.
The rest of relevant data, sortition hash $sh$ and vote weight $j$, are reconstructed as part 
of the verification process, 
where a node authenticates the received vote and re-computes them.
For the sake of simplicity we abstract away this step and assume immediate availability of all 
$credentials$ fields.


% equivocation vote
Let $I$ be an address, $r, s, p\in\mathbb{Z}_{\ge 0}$, $cred$ a credential, and $v_0,v_1$ different
vote proposals.
An {\sf equivocation vote}\index{equivocation vote} happens when a pair of votes
$vt_0 = \mathsf{Vote}(I, r, p, s, v_0, cred)$ and $vt_1 = \mathsf{Vote}(I, r, p, s, v_1, cred)$.
An equivocation vote is valid if both of its constituent votes are valid.
It is important to keep in mind that nodes are forbidden from equivocating 
on any steps $s \neq soft$.\marginpar{What does this mean? How do nodes enforce this?}

% bundle
A {\sf bundle}\index{bundle} is a set $b = \mathsf{Bundle}(r,p,s,v)$ such that for any pair of distinct values 
$vt_0, vt_1 \in b$ the following conditions hold: 
a) $vt_{0_r} = vt_{1_r} $, 
b) $vt_{0_p} = vt_{1_p}$,
c) $vt_{0_s} = vt_{1_s}$,
d) for each pair of distinct elements, either $(vt_0)_I \neq (vt_1)_I \land vt_0.v = vt_1.v$ or the pair $vt_0$, $vt_1$ 
is an equivocation vote, and
e) the number of votes in $b$ is such that the sum of weights for each vote in $b$ is greater or equal to the
committee threshold of the votes in the set.

For convenience, we define the {\sf observed bundles}\index{B} for the current execution state, $B$, 
as the set of all of the bundles
observed by the node in the current execution state. Said set is always consistent with an in-place
reconstruction by grouping elements of $V$ in all possible subsets with the required properties
of a valid bundle.
\end{subsection}

\end{section}
% ------------------------------------------------------------------------
% ---------------------------------------------------------------------
% quizas hay que reubicar esta sect. ver luego
\begin{section}{Vanilla run}\label{subsect:vanilla-run}
    Let us assume a genesis block was generated, the blockchain has been running and
    has already generated blocks, with a set of nodes and accounts. 
    We are now at round $r-1$ ($r>2$), meaning that $r-1$ blocks have been 
    generated and confirmed by the blockchain.
    Moreover, the node has received transactions which have been verified to 
    be correctly signed by Algorand accounts and validated according to Ledger context, 
    and has added them to its transaction pool and relayed them to other nodes.
    For this section, we assume that all nodes behave according to protocol
    and that they are in sync (e.g., the context $(r,s,p)$ for all nodes is 
    the same and their internal clocks are synchronized).
    
    The node keeps some values in memory or storage. In particular the 
    timer, which we assume is now at $timer=0$,
    a round number $r\in\mathbb{Z}_{\ge 0}$, 
    a step $s:=0\in\mathbb{Z}_{\ge 0}$,
    a period $p:=0\in\mathbb{Z}_{\ge 0}$, 
    a last finished step $\bar{s}:=0\in\mathbb{Z}_{\ge 0}$, and 
    a pinned vote $v:=\bot$.
    
    The main algorithm (Algorithm~\ref{algo:main}) for consensus is an event 
    handler that receives two types of input from the node. 
    It receives messages, and it is also able to read the timer.
    % (Ver: https://github.com/algorand/go-algorand/blob/d82691daa34160ddc91f9b590ad16ad5f1d6d026/util/timers/interface.go#L25)
    % Cabe mencionar que las specs no asumen "sincronizacion" de ningun tipo de los clocks de cada nodo, 
    % y de hecho puede estar completamente desincronizado (si se asume que todos los relojes se mueven a una velocidad 
    % "similar" segun los viejos papers).
    % El 0 es un decir, en realidad hay un tiempo inicial. Seria mas bien time=ZeroedTime() o time=CurrentTime() si queremos ser mas rigurosos, y todo
    % Son deltas respecto de este, pero me parecio razonable plantearlo asi por una cuestion de legibilidad
    % En el sim esta implementado asi, como incrementos desde un tiempo inicial medido al principio de proposal
    %
    % DUDA:
    % pero el clock del sistema va en ms! y en algun lugar me parecio ver que miraba milisegundos.
    % Mi duda es que el event handler labura con = y claro, es raro que justo hagas un query al timer en el momento en 
    % el que da FilterTimeout(p) o 4\lambda
    
    % adp: en realidad el igual es un decir. Esa variabilidad, asi como otras (conexion por ejemplo) estan representadas en un valor aleatorio agregado,
    %a todos los timeouts, sampleado de una distribucion uniforme (es el ultimo valor) con un rango bastante amplio
    %igual la logica no es de estar polleando hasta que te de el timeout, es al reves, son interrupciones representadas en mensajes enviados a mi mismo.
    %La comparacion se hace una vez que me llego un mensaje. Y como es de interrupcion, que tipo de interrupcion es? Entonces ahi miro el timer
    
    % aw: calculo e'? BT'? L'?
    % adp: En este momento BT y L son contextualmente los que hayan resultado del round anterior. Digamos que estan en un estado inicial BT_r, L_r.
    % Al bloque (e) yo lo modelé como calculado al principio de la proposal, en si se calcula antes del consenso y tiene un tiempo limite
    % luego del cual deja la propuesta vacia, lo que implica no poder participar de proposal ya que el output del step 0 no puede ser
    % un bloque vacio.
    % Estaba pensando por ahi es importante aclarar la diferencia entre un EMPTY_BLOCK, que seria el que corresponde con el EMPTY_PROPOSAL_VALUE, 
    % y un bloque sin transacciones, que puede pasar si no hay txns en la txn pool, pero no seria igual a EMPTY_BLOCK
    % porque tendria todo el resto de valores calculados (semilla, hash al anterior, etc.)
    
    % $V=\{\,\}$, P=\{\,\}, BT, L, $r_{old}$, $p_{old}$, a pinned value $\bar v:=\bot$.
    
    % timer = 0
    % event handler
    % As the main algorithm runs, it checks the timer and since the condition $timer=0$ holds,
    As the main algorithm starts a round, it receives a self message with $timer=0$.
    Then the algorithm calls the Block Proposal Algorithm (Algorithm~\ref{algo:block-proposal}).
    
    
    
    The $\mathsf{BlockProposal}()$ algorithm runs, moving directly to the main loop. Said loop
    iterates over all the accounts that are registered in the node.
    
    %adp
    %Bueno esto es interesante. El bloque define todo lo necesario para un cambio de estado.
    %En realidad por specs. los cambios de estado de Ledger y BT (o sea, de las cosas que no
    %son de funcionamiento del consenso en si -p,s,V,P,etc.-) se aplican sobre el nodo al confirmar un bloque.
    %El nodo puede cachear algunos de estos valores por performance (ej, tener un cache de los cambios de balance
    %ya que ya los calculo) pero no esta enforceado. 
    %Un caso especial es la avm. Esta ejecuta codigo en dos momentos distintos potencialmente: 
    %cuando recibe una txn o cuando recibe un bloque, como parte de la validacion de ambos respectivamente.
    %
    %En recepcion de txn:
    %Cuando recibe una txn, si es una logicsig, ejecuta ese codigo (como parte de la verif. de la firma) y como
    %las logicsig son stateless, ese nodo ya no va a ejecutar ese codigo mas, la encola en la txn pool y ya esta.
    %Cabe aclarar aca que toda txn pusheada en la txnPool esta YA validada individualmente (aplica para grupos tambien).
    %Si la transaccion era una appcall, corre el codigo. Si falla obviamente se descarta, pero si aprueba la txn
    %esta validada INDIVIDUALMENTE nada mas, pero como depende del contexto, si la txn no entra al proximo bloque
    %el codigo se tiene que correr de nuevo en el proximo round.
    %
    %En recepcion/armado de bloque:
    %cuando recibe un bloque, valida individualmente todas las txns que no figuren en la txn pool en orden.
    %Miro el txnPool. Si ya la tengo me ahorro todo chequeo de validacion que no sea contexto-dependiente (verif. de firmas
    %es uno en particular importante porque es caro). Esto implica que si tiene una logicsig, no la ejecuto.
    %Ahora si es una appCall, no importa, la tengo que volver a correr, ya que la appCall es dependiente del ctx. y
    %aca parte de la validacion es que el orden sea coherente. Aplica tambien para los pays, los transfers, en fin,
    %cualquier cosa contextual.
    %(Ver: https://forum.algorand.org/t/which-protocol-steps-have-teal-execution/8860/2)
    %
    % aw:
    % no me queda claro si ademas de ejecutar las tranasacciones stateful, tambien aplica cambios. como quien cuando?
    %
    % adp: Ah, esto internamente funciona asi. Una proposal es un bloque junto con todo lo necesario para validarlo.
    % https://github.com/algorand/go-algorand/blob/2670e9493688696b3649dd67ccff5dbb353bf6e8/ledger/ledgercore/validatedBlock.go#L27
    %Basicamente, adentro de una proposal tenes una unauthenticatedProposal (donde vas a tener el bloque pelado, la VRFProof de la semilla, 
    %el periodo original y la address del propositor original). Ademas, tenes un validatedBlock, que contiene adentro el delta de estado que resultaria
    %de aplicar el bloque (logicamente solo los campos relevantes). Igual esto es completamente opcional, y si hubiese en el medio ponele un corte de luz,
    %eso no queda guardado a long term storage (como si los votos y bloques). Entonces, cuando esto va vacio por h o por b, el fallback es computar
    %esos cambios on commitment. Pero rigurosamente tiene un cache para acelerar las cosas.
    
    %Como este tiene algunos otros truquitos, no se hasta que punto incluirlos y ser riguroso y hasta que punto empantanan el entendimiento del 
    %protocolo como tal. Deberiamos:
    %describirlos en detalle igual y considerarlos en todo momento
    %describirlos brevemente con algun nivel de formalidad/informalidad y despues abstraerlos
    %obviarlos para este paper (no asi el simulador) porque son opcionales y no afectan la logica per se del sistema
    %Yo votaria por la segunda pero opinion?
    
    %
    % sortition
    
    For each account $a$, the node runs $\mathsf{Sortition}(a, proposal)$ (Algo.~\ref{algo:sortition}) 
    which basically runs a Verifiable Random Function in order to decide whether this account 
    can vote (by picking a random value) and provide a proof that the random value was generated according
    to protocol.
    % j>0
    If sortition for a particular account returns the zero value, this means the account has
    not been selected for block proposal. %block creation or voting,
    If after running sortition for every online account managed by the node, no positive integer value is returned,
    the algorithm exits and the node will no longer be a proposer in the proposal step.
    %adp: el nodo sigue participando del round, solo que no propone
    %aw: pero como? Si no propone ni vota! Qué mas hay para hacer?
    %adp: en realidad se me habia pasado que decía block creation _or voting_, 
        %aca estamos corriendo sortition solo para block proposal (el step que estoy corriendo, s=0). 
        %Sortition es dependiente del contexto r,p,s en el que corremos (eso garantiza 
        %que no haya previsibilidad, ej. soy un atacante y veo que salieron las cuentas 
        %A_0...A_t como committee members en el soft vote para el primer periodo. 
        %Logro forzar un segundo periodo -o espero a que se de "naturalmente"- y despues solo 
        %necesito comprometer una cantidad muy pequeña de cuentas para controlar el softvote, y ya esta puedo colgar todo para siempre)
        %Entonces que un nodo no participe de un step no garantiza que no participe de otros steps del mismo periodo (ni de otros periodos, 
        %pero eso no importa para la vanilla run).
        %Incluso si no participa *proponiendo* un bloque, e incluso si tampoco sale nadie sorteado para votar soft o cert, 
        %va a participar en el sentido de que va a recibir proposal votes, va a hacer un filtering, va a recibir soft votes,
        %va a armar un soft bundle, va a recibir cert votes y va a armar un cert bundle. Cuando reciba la propuesta (bloque completo) ademas,
        %la va a reenviar ya que esto no depende de la pertenencia al comité.
    When it is nonzero, the node participates in the proposal voting representing the account.
    %En esta vanilla run, el period es siempre 0, asi que modifico la primera partecita para reflejar eso.
    %If either the period is zero ($p=0$) or the node received a bundle $\mathsf{Bundle}(r,p-1,s,\bot)$
    %for some number of steps $s\in\Z_{\ge 0}$, then
    In a vanilla run scenario and at this point, the period is zero ($p=0$). 
    The algorithm performs a block assembly (Algorithm \ref{algo:assemble-block}), 
    sets $v$ as the proposal value obtained from the vote $e$ and does two separate 
    broadcasts for $\mathsf{Vote}(a_I, r,p, proposal, v, cred)$ and $e$.
    Also, we enter the ``soft vote'' step setting $s:=1$.
    
    
    % adp:
    %Cabe aclarar aca que si tenes dos o mas cuentas seleccionadas para participar, queda a discreción de la impl.
    %si jugar por las dos cuentas, o tratar de optimizar el comportamiento de la red mandando solo la de mejor prioridad
    %y descartando la/s otra/s (que serian votos por la misma propuesta pero con los valores account dependientes -vrf output,
    %proposer address- de las otras cuentas)
    %
    % aw: interesante. Yo lo omitiria en la vanilla run, y lo aclararia luego
    
    %\bar v is the pinned value, which will be the special empty proposal value $\bot$ in a $0$th period, 
    %or a value for which a soft or recovery ($\mathsf{next}_s$, $late$ or $redo$) bundle has been observed in the previous period.
    
    % 0 < timer < FilterTimeout(p)
    % main algorithm: Handle Proposal
    Assume that some time has passed and now $0<timer<\mathsf{FilterTimeout}(p)$, and that 
    the node received a block proposal $e^\prime$ which was broadcasted from another node. 
    Then, the event handler runs $\mathsf{HandleProposal}(e^\prime)$ (Algorithm~\ref{algo:handle-proposal}).
    This algorithm receives the proposal $e^\prime$ and unpacks its contents,
    including the execution state $(r^\prime,p^\prime,s^\prime)$.
    Per assumptions, we have that $r=r^\prime$ and $p=p^\prime=0$.
    The algorithm checks if the proposal is valid, calling $\mathsf{VerifyProposal}(v^\prime)$ 
    on $v^\prime=Proposal_{value}(e^\prime)$ (see Algorithm~\ref{algo:verify-proposal} for more details),
    it also checks if periods differ ($p\neq p^\prime$), exiting if not. However, both checks pass per 
    the vanilla run assumptions.
    %Next it returns if any of the following conditions hold:
    %a) $v^\prime$ was observed in a soft bundle for the current context $(r,p)$ (EXPLICAR MEJOR),
    %b) if it agrees with the pinned value proposal, or
    %c) if the hash underlying proposal $e^prime$ agrees with the lowest hash seen for this
    %context. (EXPLICAR MEJOR)
    %Assume that this is the first block received, and hence none of the above conditions are
    %attained.
    Next, if $e^\prime\in P$, it returns; else $\mathsf{HandleProposal}$ re-broadcasts $e^\prime$, 
    adds $e^\prime$ to a set $P$ of stored proposals, and exits.
    
    % revisar: porque broadcastea e y recibe vt?
    
    % 0 < timer < FilterTimeout(p)
    % main algorithm: Handle Vote
    Let us say that the node received a broadcasted vote $vt$ (e.g., as those sent by the $\mathsf{HandleProposal}$ 
    algorithm) and assume that $0<timer<\mathsf{FilterTimeout}(p)$ still holds.
    The event handler for the main algorithm thus calls $\mathsf{HandleVote}(vt)$ (Algorithm~\ref{algo:handle-vote}).
    The algorithm exits on checks --which are passed with the vanilla run assumptions.
    It also exits if the vote received has already been recorded in the votes set $V$.
    If it is new, the node adds the vote to the votes set $V$ and broadcasts the vote 
    to other nodes.
    Since nodes are synchronized, it holds that $vt_s=0=proposal$, the algorithm checks if 
    $\mathsf{RetrieveProposal}(vt_v) \neq \bot$ and broadcasts this proposal if it is available, ignoring if it is not.
    %aw: a ver, entendamos que pasa aca: si estamos en el ppio, solo deberia agregar el voto a V y broadcastear. No?
    %adp: claro, si estamos en un vanilla run y estamos llamando al vote handler con un proposal vote (s=0), 
        % solo observa (aka agrega el voto a V) y broadcastea ese voto.
        %Condicionalmente broadcastea la propuesta completa (el bloque que corresponde al vt.v), si la tiene.
        %
        %Aca voy a estar potencialmente recibiendo un monton de propuestas y sus respectivos votos, 
        %no puedo garantizar el orden de los mensajes (incluso en una vanilla run).
        %En el handler, quizas se podrian obviar todos los chequeos en un vanilla run, porque:
            %asumimos honestidad de los nodos (todos los votos son correctos y verifican OK)
            %asumimos por lo mismo de arriba que no hay equivocations
            %el step no es mayor que 0 en esta porcion que estamos describiendo(vt.s=0),
            %asumimos que todos los nodos estan en el mismo round, luego vt.r = r
            %mismo caso que arriba
        %Hay complicaciones posibles. Podria ser que mi nodo este desactualizado y reciba votos para steps futuros, que tiene que reconsiderar mas adelante.
        %Podemos agregar el caveat de que vanilla run asume cierta sincronizacion de los clocks de todos los nodos, para que todos esten
        %mas o menos en el mismo momento.
        %TODO: implementar desync en la simulacion! Puede ser un caso interesante para simular.
    
    
    %aca en el medio falta algo. Cuando el event handler recibe un voto, y time < FilterTimeout(p), el handler lo va 
    %a observar y demas.
    %Cuando el event handler recibe un timeout event = FilterTimeout(p), filtra (se queda con el proposal value que 
    %minimice la funcion de prioridad) y emite un soft vote (o sea llama la subrutina softVote()).
    %Cuando el event handler recive un voto y time > FilterTimeout(p) (o sea, ya filtro), observa el voto. 
    % Aca va a estar recibiendo soft votes de otros, y step=1 (el step se cambio a 1 dentro de softVote()).
    %Si ya observo un soft bundle, emite un cert vote y ahi step := 2 (tanto del voto como
    %en el contexto de ejecucion del nodo). Entre FilterTimeout(p) y el primer timeout de next
    %2*max(\lambda, \Lambda) + esa pequeña variacion de distr. uniforme, va a observar en el caso vanilla run un cert bundle,
    %ahi viene eso ultimo
    
    Until $timer\ge \mathsf{FilterTimeout}(p)$ the main algorithm will execute the above steps
    whenever a vote or a proposal are received, always recording new events and this happens.
    
    % timer = FilterTimeout(p)
    % main algorithm: soft vote
    Eventually, the timer is at $timer=\mathsf{FilterTimeout}(p)$ and the main algorithm calls 
    $\mathsf{SoftVote()}$ (Algorithm~\ref{algo:soft-vote}).
    The soft vote is about selecting a priority block and voting it in, and it proceeds as follows.
    It initializes to an empty vote $v=\bot$ and with the lowest observed hash at infinity ($lowestObservedhash:=\infty$).
    The node will go through all the votes $vt^\prime\in V$ in its votes set that are in the
    proposal step ($vt^\prime_s=0$).
    Given the credentials for the vote $vt^\prime_{credential}=(sh,\pi, j)$, where $sh$ is the hash,
    $\pi$ is the proof and $j\in\mathbb{Z}_{\geq 0}$, the algorithm computes the priority hash
    $$
    priorityHash:=\min\{\mathsf{Hash}(sh\| i): 0\le i<j\},
    $$
    and whenever this value (as an integer) is lower than the recorded 
    $lowestObservedHash$ it sets 
    $lowestObservedHash:=priorityHash$ and $v:=vt^\prime_v$.
    Next, if there was at least one vote in $V$, for every registered account $a\in A$
    it computes \marginpar{fix notation!}
    $$
    (sh,\pi,j):=credential^{\prime\prime}:=\mathsf{Sortition}(a,soft)=\mathsf{Sortition}(a,1)
    $$
    and, if $j>0$ it broadcasts $\mathsf{Vote}(r,p,soft,v,credential^{\prime\prime})$.
    Moreover, if the proposal $prop:=\mathsf{RetrieveProposal}(v)$ is not $\bot$, it also broadcasts $prop$.
    
    % timer > FilterTimeout(p), s=1=proposal. handle-poposal
    When the main algorithm receives a message of type proposal 
    $prop$ as above, it will
    run the handle proposal algorithm as before.
    
    % timer > FilterTimeout(p), s=1=proposal. handle-vote
    When the main algorithm receives a message of type vote 
    $\mathsf{Vote}(r,p,soft,v,credential)$ as above, it relays the vote, adds it to the
    votes set (if it is new) and checks whether it can form a bundle from the 
    votes in V, i.e., it checks if there is a vote $v$ such that for all the votes 
    $vt\in V$ with round $vt_r=r, vt_p=0, vt_s=soft$ that have the same vote $vt.v$ 
    and such that the sum of its weights ($\sum_{vt\in V} vt_{cred_j}\ge \mathsf{CommitteeThreshold}(soft)$) 
    is bigger than the committee threshold. \marginpar{Revisar que este definido y apuntar a esa seccion.}
    Imagine that the first time this happens, it cannot form a bundle. 
    
    Eventually it basically adds the accepted block to the ledger, modifies the state according
    to the new block, garbage collects and sets the new round.
    That is, it will broadcast the proposal if it is not in the proposal set $P$,
    and then commit $v$, calling $\mathsf{Commit}(v)$, set $r_{old}:=r$,
    and calls $\mathsf{StartNewRound}(r+1)$ and $\mathsf{GarbageCollect}(r_{old},p)$
    ending the round.
    Calling the new round algorithm (Algo.~\ref{algo:start-new-round}) will
    reset variables as: $\bar s:=s$, $\bar{v}:=\bot$, $r:=r+1$, $p:=0$ and
    $s:=proposal=0$;
    and calling the garbage collection algorithm (Algo.~\ref{algo:garbage-collect}) 
    will compute 
    $$
    \begin{array}{rl}
    V_{(r,p-1)} & :=\{vt\in V : vt_r < r \text{ or } (vt_r = r \text{ and } vt_p + 1 < p)\}\\
    P_{(r,p-1)} & :=\{pr\in PP: pr_r < r \text{ or } (pr_r = r \text{ and } pr_p + 1 < p)\}
    \end{array}
    $$%Es $pr_p+1$; no $pr_{p+1}$ 
    and then remove these sets from the votes and participation sets: $V:=V\setminus V_{(r,p-1)}$,
    $P = P\setminus P_{(r,p-1)}$.
    
    
    
    % handle proposal con p++
    % checks if $v^\prime$ is committable (i.e., running Algorithm~\ref{algo:is-commitable} 
    % $\mathsf{IsCommittable}(v^\prime)$ returns {\tt true}), 
    % and if the step is the certification or smaller (it is, because $s=0$ and $cert=2$, see table (\ref{table:s})). 
    % Since both checks are true in this run, the algorithm iterates over every account $a$ registered 
    % to the node, running the sortition algorithm in each case to compute 
    % $cred:=\mathsf{Sortition}(a, cert)=\mathsf{Sortition}(a, 2)$\marginpar{ver HandleProposal: es cert o s?}
    % %aca es cert pero porque esta linea se ejecutaria recien en el hipotetico caso de que estes parado con un 
    % %cert bundle esperando que te llegue la propuesta completa correspondiente para commitear el bloque, cosa que
    % %podriamos asumir no deberia pasar en el vanilla run (esta linea se ejecuta solo si IsCommitable(...))
    % %Para la vanilla run, lo unico que va a hacer este handler es observar (agregar a P) la proposal recibida,
    % %y enviarla a los peers (excluyendo al que la propuso, por eso el relay en vez de broadcast). Para esto
    % %no es necesario sortition porque es simplemente forwardear.
    % extract $cred_j$ and, if it is nonzero, broadcast the vote:
    % $$
    %     \mathsf{Broadcast}(\mathsf{Vote}(a_I,r,p,cert,v,cred))
    % $$
    % else do nothing.
    % After this, the algorithm finishes and the event handler is called again.
    
    
    
    \end{section}

% ------------------------------------------------------------------------
\begin{section}{Main algorithm}\ref{sect:main}
% Broadcast(e) = Event(type=proposal-payload, data=e, sign=Signature(pk_sender, e))
% Broadcast(\mathsf{Vote}(....)) = Event(type=vote, data=\mathsf{Vote}(....), sign=Signature(pk_sender, \mathsf{Vote}(....)))
%
% Broadcast(Bundle) = Event(type=bundle, data={v for v in Bundle}, sign=Signature(pk_sender, {v for v in Bundle}))

The node is reactive. The main algorithm for the node, thus, starts when it receives 
any input, it makes computations --probably modifying the state of the node-- and 
may end by broadcasting data to other nodes.

\begin{algorithm}[H]
    \caption{\underline{Main node algorithm}}
    \label{algo:main}
    \begin{algorithmic}[1]
    \Function{$\mathsf{EventHandler}(\mathsf{Event} \ ev)$}{}
    
    \If{$ev$ is $\mathsf{TimeoutEvent}$}
        \State $time := ev_{time}$
        \If{$time = 0$}
            \State $\mathsf{BlockProposal}()$; $s:=1$
        \ElsIf{$time = \mathsf{FilterTimeout}(p)$}
            \State $s:=2$; $\mathsf{SoftVote}()$
        \ElsIf{$time = \max\{4\lambda, \Lambda \}$}
            \State $s:=3$; $\mathsf{Recovery}()$
        \ElsIf{$time\in[\max\{4\lambda, \Lambda \} + 2^{s_t-3}\lambda, \max\{4\lambda, \Lambda \} + 2^{s_t-2}\lambda)$ for some $s\le s_t \le 252$}
            \State $s:=s_t $; $\mathsf{Recovery}()$
        \ElsIf{$time = k\lambda_f + r$ for some $k,r \in \mathbb{Z}, k>0, 0\le r \le \lambda_f$}
            \State $\mathsf{FastRecovery}()$
        \EndIf
    \Else \ //ev is MessageEvent
        \State $msg := ev_{msg}$
        \If{$msg_{data}$ is of type $Proposal \ pp$}
            \State $\mathsf{HandleProposal}(pp)$
        \ElsIf{$msg_{data}$ is of type $Vote \ v$}
            \State $\mathsf{HandleVote}(v)$
        \ElsIf{$msg_{data}$ is of type $Bundle \ b$}
            \State $\mathsf{HandleBundle}(b)$
        \EndIf
    \EndIf

    \EndFunction
    \end{algorithmic}
\end{algorithm}

On a higher level, we can think of a step as a defined part of the consensus algorithm. The first three steps
($proposal$, $soft$ and $cert$)
are the fundamental parts, and will be the only steps run in normal, ``healthy'' functioning conditions.
The following steps are recovery procedures in case there's no observable consensus before their trigger times.
$next_{s-3}$ with $s \in [3, 252]$ are recovery steps and the last three ($late$, $redo$ and $down$)
are special ``fast'' recovery steps.
A period is an execution of a subset of steps, ran in order until one of them achieves 
a bundle for a specific value. A round always starts with a $proposal$ step and finishes with a $cert$
step (when a block is certified and committed to the ledger). However, multiple periods might
be run inside a round until a certification bundle ($\mathsf{Bundle}(r,p,s,v) $ where $s = cert$) is observable by the network.

\medskip
Events are the only way in which the node state machine is able to both internally transition and produce output.
In case an event is not identified as misconstrued or malicious in nature, it will certainly produce a state change,
and it will almost certainly cause a receiving node to produce and then broadcast or relay an output, to be consumed
by its peers in the network.
There are two kinds of events: Timeout events, which are produced once the internal clock of a node reaches a certain
time since the start of the current period; and Message events, which is output produced by nodes in response to some stimulus
(including the receiving node itself).
Internally, we consider the relevant data of an event to be:
\begin{itemize}
    \item A floating point number representing time in seconds, from the start of the current period, in which the event
    has been triggered.
    \item An event type, from an enumeration of two options (either $TIMEOUT$ or $MESSAGE$)
    \item An attached data type, an enumeration of four options: $NONE$ (chosen in case of an event of main type $TIMEOUT$), 
    $VOTE$, $PROPOSAL\_PAYLOAD$ and $BUNDLE$. It indicates the type of data attached.
    \item Attached data, plain bytes to be cast and interpreted according to the attached data type, or empty in case of a
    timeout event.
\end{itemize}

$\mathbf{Timeout \ Events}$ are events that are triggered after a certain time has elapsed after the start of a new period.
\begin{itemize}
    \item $soft$ Timeout (aka. Filtering): The filter timeout is run after a timeout of $\mathsf{FilterTimeout}(p)$ is observed 
    (where $p$ is the currently running period). Note that it only depends on the period as far as if it's the first
    period in a round or a subsequent one.
    Will perform a filtering action, finding the highest priority proposal observed to produce a soft vote, as detailed
    in the soft vote algorithm.

    \item $next_0$ Timeout: it's the first recovery step, only executed if no consensus for a specific value was observed,
    and no $cert$ bundle is constructible with observed votes. It plays after observing a timeout of $\max\{4\lambda, \Lambda \}$.
    In it, the node will next vote a value and attempt to reach a consensus for an $next_0$ bundle, that would in turn kickstart
    a new period.

    \item $next_{st}$ Timeout: this family of timeouts runs whenever the elapsed time since the start of the period reaches
    $\max\{4\lambda, \Lambda \} + 2^{st-3}\lambda + r$, where $st\in [4, 252]$ and $r \in [0, 2^{st-3}\lambda]$, a random 
    delta sampled uniformly at random that represents network variability.
    The algorithm run is exactly the same as in the $next_0$ step.

    \item Fast recovery Timeout ($late$, $redo$ and $down$ steps): On observing a timeout of $k\lambda_f + r$ with $r$ a uniform random sample in $[0, \lambda_f]$ and
    $k$ a positive integer, the fast recovery algorithm is executed. It works in a very similar way to $next_k$ timeouts, with some subtle differences (besides trigger time).
    For a detailed description refer to its own subsection.
\end{itemize}


$\mathbf{Message \ Events}$ Are events triggered after observing a certain message carrying data.
There are 3 kinds of messages: votes, proposal payloads, and bundles, and each carry
the corresponding construct (coinciding with their attached data type field).

% --------------------------------------------------------------------
\begin{subsection}{Block Proposal}\label{ssect:blockproposal}

    \begin{algorithm}
        \caption{\underline{Block Proposal}}
        \label{algo:block-proposal}
        \begin{algorithmic}[1]
        \Function{$\mathsf{BlockProposal}$}{\;}

            \State $\mathsf{ResynchronizationAttempt}()$

            \For{$a \in A$}
                \State $cred :=  \mathsf{Sortition}(a_I, r,p, proposal)$
                \If{$cred_j > 0$}
                    \If{$p = 0 \lor \exists s^\prime \textfractionsolidus \mathsf{Bundle}(r, p-1, s^\prime, \bot) \subset V$}
                        \State $(e,\pi_{seed}) := \mathsf{AssembleBlock}(a_I)$
                        \State $prop := \mathsf{Proposal}(e, \pi_{seed}, p, a_I)$
                        \State $v := \mathsf{Proposal_{value}}(prop)$
                        \State $\mathsf{Broadcast}(\mathsf{Vote}(a_I, r, p, proposal, v, cred))$
                        \State $\mathsf{Broadcast}(prop)$
                    \Else
                        \State $\mathsf{Broadcast}(\mathsf{Vote}(a_I, r, p, proposal, \bar{v}, cred))$
                        \If{$\mathsf{RetrieveProposal}(\bar{v}) \neq \bot$}
                            \State $\mathsf{Broadcast}(\mathsf{RetrieveProposal}(\bar{v}))$
                        \EndIf
                    \EndIf
                \EndIf
            \EndFor
        \EndFunction
        \end{algorithmic}
    \end{algorithm}

\newpage
% porposal = s
\noindent \textbf{Description:}\\
This algorithm is the first called on every round and period. 
Starting on line 2, the node attempts a resynchronization (described in \ref{sect:soubroutines}), which
only has any effect on periods $p > 0$.

The algorithm loops on all of its managed online accounts ($a\in A$). 
This is a pattern that we'll see in every other main algorithm subroutine 
that performs any form of committee voting.
For each account, the sortition algorithm is run to check if the account is allowed 
to participate in the proposal. 
If an account $a$ is selected by sortition (because $cred_j=\mathsf{Sortition}(a_I, r,p,proposal)_j>0$)
there are two options. 

i) If this is a proposal step ($p=0$) or if the node has {\em observed} a bundle 
$\mathsf{Bundle}(r, p-1, s^\prime, \bot)$ (meaning there is no valid pinned value), 
then the algorithm assembles a block, computes the proposal value for this block, 
broadcast a proposal vote by the account $a$, and broadcasts the full block in a 
proposal type message.

ii) Otherwise, a value $\bar v$ has been pinned supported by a bundle observed in 
period $p-1$, and on line 12 the node gets this value, assembles a vote
$\mathsf{Vote}(a_I, r, p, proposal, \bar{v}, cred)$, broadcasts this vote,
and will also broadcast the proposal for the pinned vote if it was already
observed.
%adp P*? CAN the pinned value at this stage, by some manipulation of equivocation votes, not be unique? meaning there
%is more than one full bundle for the past period.
%
%% Esto  me confunde. Esta bien indentado el algoritmo? O sea esto es independeinte de los IFs de arriba?
Then, for every account selected, a proposal vote for this pinned value is broadcast. Afterwards, 
if the corresponding full proposal has been observed, then it is also broadcast.


\end{subsection}
% ---------------------------------------------------------------------------------------------------
\begin{subsection}{Soft Vote}\label{ssect:softvote}

\begin{algorithm}[H]
    \caption{\underline{Soft Vote}}
    \label{algo:soft-vote}
    \begin{algorithmic}[1]
    \Function{$\mathsf{SoftVote}$}{\;}
    \State $lowestObservedHash := \infty$
    \State $v := \bot$ 

    \For{$vt^\prime \in \mathsf{V} \text{ with } vt^\prime_s = proposal$}
        \State $priorityHash := \min_{i \in [0, vt^\prime_{cred_j})} \{ \mathsf{H}(vt^\prime_{cred_{sh}} || i)\}$
        \If{$priorityHash < lowestObservedHash$}
            \State $lowestObservedHash := priorityHash$
            \State $v := vt_v$
        \EndIf    
    \EndFor

    \If {$lowestObservedHash < \infty$}
        \For{$Account \ a \in A$}
            \State $cred := \mathsf{Sortition}(a_I, r, p, soft)$
            \If{$cred_j > 0$}
                \State $\mathsf{Broadcast}(\mathsf{Vote}(r, p, soft, v, cred))$
                \If{$\mathsf{RetrieveProposal}(v)$}
                    \State $\mathsf{Broadcast}(\mathsf{RetrieveProposal}(v))$
                \EndIf
            \EndIf
        \EndFor
    \EndIf

    \EndFunction
    \end{algorithmic}
\end{algorithm}

\noindent \textbf{Description:}\\
The soft vote stage (also known as ``filtering'') is run after a timeout of $\mathsf{FilterTimeout}(p)$
(where $p$ is the executing period of the node) is observed by the node. 
That is to say, filtering is triggered after either a $2\cdot\lambda_0$ or $2\cdot\lambda$ timeout is observed according 
to whether $p=0$ or $p>0$ respectively.
Let $V^*$ be all proposal votes received, e.g., $V^*=\{vt^\prime\in \mathsf{V} : vt^\prime_s = proposal\}$.
With the aid of a priority hash function, this stage performs a filtering action,
keeping the lowest hashed value observed.
The priority function (lines 4 to 8) should be interpreted as follows. Consider every proposal vote $vt$ in $V^*$.
Given the sortition hash $sh$ output by the $\mathsf{VRF}$ for the proposer account, and for each sub-user unit $i$ 
in the interval from $0$ (inclusive) to the vote weight (exclusive; the $j$ output of $\mathsf{Sortition}(.)$ inside 
the $cred$ credentials structure), the node hashes the concatenation of $sh$ and $i$, $\mathsf{H}(sh||i)$ 
(where $\mathsf{H}(.)$ is the node's general cryptographic hashing function). On lines 6 to 8, 
then, it keeps track of the proposal-value that minimizes this concatenation and subsequent hashing procedure.
After running the filtering algorithm for all proposal votes observed, and assuming there was at least one vote
in $V^*$, the broadcasting section of the filtering algorithm is executed (lines 9 to 15).
For every online managed account selected to be part of the $soft$ voting committee, a $soft$ vote is
broadcast for the previously found filtered value $v$. If the full proposal has been observed and is available in $P$,
it is also broadcast. 
If the previous assumption of non-empty $V*$ does not hold, no broadcasting is performed and the node produces no
output in its filtering step.

\end{subsection}

% --------------------------------------------------------------------
\begin{subsection}{HandleProposal}\label{ssect:handle-proposal}

    \begin{algorithm}[H]
        \caption{\underline{Handle Proposal}}
        \label{algo:handle-proposal}
        \begin{algorithmic}[1]
        \Function{$\mathsf{HandleProposal}$}{$Proposal \ prop$}

            \State $v :=  \mathsf{Proposal_{value}}(prop, prop_{p}, prop_{I})$

            %relays proposal if its for a future round (but does not process it)
            \If{$\exists \mathsf{Bundle}(r+1,0,soft,v) \in B$}
                \State $\mathsf{Relay}(prop)$  %relay broadcasts to everyone except proposal sender
                \State \Return //do not observe, as it's for a future round (we're behind)
            \EndIf

            %ignores proposal if it's invalid or if it has already been observed
            \If{$\lnot \mathsf{VerifyProposal}(prop) \lor e \in P$ }
                \Return //ignore proposal
            \EndIf

            %ignores proposal if its proposal value is not either 
            %the current sigma, the pinned value or the current mu
            \If{$v \notin \{\sigma, \bar{v}, \mu\}$}
                \Return //ignore proposal
            \EndIf

            %we need to relay (broadcast to everybody but ourselves and o.g. sender), and observe p
            \State $\mathsf{Relay}(prop)$
            \State $P := P \cup e$

            %all checks passsed, produce output
            \If{$\mathsf{IsCommitable}(v) \land s \leq cert$}
                \For{$a \in A$}
                    \State $cred := \mathsf{Sortition}(a_I, r,p, cert)$
                    \If{$cred_j > 0$}
                        \State $\mathsf{Broadcast}(\mathsf{Vote}(a_I, r, p, cert, v,  cred))$
                    \EndIf
                \EndFor    
            \EndIf

        \EndFunction
        \end{algorithmic}
    \end{algorithm}
    
    Here $\mu$ is the highest priority observed proposal-value in the current $(r,p)$ context 
    (lowest hashed according to the function outlined in the $\mathsf{BlockProposal}$ algorithm), 
    or $\bot$ if no valid proposal vote has been observed by the node.

    $\sigma$ is the sole proposal-value for which a soft bundle has been observed (again, 
    in the current $(r,p)$ context), or $\bot$ if no valid soft bundle has been observed by the 
    node.

    \noindent \textbf{Description:}\\
The proposal handler is triggered when a node receives a message containing a full proposal.
It starts by performing a series of checks, after which it will either ignore the received
proposal, discarding it and emitting no output; or relay, observe and produce an output
according to the the current context and the characteristics of the proposal.

In lines 3 to 5, it is checked if the proposal is from the next first period of the round next
to the current, in which case the node relays this proposal and then ignores it for the purpose 
of the current round. 
Whenever the node catches up (i.e., observes a round change), and only if necessary, it will request 
this proposal back from the network.
Lines 6 and 7 check if the proposal is invalid, or if it has been observed already. Any one of those
conditions are sufficient to discard and ignore the proposal.
Finally, on lines 8 and 9 it checks if the associated proposal value is either of the special values for the current
round and period ($\sigma$, $\mu$, or the pinned proposal value $\bar{v}$). Any proposal whose proposal value does not match
one of these is ignored.

Once the checks have been passed, in lines 10 and 11, the algorithm relays and observes the proposal (by adding
it to the observed proposals set, $P$). 

Next, and only if the proposal value is committable and the current step is lower than or equal
to a certification step (i.e., it is not yet in a recovery step), the node plays for each account 
performing sortition to select committee members for the certification step. 
For each selected member, a corresponding ``certify vote'' for the current proposal value is cast.


\end{subsection}

% --------------------------------------------------------------------

\begin{subsection}{HandleVote}\label{ssect:HandleVote}

    \begin{algorithm}[H]
        \caption{\underline{Handle Vote}}
        \label{algo:handle-vote}
        \begin{algorithmic}[1]
        \Function{$\mathsf{HandleVote}$}{$\mathsf{Vote} \ vt$}

            % //P*? como funciona la penalizacion del jugador en este caso (funcion PenalizePeer())?
            
            % //P*? que pasa si vt_r $>$ r+1? Crash? Hay algun mecanismo de bootstrapping a ese punto?
            
            % //P*? cómo funciona la operación de relay? Sólo reenvía, o es un broadcast?
            
            % //P*? cómo funciona internamente el request for proposal?

            % //P*? si el voto es repetido, el nodo lo ignora verdad? Esto no esta especificado asi, pero es quizas un error?
            % \\

            \If{$\mathbf{not}\; \mathsf{VerifyVote}(vt)$}
                \State $\mathsf{DisconnectFromPeer}(\mathsf{SENDER\_PEER}(vt))$
                \Return \ //ignore invalid vote
            \EndIf

            \If{$vt_s = 0 \land (vt \in V \lor \mathsf{IsEquivocation}(vt))$}
                \Return \ //ignore vote, equivocation not allowed in proposal votes
            \EndIf

            \If{$vt_s > 0 \land \mathsf{IsSecondEquivocation}(vt) $}
                \Return \ //ignore vote if it's a second equivocation
            \EndIf

            \If{$vt_r < r $}
                \Return \ //ignore vote of past round
            \EndIf

            \If{$vt_r = r+1 \land (vt_p > 0 \lor vt_s \in \{next_0,\ldots, next_{249}\})$}
                \Return \ //ignore vote of next round if non-zero period or $next_k$ step
            \EndIf

            % cambiar parentesis y corchetes por \{ \}
            \If{$vt_r = r \land (vt_p \notin \{p-1,p, p+1\} \lor$ \\
            $(vt_p = p+1 \land vt_s \in \{next_1,\ldots, next_{249}\}) \lor$ \\
            $(vt_p = p \land vt_s \in \{next_1,\ldots, next_{249}\} \land vt_s \notin \{s-1,s, s+1\}) \lor$ \\
            $(vt_p = p-1 \land vt_s \in \{next_1,\ldots, next_{249}\} \land vt_s \notin \{\bar{s}-1, \bar{s},\bar{s}+1\}))$}
                \Return \ //ignore vote
            \EndIf

            \State $V := V \cup vt$ \ //observe vote
            \State $\mathsf{Relay}(vt)$

            \If{$vt_s = proposal$}
                \If{$\mathsf{RetrieveProposal}(vt_v) \neq \bot$}
                    \State $\mathsf{Broadcast}(\mathsf{RetrieveProposal}(vt_v))$
                \EndIf
            \ElsIf{$vt_s = soft$}
                %check if soft bundle has been achieved
                \If{$\exists v | Bundle(vt_r,vt_p,soft,v) \subset V$}
                    %Try to emit a certification vote
                    \For{$a \in A$}
                        \State $cred := 
                        \mathsf{Sortition}(a_{sk}, r,p,cert)$
                        \If{$cred_j > 0$}
                            \State $\mathsf{Broadcast}(\mathsf{Vote}(a_I, r, p, cert, v, cred))$
                        \EndIf
                    \EndFor
                \EndIf
            \ElsIf{$vt_s = cert$}
                %check if cert bundle has been achieved
                \If{$\exists v | \mathsf{Bundle}(vt_r,vt_p,cert,v) \subset V$}
                    \If{$\mathsf{RetrieveProposal}(v) = \bot$}
                        \State $\mathsf{RequestProposal}(v)$ //waits or keeps playing without voting power
                        \If{$p < vt_p$}
                            \State $p_{old} := p$
                            \State $\mathsf{StartNewPeriod}(vt_p)$
                            \State $\mathsf{GarbageCollect}(r, p_{old})$
                        \EndIf
                    \EndIf
                    \State $\mathsf{Commit}(v)$  %ver que pasa si no se pudiera commitear
                    \State $r_{old} := r$
                    \State $\mathsf{StartNewRound}(vt_r+1)$
                    \State $\mathsf{GarbageCollect}(r_{old}, p)$
                \EndIf
            \ElsIf{$vt_s > cert$}
                \If{$\exists v | \mathsf{Bundle}(vt_r,vt_p,vt_s,v) \subset V$}
                    \State $p_{old} := p$
                    \State $\mathsf{StartNewPeriod}(vt_p + 1)$
                    \State $\mathsf{GarbageCollect}(r, p_{old})$
                \EndIf
            \EndIf

        \EndFunction
        \end{algorithmic}
    \end{algorithm}
    
A vote $vt$ is an uple consisting of a secret key $vt_{sk}$, a round $vt_r$, a step $vt_r$ and a period $vt_p$.\index{Vote structure}
    
\noindent \textbf{Description:}\\
The vote handler is triggered when a node receives a message containing a vote for a given proposal value, round, period and step.
It first performs a series of checks, and if the received vote passes all of them, then it is broadcast by all accounts selected
as the appropriate committee members.
On line 2, it checks if the vote is valid by itself. If invalid, the node can optionally disconnect 
from the sender of the vote. In that case, we use $\mathsf{SENDER\_PEER(msg)}$ as a helper network module function,
that retrieves the network ID of the original message sender.
Equivocation votes on a proposal step are not allowed, so a check for this condition is performed on line 5.
Furthermore, second equivocations are never allowed (line 7).
Any votes for rounds prior to the current round are discarded (line 9).
On the special case that we received a vote for a round immediately after the current round, we observe it only if it is a first period,
proposal, soft, cert, late, down or redo vote (discarding votes for further periods or votes for a $next_k$ step).
Finally, the checks on lines 13 to 16 check that, if the vote's round is the currently executing round, and one of:
\begin{itemize}
    \item vote's period is not a distance of one or less away from the node's current period,
    \item vote's period is the next period, but its step is $next_{k}$ with $k \geq 1$,
    \item vote's period is the current period, its step is $next_{k}$ with $k \geq 1$, 
and its step is not within a distance of one away from the currently observed node's step, or
    \item vote's period is one behind the current period, its step is $next_{k}$ with $k \geq 1$, and
its step is not within a distance of one away from the node's last finished step,
\end{itemize}
then the vote is ignored and discarded. \\
Once finished with the series of validation checks, the vote is observed on line 18, relayed on line 19, and then processed.
The node will determine the desired output according to its current context and the vote's step.
If the vote's step is $proposal$, the corresponding proposal for the proposal-value $v$, $\mathsf{RetrieveProposal}(v)$ is broadcast if it has been observed 
(that is, the player performs a re-proposal payload broadcast).
If the vote's step is $soft$ (lines 19 through 24), and a $soft$ Bundle has been observed with the addition of the vote on line 19,
the $\mathsf{Sortition}(.)$ sub-procedure is run for every account managed by the node (line 23). Afterwards, for each account selected by
the lottery, a $cert$ vote is cast as output (line 25).
If the vote's step is $cert$ (lines 26 through 32), and observing the vote causes the node to observe a $cert$ Bundle for a proposal-value $v$,
then it checks if the full proposal associated to the critical value has been observed (line 28). Note that simultaneous observation of a $cert$ Bundle 
for a value $v$ and of a proposal $prop = \mathsf{RetrieveProposal}(v)$ implies that the associated entry is committable.
Had the full proposal not been observed at this point, the node may stall and request the full proposal from the network.
Once the desired block can be committed, on lines 30:32 the node proceeds to commit, start a new round, and garbage collect all
transient data from the round it just finished.
Finally, if the vote is that of a recovery step (lines 33:36), and a Bundle has been observed for a given proposal-value $v$,
then a new period is started and the currently executing period-specific data garbage collected.



\end{subsection}

% --------------------------------------------------------------------

\begin{subsection}{HandleBundle}\label{ssect:HandleBundle}

    \begin{algorithm}[H]
        \caption{\underline{Handle Bundle}}
        \label{algo:handle-bundle}
        \begin{algorithmic}[1]
        \Function{$\mathsf{HandleBundle}$}{$\mathsf{Bundle} \ b$}

            % //P*? "Ignores* it if Bundle(r, p, s, v) is invalid." Esta linea esta mal no? en specs. Deberia ser rk, pk, sk

            % //P*? "If there exists a vote which causes the player to observe some bundle Bundle(rk, pk, sk, $v´$) for some sk..."
            % should probably be for some $v´$

            \If{$\neg \mathsf{VerifyBundle}(b)$}
                \State $\mathsf{DisconnectFromPeer}(\mathsf{SENDER\_PEER}(b))$ \ //optional
                \State \Return
            \EndIf

            \If{$b_r = r \land b_p + 1 \geq p$}
                \For{$vt \in b$}
                    \State $\mathsf{HandleVote}(vt)$
                \EndFor
            \EndIf

            %El relaying del bundle en esta implementación queda implícito, pero como relayeamos cada voto, en teoría si observamos
            %un bundle estamos relay-eando ese bundle voto a voto

        \EndFunction
        \end{algorithmic}
    \end{algorithm}
    
    
    \noindent \textbf{Description:}\\
The bundle handler is invoked whenever a bundle message is received. 
If the received bundle is invalid (line 2), it is immediately discarded. Optionally, the node may
penalize the sending peer (for example, disconnecting from or blacklisting it).
On line 5 a check is performed. 
If the bundle's round is the node's current round and it's at most one period behind of the node's current period, 
then the bundle is processed, which is simply calling the vote handler for each 
vote constituting it (lines 6:7). If the check on line 5 is not passed by $b$, no output is produced
and the bundle is ignored and discarded.
Note that handling each vote separately, if a bundle $b\prime = \mathsf{Bundle}(b_r, b_p, b_s, v\prime)$ is observed
(where $v\prime$ is not necessarily equal to $b_v$, consider $b$ may contain equivocation votes), then it will be relayed
as each vote was relayed individually, and any output or state changes it produces will be made. All leftover votes 
in $b$ will be processed according to the new state the node is in, e.g. being discarded if $b_r < r$.
    
\end{subsection}

% --------------------------------------------------------------------

\begin{subsection}{Recovery Attempt}
    \label{ssect:Recovery}

    \begin{algorithm}[H]
        \caption{\underline{Recovery}}
        \label{algo:recovery}
        \begin{algorithmic}[1]
        \Function{$\mathsf{Recovery}$}{\;}

        \State $\mathsf{ResynchronizationAttempt}()$
    
        \For{$Account \ a \in A$}
            \State $cred := \mathsf{\mathsf{Sortition}}(a_{I}, r,p,s)$
            \If{$cred_j > 0$}
                \If{$\exists v=\mathsf{Proposal_{value}}(prop, prop_p, prop_I) $ for some $prop\in \mathsf{P} | \mathsf{IsCommitable}(v)$}
                    \State $\mathsf{Broadcast}(\mathsf{Vote}(a_I, r, p, s, v, cred))$
                \ElsIf{$\nexists s_0 > cert | \mathsf{Bundle}(r, p - 1, s_0, \bot) \subseteq \mathsf{V} \wedge$ \newline 
                ${}$ ${\hskip 2.65cm} \exists s_1 > cert | \mathsf{Bundle}(r, p - 1, s_1, \bar{v}) \subseteq \mathsf{V}$}
                    \State $\mathsf{Broadcast}(\mathsf{Vote}(a_I, r, p, s, \bar{v}, cred))$
                \Else
                    \State $\mathsf{Broadcast}(\mathsf{Vote}(a_I, r, p, s, \bot, cred))$
                \EndIf
            \EndIf
        \EndFor
        \EndFunction
        \end{algorithmic}
    \end{algorithm}
    
    
    \noindent \textbf{Description:}\\
The recovery algorithm that is executed periodically,
whenever a $cert$ bundle has not been observed before $\mathsf{FilterTimeout}(p)$ for a given period $p$. \\
On line 2 it starts by making a resynchronization attempt. Then on line 3 the node's step is updated.\\
Afterwards, the node plays for each managed account. For each account that is selected to be a part of the voting committee for the current
step $next_k$, one of three different outputs is produced. \\
If there is a proposal-value $v$ that can be committed in the current context, a $next_k$ vote for $v$ is broadcast by the player. \\
If no proposal-value can be committed, no recovery step Bundle for the empty proposal-value ($\bot$) was observed in the 
previous period, and a recovery step Bundle for the pinned value was observed in the previous period (note that this implies $\bar{v} \neq \bot$),
then a $next_k$ vote for $\bar{v}$ is broadcast by the player. \\
Finally, if none of the above conditions were met, a $next_k$ vote for $\bot$ is broadcast. A player is forbidden
from equivocating in $next$ votes.

\end{subsection}


% --------------------------------------------------------------------
\begin{subsection}{Fast Recovery Attempt}\label{ssect:FastRecovery}

    \begin{algorithm}[H]
        \caption{\underline{FastRecovery}}
        \label{algo:fast-recovery}
        \begin{algorithmic}[1]
        \Function{$\mathsf{FastRecovery}$}{\;}

        %P*? Como se maneja el step number aca? y el bar_step?

        \State $\mathsf{ResynchronizationAttempt}()$
    
        \For{$Account \ a \in A$}
            \If{$\mathsf{IsCommitable}(v)$}
                \State $cred := \mathsf{Sortition}(a_{I}, r,p,late)$
                \If{$cred_j > 0$}
                    \State $\mathsf{Broadcast}(\mathsf{Vote}(r, p, late, v, cred))$
                \EndIf

            \ElsIf{$\nexists s_0 > cert | \mathsf{Bundle}(r, p - 1, s_0, \bot) \subseteq V \wedge$ \newline 
                ${}$ ${\hskip 2.1cm} \exists s_1 > cert | \mathsf{Bundle}(r, p - 1, s_1, \bar{v}) \subseteq V$}
                    \State $cred := 
                    \mathsf{Sortition}(a_{I},r,p, redo)$
                    \If{$cred_j > 0$}
                        \State $\mathsf{Broadcast}(\mathsf{Vote}(r,p,redo,\bar{v}, cred))$
                    \EndIf

            \Else
                \State $cred := 
                \mathsf{Sortition}(a_{I}, r,p, down)$
                \If{$cred_j > 0$}
                    \State $\mathsf{Broadcast}(\mathsf{Vote}(r,p,down,\bot, cred))$
                \EndIf
            \EndIf
        \EndFor

        \For{$vt \in \mathsf{V} | vt_s \geq 253$}
            \State $\mathsf{Broadcast}(vt)$
        \EndFor

        \EndFunction
        \end{algorithmic}
    \end{algorithm}
    
    \noindent \textbf{Description:}\\
    The fast recovery algorithm is executed periodically every integer multiple of $\lambda_f$
    seconds (plus variance).
    Functionally, it's very close to the regular recovery algorithm (outlined in the previous section), 
    performing the same checks and similar outputs. The main difference is that it emits votes 
    for any of three different steps ($late$, $redo$ and $down$) according to sortition 
    results for every account.
    % It's also important to point out that nodes are forbidden to equivocate for $late$, $redo$ and $down$ votes.
    Finally, the algorithm broadcasts all fast recovery votes observed. That is, all votes $vt \in \mathsf{V}$ for which
    $vt_s$ is a fast recovery step ($late$, $redo$ or $down$).
\end{subsection}


% ------------------------------------------------------------------------------------
\end{section}
% ------------------------------------------------------------------------------------
% ------------------------------------------------------------------------------------
\begin{section}{Subroutines}\label{sect:soubroutines}

% ----------------------------------------------------------------------------------------------

\begin{algorithm}[H]
    \caption{\underline{FilterTimeout}}
    \label{algo:filter-timeout}
    \begin{algorithmic}[1]
    \Function{$\mathsf{FilterTimeout}$}{$uint64 \ p$}
        \If{$p = 0$}
            \State \Return $2\lambda_0$
        \Else 
            \State \Return $2\lambda$
        \EndIf
    \EndFunction
    \end{algorithmic}
\end{algorithm}

\noindent \textbf{Arguments:}
\begin{itemize}
    \item $uint64 \ p$ is a period number.
  \end{itemize}

\noindent \textbf{Description:}\\
The function $\mathsf{FilterTimeout}(\;)$\index{$\mathsf{FilterTimeout}(\;)$} provides the timeout 
constant for the filtering (i.e., ``soft'' or ``soft vote'') stage.
This timeout depends on the period value; the first period has a special, faster timeout.
If no consensus was achieved, this timeout constant is relaxed in all subsequent periods.\\ 

\noindent \textbf{Returns:}\\
The time constant used to trigger the filtering stage (according to whether the given
    period $p$ is the first period of the current round or not).

% ----------------------------------------------------------------------------------------------

\begin{algorithm}[H]
    \caption{\underline{General Purpose Hashing Function}}
    \begin{algorithmic}[1]
    \Function{$\mathsf{H}$}{$Hashable \ in$}
        \If{$SHA512/256 \ is \ supported$}
            \State \Return $\mathsf{SHA512/256}(in)$
        \Else
            \State \Return $\mathsf{SHA256}(in)$
        \EndIf
    \EndFunction
    \end{algorithmic}
\end{algorithm}

\noindent \textbf{Arguments:}
\begin{itemize}
    \item $Hashable \ in$, some hashable data (plain bytes)
  \end{itemize}

\noindent \textbf{Description:}\\
General purpose hashing function. If $SHA512/256$ is supported by the underlying system running the node, it's used.
Otherwise, it falls back to $SHA256$.\\

\noindent \textbf{Returns:}
    The result of hashing the input $in$ with the selected algorithm based on underlying system support

% ----------------------------------------------------------------------------------------------

\begin{algorithm}[H]
    \caption{\underline{Assemble Block}}
    \label{algo:assemble-block}
    \begin{algorithmic}[1]
    \Function{$\mathsf{AssembleBlock}$}{$Address \ I$}

    \State $Block \ b$ \\ \\

    //define block body, ordered set of signed transactions
    \State $it_{TP} := \mathsf{iterator}(TP_{head})$
    \While{$\mathsf{Time}() < \mathsf{Deadline} \land \mathsf{hasNext}(it_{TP})$}
    %https://github.com/algorand/go-algorand/blob/02b99bb25e2df8ca8c46f0caa8de2947121b4367/data/pools/transactionPool.go#L820
        \State $txn := \mathsf{next}(it_{TP})$
        \If{$\mathsf{TxnSetValid}(b_{payset}||txn)$}
            \State $b_{payset} :=  b_{payset}||txn$ \\
        \EndIf
    \EndWhile

    //define block header
    \State $b_{r} := r$
    \State $b_{prevHash} := \mathsf{H}(\mathsf{L}[r-1])$
    
    \State $(Q, \pi_{seed}) := \mathsf{ComputeSeedAndProof}(I)$
    \State $b_{Q} := Q$

    \State $b_{timestamp} := \mathsf{SYSTEM\_TIME}$ //timestamp in seconds since epoch

    \State $b_{GenesisID} := \mathsf{L}_{genesisID}$

    \State $b_{GenesisHash} := \mathsf{H}(\mathsf{L}[0])$

    % //should we include reward state, update vote and update state?

    % \State $b_{txnCounter} := NEXTTXNCOUNTER$

    % \State $b_{stateProof} := StateProofTrackers$
    % //For the scope of this work, we exclude state proof trackers\\

    % \State $b_{partUpdates} := \{a \in G \int G'\}$

    \State $b_{txnCommitment} := \mathsf{root}(\mathsf{MerkleTree}(b_{payset}))$

    \State \Return $(b, \pi_{seed})$

    \EndFunction
    \end{algorithmic}
\end{algorithm}

\noindent \textbf{Description:}\\
Gets a set of transactions out of the transaction pool (prioritizing the highest transaction fee if there were any).
Then, assembles a full ledger entry, setting all the appropriate fields in a block.

% ----------------------------------------------------------------------------------------------

\begin{algorithm}[H]
    \caption{\underline{VerifyBlock}}    
    \label{algo:verify-block}
    \begin{algorithmic}[1]
    \Function{$\mathsf{VerifyBlock}$}{$Block \ b, \pi_{seed}, p_{orig}, I_{orig}$}

    % //define block body
    % \State $b.body := TP[-s]$ \\ \\

    % //define block header
    % \State $b_{r} := r$
    % \State $b_{prevHash} := \mathsf{H}(L[r-1])$
    
    % \State $(seed, \pi_{seed}) := \mathsf{ComputeSeedAndProof}(I)$
    % \State $b_{seed} := seed$

    % \State $b_{txnCommitment} := \mathsf{MerkleTree}(TP[-s])_{root}$

    % https://github.com/algorand/go-algorand/blob/02b99bb25e2df8ca8c46f0caa8de2947121b4367/data/bookkeeping/block.go#L607
    \If {$L[r-1]_{timestamp} > 0$}
    //TODO: translate this code to algorithm
    \EndIf

    % \State $b_{GenesisID} := L_{genesisID}$

    % \State $b_{GenesisHash} := \mathsf{H}(L[0])$

    % //should we include reward state, update vote and update state?

    % \State $b_{txnCounter} := NEXTTXNCOUNTER$

    % \State $b_{partUpdates} := X$


    \EndFunction
    \end{algorithmic}
\end{algorithm}

\noindent \textbf{Description:}\\

% ----------------------------------------------------------------------------------------------

\begin{algorithm}[H]
    \caption{\underline{IsCommitable}}
    \label{algo:is-commitable}
    \begin{algorithmic}[1]
    \Function{$\mathsf{IsCommitable}$}{$Proposal_{value} \ v$}

    \State \Return $(\mathsf{RetrieveProposal}(v) \neq \bot) \land (\mathsf{Bundle}(r,p,soft,v) \subset V$)

    \EndFunction
    \end{algorithmic}
\end{algorithm}


\noindent \textbf{Arguments:}
\begin{itemize}
    \item $Proposal_{value} \ v$, a value to check for committability.
  \end{itemize}

\noindent \textbf{Description:}\\
Checks that the value $v$ is committable in the current node's context.
To be committable, the two conditions outlined in line 2 have to be met.
That is, the corresponding proposal that the value refers to has to be
available (have been observed in the current round), and there must
be a valid bundle of soft votes for $v$ observed during the current round and
period. \\

\noindent \textbf{Returns:}
\begin{itemize}
    \item A boolean value indicating committability of the argument $v$.
  \end{itemize}

% ----------------------------------------------------------------------------------------------

\begin{algorithm}[H]
    \begin{algorithmic}[1]
    \Function{$\mathsf{Commit}$}{$Proposal_{value} \ v$}

    \State $e := \mathsf{RetrieveProposal}(v)_e$ 
    \State $L := \mathsf{L} || e$
    \State $\mathsf{UpdateBT}(e)$
    \State $\mathsf{UpdateTP}(e_{payset})$

    \EndFunction
    \end{algorithmic}
    \caption{\underline{Commit}}
\end{algorithm}


\noindent \textbf{Arguments:}
\begin{itemize}
    \item $Proposal_{value} \ v$, a proposal-value to be committed.
  \end{itemize}

\noindent \textbf{Description:}\\
Commits the corresponding block for the proposal value received into the ledger.
The proposal value must be committable (which implies validity and availability of the full
ledger entry and seed).
Line 2 means the algorithm will append the block contained in the proposal $\mathsf{RetrieveProposal}(v)$.
Afterwards, it updates the balance table $BT$ with all state changes called for the committed entry.
The function $\mathsf{UpdateBT}(.)$ is responsible for updating the table by incorporating all changes
outlined by transactions in the block body (we defer to the specifications for further details). 

% ----------------------------------------------------------------------------------------------

\begin{algorithm}[H]\label{algo:verify-vote}
    \begin{algorithmic}[1]
    \Function{$\mathsf{VerifyVote}$}{$Vote \ vt$}
        \State $valid := vt_r \leq r+2$
        
        \If{$vt_s = 0$}
            \State $valid := valid \land vt.v.p_{orig} \leq vt_p$
            \If{$vt_p = vt.v.p_{orig}$}
                \State $valid := valid \land vt.v.I_{orig} = vt_I$
            \EndIf
        \EndIf
        
        \If{$vt_s \in \{propose, soft, cert, late, redo\}$}
            \State $valid := valid \land vt.v \neq \bot$
        \ElsIf{$vt_s = down$}
            \State $valid := valid \land vt.v = \bot$
        \EndIf

        \State $valid := valid \land \mathsf{VerifyPartSignature}(vt)$
        \State $valid := valid \land \mathsf{VerifyVRF}(vt_{\pi}, vt_I, vt_r, vt_p, vt_s)$

        \State \Return $valid$
    \EndFunction
    \end{algorithmic}
    \caption{\underline{VerifyVote}}
\end{algorithm}

\noindent \textbf{Description:}\\
Vote verification gets an unauthenticated vote and returns an authenticated vote and a
boolean indicating whether authentication succeeded or failed.
The procedure retrieves the relevant ephemeral participation public key for the user given the vote round $vt_r$,
checking that it exists and taking into account the lookback period $\delta_s\delta_b$.
It then checks that the currently executing round (minus lookback) is inside the validity interval for said key.
Finally, the internal cryptographic signature verification function (leveraging Algorand's fork of the sodium C library)
is called to check the signature itself against the provided key and the vote serialized as plain bytes.

% % ----------------------------------------------------------------------------------------------

% \begin{algorithm}[H]\label{algo:verify-part-sign}
%     \begin{algorithmic}[1]
%     \Function{$\mathsf{VerifyPartSignature}$}{$Vote \ vt$}
        
%         //get voter's relevant ephemeral key for this round
%         \State x

%         //verify key's validity interval
%         \State x

%         //use the cryptographic signature verification function
%         \Return $\mathsf{ed25519\_verify}(part_{pk}, \mathsf{encode}(vt))$
%     \EndFunction
%     \end{algorithmic}
%     \caption{\underline{VerifyVote}}
% \end{algorithm}

% \noindent \textbf{Description:}\\


% ----------------------------------------------------------------------------------------------

\begin{algorithm}[H]
    \begin{algorithmic}[1]
    \Function{$\mathsf{RetrieveProposal}$}{$Proposal_{value} \ v$}

    \If{$\exists prop \in P \ | \ Proposal_{value}(prop) = v$}
        \State \Return $prop$
    \Else
        \State \Return $\bot$
    \EndIf

    \EndFunction
    \end{algorithmic}
    \caption{\underline{Proposal}}
\end{algorithm}

\noindent \textbf{Description:}\\ Gets the proposal associated to a given proposal-value, 
if it has been observed in the current context.
Otherwise, it returns $\bot$, defined as the ``empty proposal'' (special value where all
proposal fields are zeroes).
%esto no esta en una sola referencia de codigo, sino que abstrae varias cosas
%internamente hay una tabla que matchea proposal votes (que contienen el proposal value)
%con bloques. Esto es porque la validacion es asincronica y necesitas, si llegas a validar la proposal,
%saber que contas con el voto para no descartarla y desperdiciar todo ese computo (que es caro)
% ----------------------------------------------------------------------------------------------

\begin{algorithm}[H]
    \begin{algorithmic}[1]
    \Function{$\mathsf{MakeProposal}$}{$Block \ e, \pi_{seed}, uint64 \ p_{orig}, Address \ I_{orig}$}
    %el bloque se asume ya validado

        \State $proposal \ prop := (e, \pi_{seed}, p_{orig}, I_{orig})$
        \Return $prop$

    \EndFunction
    \end{algorithmic}
    \caption{\underline{Make Proposal}}
\end{algorithm}

% https://github.com/algorand/go-algorand/blob/master/agreement/proposal.go#L104

\noindent \textbf{Description:}\\ This function takes a block (which should have been validated by the node),
a VRF proof of the seed in the block header, the original period in which it was created and the address of the
original proposer (creator) of said block. It then packages the block, and all the other data which corresponds
with everything needed to validate it, into a $proposal$ structure.
% ----------------------------------------------------------------------------------------------

\begin{algorithm}[H]\label{proposal-value}
    \begin{algorithmic}[1]
    \Function{$\mathsf{Proposal_{value}}$}{$Proposal \ pp$}

    \State $proposal_{value} \ v := (pp_{I_{orig}}, pp_{p_{orig}}, \mathsf{H}(pp_e), \mathsf{H}(\mathsf{Encoding}(pp)))$

    \State \Return $v$

    \EndFunction
    \end{algorithmic}
    \caption{\underline{Proposal-value}}
\end{algorithm}

\noindent \textbf{Description:}\\ Constructs a proposal-value $v$ for the input block $e$.
The resulting proposal-value is a tuple that contains the address of the original proposer for
the block, the original period in which it was assembled, the hash of the block (taken as plain bytes) 
and the hash of the msgpack encoding of the block.
%https://github.com/algorand/go-algorand/blob/master/agreement/proposal.go#L78C1-L78C6

% ----------------------------------------------------------------------------------------------

\begin{algorithm}[H]
    \caption{\underline{VerifyProposal}}
    \label{algo:verify-proposal}
    \begin{algorithmic}[1]
    \Function{$\mathsf{VerifyProposal}$}{$ProposalPayload \ pp$}

    \State $valid := \mathsf{ValidEntry}(pp_e, pp_{\pi_{seed}}, L)$
    \State $valid := valid \land \mathsf{VerifySignature}(pp_y)$

    \EndFunction
    \end{algorithmic}
\end{algorithm}

\noindent \textbf{Description:}\\

% ----------------------------------------------------------------------------------------------

\begin{algorithm}[H]\label{algo:verify-bundle}
    \begin{algorithmic}[1]
    \Function{$\mathsf{VerifyBundle}$}{$Bundle \ b$}

    //all individual votes are valid
    \State $valid := (\forall vt \in b)(\mathsf{VerifyVote}(vt))$
    
    //no two votes are the same
    \State $valid := valid \land (\forall i,k \in \mathbb{Z})(vt_i \in b \land vt_k \in b \land vt_i = vt_k \implies i=k)$

    //round, period and step must all match
    \State $valid := valid \land (\forall vt \in b)(vt_r = b_r \land vt_p = b_p \land vt_s = b_s)$
  
    %P*? Equivocation vote solo vale para soft bundles. Eso es correcto?
    //all votes should either be for the same value or be equivocation votes
    \State $valid := valid \land (\forall vt \in b)(vt_v = b_v \lor (b_s = soft \land \mathsf{IsEquivocation}(vt_v, b)))$

    //summation of weights should surpass the relevant threshold
    \State $valid := valid \land  \sum_{vt \in b}(vt_j) \geq \mathsf{CommitteeThreshold}(b_s)$

    \State \Return $valid$

    \EndFunction
    \end{algorithmic}
    \caption{\underline{VerifyBundle}}
\end{algorithm}

\noindent \textbf{Description:}\\
This procedure verifies a received Bundle, through a series 
of checks.
On line 2, it ensures that all individual constituting $b$
are individually valid.
Line 3 checks that the Bundle has no repeat votes.
Line 4 checks that all votes in $b$ match the same $(r,p,s)$
execution context.
Line 5 checks that all votes are towards the same proposal value,
with the exception of equivocation votes which are interpreted as wildcard
towards any proposal value.
%aca: are equiv votes just valid on soft bundles? Preguntar
Finally, on line 6 it checks that the sum of the weight of all constituting
votes is greater or equal to the corresponding committee threshold (otherwise, 
the bundle would not be complete).
After all aformentioned checks have passed, a boolean true value is returned.
If any of them failed, a false value is returned instead, and $b$ is deemed invalid.

Here
$$
CommitteeSize(s):= \left\{
\begin{array}{rl}
     20 & \text{ if }s = Proposal \\
   2990 & \text{ if }s = Soft \\
   1500 & \text{ if }s = Cert \\
    500 & \text{ if }s = Late \\
   2400 & \text{ if }s = Redo \\
   6000 & \text{ if }s = Down \\
   5000 & \text{otherwise}
\end{array}
\right.
$$
Committee Threshold: $CommitteeThreshold(s)$ is a 64-bit integer defined as follows:
$$
CommitteeThreshold(s):= \left\{
\begin{array}{rl}
     0 &  \text{ if }s = Proposal \\
  2267 &  \text{ if }s = Soft \\
  1112 &  \text{ if }s = Cert \\
   320 &  \text{ if }s = Late \\
  1768 &  \text{ if }s = Redo \\
  4560 &  \text{ if }s = Down \\
  3838 &  \text{otherwise}
\end{array}
\right.
$$

% ----------------------------------------------------------------------------------------------

\begin{algorithm}[H]\label{algo:start-new-round}
    \caption{\underline{Start New Round}}
    \label{algo:start-new-round}
    \begin{algorithmic}[1]
    \Function{$\mathsf{StartNewRound}$}{$uint64 \ newRound$}
    \State $\bar{s} := s$
    \State $\bar{v} := \bot$
    \State $r := newRound$
    \State $p := 0$
    \State $s := proposal$
    \State Reset $time$.
    \EndFunction
    \end{algorithmic}
\end{algorithm}

\noindent \textbf{Description:}\\
Procedure used to set all state variables necessary to start a new round.
Last finished step is set to the step where the previous round culminated.
Pinned proposal-value is set to the empty proposal-value as the round is just starting.
The current round number gets updated to the freshly started round.
Period and step number are set to $0$ and $proposal=0$ respectively.

% ----------------------------------------------------------------------------------------------

\begin{algorithm}[H]
    \caption{\underline{Start New Period}}
    \label{algo:start-new-period}
    \begin{algorithmic}[1]
    \Function{$\mathsf{StartNewPeriod}$}{$uint64 \ newPeriod$}

    \State $\bar{s} := s$
    \State $s := proposal$

    \If{$\exists v=Proposal_{value}(e),s^\prime \ | e\in P, \ v \neq \bot \land (s^\prime = soft \lor s^\prime > cert)  
    \land Bundle(r, newPeriod-1, s, v) \subset V$}
        \State $\bar{v} := v$
    \ElsIf{$\sigma \neq \bot$}
        \State $\bar{v} := \sigma$
    \EndIf

    \State $p := newPeriod$
    \State Reset $time$.
    \EndFunction
    \end{algorithmic}
\end{algorithm}

$\sigma$ is the sole proposal-value for which a soft bundle has been observed (again, 
in the current $(r,p)$ context), or $\bot$ if no valid soft bundle has been observed by the 
node.

\noindent \textbf{Description:}\\
Procedure used to set all state variables necessary to start a new period.
Note that we start a new period on observing a recovery bundle for a proposal-value, whether it be
an actual value or the special empty value $\bot$.
On lines 2 and 3, the node sets the last finished step to the currently executing step when a new period's
start was observed, and the current step to $proposal$.
Then it checks for the existence of a non-$cert$ step bundle in the period immediately before the new one (line 4), 
for a proposal-value that's anything but the empty value $\bot$ (note that if the node had observed a $cert$
bundle in the previous period, it would not be starting a new period and it would be instead attempting to commit
the relevant entry and subsequently start a new round). If such bundle for a proposal-value $v$ exists, the pinned 
value is updated to $v$.
Otherwise, and assuming implicitly in this case that the bundle that caused the period switch is of value $\bot$,
a check for the special $\sigma$ value is performed on line 6, where $p$ is the period that was being executed 
by the node up until a new period was observed. If $\sigma$ is a valid non-empty proposal-value, the pinned 
value $\bar{v}$ is set to this (line 7).
If none of the above conditions were met, the pinned value remains unchanged going into the new period.
Finally, the node updates $p$ to match the period to start.

% ----------------------------------------------------------------------------------------------

\begin{algorithm}[H]
    \caption{\underline{Garbage Collect}}
    \label{algo:garbage-collect}
    \begin{algorithmic}[1]
    \Function{$\mathsf{GarbageCollect}$}{$r^\prime, p^\prime$}

    \State $V_{(r^\prime,p^\prime-1)} := \{ vt \in V | vt.r < r \lor (vt_r=r^\prime \land vt_p + 1 < p^\prime) \}$
    \State $P_{(r^\prime,p^\prime-1)} := \{ pp \in P | pp.r < r \lor (pp_r=r^\prime \land pp_p + 1 < p^\prime) \}$

    \State $V := V\diagdown V_{(r^\prime,p^\prime-1)}$
    \State $P := P\diagdown P_{(r^\prime,p^\prime-1)}$

    \EndFunction
    \end{algorithmic}
\end{algorithm}

\noindent \textbf{Description:}\\
Garbage collection algorithm, for the finished $(r^\prime,p^\prime)\in\mathbb{Z}_{\ge 0}^2$ context.
The procedure discards all votes in $V$ and proposals in $P$ where the round of emission is less than the
new round, or the round of emission is equal to the new round and the period of emission is below the period
directly before the current one.
In particular, when starting a new round both $V$ and $P$ are set to the empty set,
if this is a new period for the same round, it keeps votes and proposals for the current round
and both the current and previous periods.

% ----------------------------------------------------------------------------------------------

\begin{algorithm}[H]
    \caption{\underline{Request Proposal}}
    \label{algo:request-proposal}
    \begin{algorithmic}[1]
    \Function{$\mathsf{RequestProposal}$}{$Proposal_{value} \ v$}
        \State async request $e \neq \bot \ | \ e \in \mathsf{P} \implies \mathsf{RetrieveProposal}(v) == e$ from $\mathsf{PEERS}$ 
    \EndFunction
    \end{algorithmic}
\end{algorithm}

%aca es donde llego sin bloque
%https://github.com/algorand/go-algorand/blob/527d2c53d47f4d20d6dad5798cc0ffd1d37a6af8/agreement/player.go#L359

\noindent \textbf{Description:} \\
This call opens a channel to asynchronously request the block for which the node has
observed a complete certificate, but has not observed a proposal. In particular, it does not
have the corresponding block for ledger commitment.
The specs. allow some implementation divergence in this case.
A node may continue participating in consensus while it asynchronously waits for the proposal
in the open channel for this purpose. When taking this approach, the node is able to vote, but may
not emit votes for a specific value until it has received the missing block or blocks, and may only produce
votes for $\bot$ when applicable.
Alternatively, the node may choose to stall, stopping its participation in consensus until the full ledger is available.

% \marginpar{ver como hacer el request...como lo resuelve el nodo?}

%The Ledger.Wait function (and its variants) seem to be used to wait for the block
% https://github.com/algorand/go-algorand/blob/51f5314422b568526d09fdb74c4c87cfaaa0b4e2/ledger/ledger.go#L747

% ----------------------------------------------------------------------------------------------

\begin{algorithm}[H]
    \caption{\underline{Disconnect from Peer}}
    \label{algo:disconnect-peer}
    \begin{algorithmic}[1]
    \Function{$\mathsf{DisconnectFromPeer}$}{$\mathsf{PEER\_ID}$}
        \State Remove $\mathsf{PEER\_ID}$ from $\mathsf{PEERS}$
    \EndFunction
    \end{algorithmic}
\end{algorithm}

%NOTA: algorand broadcastea txns por pubsub (https://docs.libp2p.io/concepts/pubsub/overview/)
%igual termina todo multiplexado en la misma conexion, asi que el funcionamiento termina siendo similar.

%https://github.com/algorand/go-algorand/blob/527d2c53d47f4d20d6dad5798cc0ffd1d37a6af8/network/p2pNetwork.go#L247

\noindent \textbf{Description:}
Function to send a hint for disconnection from a given peer, on a network level.
$\mathsf{PEER\_ID}$ is a libp2p peer ID, a base58 encoded multihash string.
Refer to libp2p official documentation for further details.
% https://docs.libp2p.io/concepts/fundamentals/peers/#peer-ids-in-multiaddrs
Algorand works using libp2p to setup a P2P network, where nodes gossip messages to one another
through websockets, and mantain a list of active peers.
Consider a peer acts in one of the following ways:
\begin{itemize}
    \item sends badly formed votes, bundles or proposals, %(or transactions? they are handled in a different way),
    %https://github.com/algorand/go-algorand/blob/527d2c53d47f4d20d6dad5798cc0ffd1d37a6af8/agreement/player_test.go#L2243
    \item its connection becomes slow or idle,
    %\item sends messages that produce a read or write error,
    %\item unresolved clique, esto es cuando no pudiste formar un clique, depende de parametros de red
    \item remains the least performing peer for a given amount of time,
    \item requests a disconnect (e.g. is going offline),
    \item sends messages with invalid network credentials (e.g. an invalid peer ID),
    \item its connection is found to be duplicated in the peer list or
    \item on a proposal request scenario, sends more data than requested.
    %https://github.com/algorand/go-algorand/blob/527d2c53d47f4d20d6dad5798cc0ffd1d37a6af8/network/wsPeer.go#L175
\end{itemize}
 
In any of these cases, the outcome of accepting the message is generally adversarial
to the correct functioning of the network. The node disconnects from the peer, closing the websocket and taking
its entry off of the available peer list, and the content of the message is ignored and discarded.
% If the number of available connections dips below a network parameter, a rediscovery subroutine kicks in

% ----------------------------------------------------------------------------------------------

\begin{algorithm}[H]
    \caption{\underline{Resynchronization Attempt}}
    \label{algo:resynchronization-attempt}
    \begin{algorithmic}[1]
    \Function{$\mathsf{ResynchronizationAttempt}$}{\; }

    \State $Val = \bot$

    \If{$\exists v | Bundle(r, p, soft, v) \subset V$}
        \State $\mathsf{Broadcast}(Bundle(r, p, soft, v))$
        \State $val = v$    
    \ElsIf{$\exists s_0 > cert | Bundle(r, p - 1, s_0, \bot) \subset V$}
        \State $\mathsf{Broadcast}(Bundle(r, p - 1, s_0, \bot))$
    \ElsIf{$\exists s_0, v | s_0 > cert \land v \neq \bot \land Bundle(r, p - 1, s_0, v) \subset V$}
        \State $\mathsf{Broadcast}(Bundle(r, p, s_0, v))$
        \State $val = v$
    \EndIf

    \If{$val \neq \bot \land \mathsf{RetrieveProposal}(v) \neq \bot$}
        \State $\mathsf{Broadcast}(\mathsf{RetrieveProposal}(v))$
    \EndIf

    \EndFunction
    \end{algorithmic}
\end{algorithm}

\noindent \textbf{Description:}\\
A resynchronization attempt, performed at the start of all recovery algorithms.
If a soft bundle has been observed for a proposal-value $v$, then the bundle is broadcast.
Otherwise, if a recovery step bundle for an empty proposal-value $\bot$ was observed in the previous period,
It's broadcast.
Else, if there is a recovery step $s_0$ and a non-empty proposal-value $v$ for which a bundle was observed in the previous
period, it's broadcast.
Finally, if any Bundles were broadcast for a proposal-value $v$, the corresponding proposal $\mathsf{RetrieveProposal}(v)$ is broadcast
if it has been observed.\\

% ----------------------------------------------------------------------------------------------

\begin{algorithm}[H]
    \caption{\underline{Broadcast}}
    \label{algo:broadcast}
    \begin{algorithmic}[1]
    \Function{$\mathsf{Broadcast}$}{$data$}

    Send $\mathsf{msg}(data)$ to all peers in $\mathsf{PEERS}$

    \EndFunction
    \end{algorithmic}
\end{algorithm}

\noindent \textbf{Description:}\\
This function serves as a nexus between the networking module and the modules responsible
for running consensus, abstracting away networking details and allowing a node to produce
output for other nodes in the network to observe.
$\mathsf{msg}(.)$ abstracts away the process of packing all data to be sent into the relevant message type,
according to the nature of the data, filling out its type field depending on whether it is a transaction, 
vote, proposal or bundle.

% ----------------------------------------------------------------------------------------------

\begin{algorithm}[H]
    \caption{\underline{Relay}}
    \label{algo:relay}
    \begin{algorithmic}[1]
    \Function{$\mathsf{Relay}$}{$data$}

    Send $\mathsf{msg}(data)$ to all peers in $\mathsf{PEERS}$ except for $\mathsf{SENDER\_PEER}(data)$

    \EndFunction
    \end{algorithmic}
\end{algorithm}

\noindent \textbf{Description:}\\
Similar to the broadcast function, but in this case the node excludes explicitly from the list of senders
a peer whose ID is that of the original sender of the input data.
The function is used to re-send received messages while avoiding unnecesary forwarding loops 
that may congest the network.

% ----------------------------------------------------------------------------------------------

\begin{subsection}{Sortition and seed computation}\label{sect:sort-seed}

In the next set of functions, we make use of special cryptographic computation 
functions $\mathsf{VRF_{prove}}(.)$, $\mathsf{VRF_{verify}}(.)$ and $\mathsf{VRF_{proofToHash}}(.)$.
Implementation-wise, the node makes use of an Algorand specific fork of the sodium library.
\marginpar{CITAR?. Tambien ver si esto va aca, o lo dejamos como subsection o que}. 
Conceptually, the prove algorithm is used to execute a VRF for some given input
data and a given secret VRF key, outputing an 80 byte string which we refer to as sortition proof $\pi$. 
The proof to hash algorithm is a helper function to obtain the sortition hash $sh$ out of the proof
$\pi$. Finally, the verify function is used to check for validity of a VRF result given input data,
a public VRF key, a sortition hash and a proof, certifying that the hash and proof are output by running
an instance of $\mathsf{VRF_{prove}}(.)$ with the corresponding secret VRF key and data.
In other words, \\
$\mathsf{VRF_{verify}}(\pi, sh, I_{VRFKey}) = \mathsf{True} \leftrightarrow 
\mathsf{VRF_{prove}}(in, secrets(I,r^\prime)_{VRFkey}) = \pi \land \mathsf{VRF_{proofToHash}}(\pi) = sh$ \\
for a given round $r^\prime \leq r$ in which there is a valid VRF key pair for $I$.
Refer to the aformentioned library for details on implementation of these cryptographic functions.

\begin{algorithm}[H]
    \caption{\underline{Compute Seed And Proof}}
    \label{algo:compute-seed}
    \begin{algorithmic}[1]
    \Function{$\mathsf{ComputeSeedAndProof}$}{$Address \ I$}
        \If {$p = 0$}
             \State $y := \mathsf{VRF_{prove}}(L[r-\delta_s]_Q, secrets(I)_{VRFkey})$
             \State $\alpha := \mathsf{H}(\mathsf{VRF_{proofToHash}}(y), a_I)$
        \Else
            \State $y := 0$
            \State $\alpha := \mathsf{H}(L[r-\delta_s]_Q)$
        \EndIf

        \If{$r \mod \delta_s \delta_r < \delta_s$}
            \State $Q := \mathsf{H}(\alpha||\mathsf{H}(L[r-\delta_s\delta_r]))$
        \Else
            \State $Q := \mathsf{H}(\alpha)$
        \EndIf

         \State \Return $(Q, y)$
    \EndFunction
    \end{algorithmic}
\end{algorithm}


\noindent \textbf{Arguments:}
\begin{itemize}
    \item $Address \ I$, the address of an online user who will be computing the seed.
  \end{itemize}


\noindent \textbf{Description:}\\ Computes the cryptographic seed that goes in the block for round $r$,
and will be used as a source of randomness for sortition in a future round.
The seed is computed according to whether the function is called in a first period, $p = 0$, or not.
It also computes the proof $\pi_{seed}$, bundled up with the block inside a proposal structure for broadcasting, 
and used by nodes receiving the proposal as part of the proposal validation process.


\noindent \textbf{Returns:} \\
    the computed seed $Q$ for the given block, ledger context, round and period, as well as the sortition proof $\pi_{seed}$
    to validate it

% ----------------------------------------------------------------------------------------------

\begin{algorithm}[H]
    \caption{\underline{Verify Seed}}
    \label{algo:verify-seed}
    \begin{algorithmic}[1]
    \Function{$\mathsf{VerifySeed}$}{$Q, \pi_{seed}, Address \ I_{proposer}$}
        \State $q_0 := \mathsf{L}[r-\delta_s]_{seed}$
            \If {$p = 0$}
                \If {$\neg \mathsf{VRF_{verify}}(\pi_{seed}, q_0, I_{proposer})$}
                    \Return $\mathsf{False}$
                \EndIf
                \State $q_1 := \mathsf{H}(\mathsf{VRF.ProofToHash}(\pi)||I_{proposer})$
            \Else
                \State $q_1 := \mathsf{H}(q_0)$
            \EndIf


        \If{$r \equiv (r \mod \delta_s) \mod \delta_s\delta_r$}
            \State \Return $Q = \mathsf{H}(q_1||\mathsf{H}(\mathsf{L}[r-\delta_s\delta_b]))$
        \Else
            \State \Return $Q = q_1$
        \EndIf
    \EndFunction
    \end{algorithmic}
\end{algorithm}


\noindent \textbf{Arguments:}
\begin{itemize}
    \item $Q$, a 32 byte computed seed to verify
    \item $\pi_{seed}$, the 80 byte proof for the $\mathsf{VRF_{prove}}(.)$ call that computed $Q$
    \item $Address \ I_{proposer}$, the address of the user that proposed a block and computed $Q$
  \end{itemize}


\noindent \textbf{Description:}\\ The seed verification procedure certifies the validity of a computed seed $Q$.


\noindent \textbf{Returns:}\\ A boolean value. $\mathsf{True}$ if the seed $Q$, with proof $\pi_{seed}$, computed by $I$,
    is valid for the current node context, otherwise returns $\mathsf{False}$.

% ----------------------------------------------------------------------------------------------

\begin{algorithm}[H]\label{algo:get-total-online-stake}
    \begin{algorithmic}[1]
        \Function{$\mathsf{getTotalOnlineStake}$}{$r^\prime$}
        
        \State $sum := 0$
        \For{$br \in \mathsf{BT}[r^\prime]$}
            \If {$br_{online} \land br_{VRFkey}$}
                \State $sum := sum + br_{balance}$
            \EndIf
        \EndFor

        \State \Return $sum$

        \EndFunction
    \end{algorithmic}
    \caption{\underline{Get Total Online Stake}}
\end{algorithm}

\noindent \textbf{Arguments:}
\begin{itemize}
    \item $uint64 \ r^\prime$, a valid round ($r^\prime \leq r$, where $r$ is the node's currently executing round).
  \end{itemize}


\noindent \textbf{Description:}\\
This helper function computes the sum of all online stake in a given round.
For each account that had been created up to round $r^\prime$, that is registered as online 
and has an active VRF public key in its balance record for the given $r^\prime$, 
it adds the recorded balance for that context.
It returns the sum of that balance over all accounts, being the total online stake
in the network on that particular round $r^\prime$.

\noindent \textbf{Returns:} \\
the total stake at play in the relevant round $r^\prime$.

% ----------------------------------------------------------------------------------------------

\begin{algorithm}[H]
    \caption{Sortition}
    \label{algo:sortition}
    \begin{algorithmic}[1]
    \Function{$\mathsf{Sortition}$}{$Address \ I, uint64 \ round, uint64 \ period, uint8 \ step$}
        \State $Q := \mathsf{L}[r - \delta_s]_{Q}$

        \State $\pi := \mathsf{VRF_{prove}}(Q||round||period||step, \mathsf{secrets}(I, r-\delta_s\delta_r)_{VRFKey})$
        \State $sh := \mathsf{VRF_{ProofToHash}}(\pi)$

        \State $w := \mathsf{BT}[round-\delta_s\delta_r][I]_{balance}$
        \State $W := \mathsf{getTotalOnlineStake}(round-\delta_s\delta_r)$
        \State $\tau := \mathsf{CommitteeSize}(step)$
        \State $t := \frac{\tau}{W}$
        \State $j := 0$
        \While{$\frac{sh}{2^{\mathsf{log_2}(sh)}}\notin [ \sum_{k=0}^j\mathsf{B}(k;w,t), \sum_{k=0}^{j+1}\mathsf{B}(k;w,t))$}
            \State $j := j+1$
        \EndWhile
        \State \Return $\mathsf{credentials}(sh, \pi, j)$
    \EndFunction
    \end{algorithmic}
    \caption{\underline{Sortition}}
\end{algorithm}


\noindent \textbf{Arguments:}
\begin{itemize}
    \item $Address \ I$, the address of an online account. Their keys are used for computation of VRFs.
    \item $uint64 \ round$, a round that is valid according to node context ($round \leq r$).
    \item $uint64 \ period$, a period that is valid according to node context ($period \leq p$).
    \item $uint8 \ step$, a step to run sortition. Used to get specific step-dependant committee size and threshold.
\end{itemize}

\noindent \textbf{Description:}\marginpar{A lot of notation to describe. Review.}

The Sortition procedure is one of the most important subroutines in the main algorithm, as it is 
used in multiple stages and contexts.
Generally, it manages to pseudo-randomly but verifiably (through the use of a Verifiable Random 
Function) select a user with probability proportional
to their weight (i.e., stake) by returning a $j$ parameter, which indicates the number of times that 
specific user was chosen.
The function starts by retrieving a sortition seed $Q$.
This seed will be a tamper-proof source of randmoness committed as part of a block header $\delta_s$ rounds in
the past.
Then, on line 3 it computes the sortition proof $\pi$ by running $\mathsf{VRF_prove}(.)$, 
using the secret VRF key from user $I$, who should have a valid VRF public/private key pair 
for $\delta_s\delta_r$ rounds in past.
Algorithmically, every monetary unit the user has is considered a ``sub-user'', and then each one 
of them is selected with probability $t = \frac{\tau}{W}$,
where $\tau$ is the expected amount of users to be selected for the given role, and $W$ is the total
stake online for the relevant round.
The semi-open interval $[0,1)$ is then split into consecutive intervals using an accumulated 
binomial distribution, and wherever the fraction $\frac{sh}{2^{\mathsf{log_2}(sh)}}$
belongs to the interval, that's the amount of chosen sub-users for the subroutine caller.\\

\noindent \textbf{Returns:}\\
    an object of type $credentials$, containing the sortition hash and proof (output of VRF
    computation) and an unsigned integer $j$ representing the weight that player has in the committee,
    for the desired round, period and step.

% ----------------------------------------------------------------------------------------------


\begin{algorithm}[H]
    \begin{algorithmic}[1]
    \Function{$\mathsf{VerifySortition}$}{$I, \pi, round, period, step$}
        \State $Q := \mathsf{L}[r - \delta_s]_{Q}$
        \State $I_{VRFKey} := \mathsf{BT}[round-\delta_s\delta_r][I]_{VRFKey}$
        \State $success := \mathsf{VRF_{verify}}(\pi, Q||round||period||step, I_{VRFKey})$
        \IfThen{$\neg success$}{$\mathsf{return} \ 0$} \\

        \State $h := \mathsf{VRF_{proofToHash}}(\pi)$
        \State $\tau := \mathsf{CommitteeSize}(step)$
        \State $w := \mathsf{BT}[round-\delta_s\delta_r][I]_{balance}$
        \State $W := \mathsf{getTotalOnlineStake}(round-\delta_s\delta_r)$
        \State $t := \frac{\tau}{W}$
        \State $j := 0$
        \While{$\frac{sh}{2^{\mathsf{log_2}(h)}} \notin [\sum_{k=0}^j\mathsf{B}(k;w,t), \sum_{k=0}^{j+1}\mathsf{B}(k;w,t))$}
            \State $j := j+1$
        \EndWhile
        \Return $j$
    \EndFunction
    \end{algorithmic}
    \caption{\underline{Verify Sortition}}
\end{algorithm}

\noindent \textbf{Arguments:}
\begin{itemize}
    \item $I$, a user's address
    \item $Q$, the 32 byte sortition seed to be used
    \item $\pi$, an 80 byte VRF proof
    \item $round$, the round number to be used inside the VRF function
    \item $period$, the period to be used inside the VRF function
    \item $step$, the step to be used for committee size and the VRF function
  \end{itemize}

\noindent \textbf{Description:}\\
The sortition verification procedure takes the address of an account,
a valid sortition seed to be used as a source of entropy,
a VRF proof $\pi$ obtained from running $\mathsf{VRF_{prove}}$ and 
a thruple representing the consensus context of a node ($round$, $period$ and $step$) and utilizes 
VRF properties to verify the validity of said output.
Once the check is passed, it repeats Sortition's sub-user selection procedure, 
and outputs the amount of times the user was chosen according to their respective 
observed stake for the relevant $round$.\\

\noindent \textbf{Returns:} \\
an integer $j$ that will be positive (larger than 0) if the user has been 
    selected, and it's size corresponds to the participation weight for a given committee member.
    If the user $I$ is not chosen as a committee member for the context passed, 
    a value of $j = 0$ is returned.

\end{subsection}

% {\bf MISSING VRF(), VerifyVRF()}

\end{section}
% ----------------------------------------------------------------------------------------------
% \section*{Appendix: Notation}
\begin{section}{Appendix: Notation}


\begin{itemize}
    \item $credentials$, a data structure containing the results of running the sortition algorithm 
    for a specified account
    \item $sh$, the 64-byte sortition hash output by running $VRF_{a_{sk}}$ algorithm over a desired input.
    Usually wrapped inside a $credentials$ structure.
    \item $\pi$, the 32-byte sortition proof output by running $VRF_{a_{sk}}$ algorithm over a desired input.
    Usually wrapped inside a $credentials$ structure.
    \item $\pi_{seed}$, the 32-byte sortition proof output by running $VRF_{a_{sk}}$ algorithm for a cryptographic 
    seed computation.
    \item $j$, an unsigned 64-bit integer, representing the weight of a given account's vote inside a specific committee
    (for a given round, period and step).
    Usually wrapped inside a $credentials$ structure.
    \item $\lambda_0$, time interval for the node to accept block proposals (when $p=0$), after which it 
    chooses the observed block with the highest priority (lowest hash).
    \item $\lambda$, same as $\lambda_0$ but for $p > 0$.
    \item $\delta_s$, sortition seed renewal rate, in number of rounds. Set to $2$ in 
    \href{https://github.com/algorandfoundation/specs}{specs.} as of July 2023.
    \item $\delta_b$, balance lookback interval, in number of rounds. Set to $320$ in 
    \href{https://github.com/algorandfoundation/specs}{specs.}

    % \item Public keys $a_{pk}$ for every account linked to the node (doubles as their respective addresses)
    % \item Public participation keys $a_{p\_partkey}$ for all accounts registered as online (private participation keys are kept
    % securely by respective users and should not be directly accesible by the node)
    % \item Two levels of ephemeral keys, signed according to the signing scheme described in \href{https://github.com/algorandfoundation/specs}{specs.} (where 
    % first level keys are signed with the participation keys, and second level (aka. leaf) ephemeral keys are signed with 
    % first level ephemeral keys). 
    % These keys are used for actual participation in the consensus (abstracted as $a_{sk}$ in the following code)
    % They are ephemeral because they live for a single round, after which they are deleted
    % \item A balance table $BT$ for all accounts linked to the node, for the round $SL + R$ rounds before the one 
    % currently running
\end{itemize}

\end{section}


%makeCredential: Makes unauthenticated credential (aka. calls VRF using secrets.Prove(sel)).
%https://github.com/algorand/go-algorand/blob/f155addc1c522d1464bca71da9af495ed71ce820/data/committee/credential.go#L125
%The selector contains Seed, round, period, step, in a hashable struct
%Prove(hashable h) outputs a VRF proof 
%then Verify() https://github.com/algorand/go-algorand/blob/master/data/committee/credential.go#L75
%is called to obtain weight and VRF hash. In order to decorrelate accounts that might have the same VRF keypair,
%the VRFHash is computed as H(VRFOutputHash || AccountAddress)

% ----------------------------------------------------------------------------------------------

\bibliographystyle{alpha}
\bibliography{bibliography}

% ----------------------------------------------------------------------------------------------
\printindex
\end{document}




% misssing
% falta explicar como las accounts hacen online / offline
% falta hablar de state proofs
% transaction reference