\documentclass[10pt,a4paper]{article}
\usepackage[utf8]{inputenc} % para poder usar tildes en archivos UTF-8
\usepackage{babel} % para que comandos como \today den el resultado en Ingles
\usepackage{a4wide} % márgenes un poco más anchos que lo usual
%\usepackage{caratula}
% \usepackage[left=3cm,right=3cm,bottom=3cm,top=3cm]{geometry}

\usepackage{float}

% Comandos para simbolos matematicos.
\usepackage{amsmath, amssymb, tabularx}

% Comandos para referencias
\usepackage{natbib}

% Comandos para Figuras, Graficos, Tikz etc.
\usepackage{tikz}
\usepackage{epsfig}
\usepackage{pgfplots}
\usepackage{graphicx}
\usepackage{epsfig}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{svg}
\setsvg{inkscape=inkscape -z -D}

% Comandos para teoremas etc.
\usepackage{amsthm}
% \newtheorem{theorem}{Teorema}
% \newtheorem{lemma}[theorem]{Lema}
% \newtheorem{proposition}[theorem]{Proposición}
% \newtheorem{remark}{Observación}
% \newtheorem{corollary}{Corolario}
% \newproof{proof}{Demostración}

% Comandos para algoritmos.
\usepackage[noend]{algpseudocode}
\usepackage{algorithm}
\algnewcommand{\IfThenElse}[3]{% \IfThenElse{<if>}{<then>}{<else>}
    \State \algorithmicif\ #1\ 
    \algorithmicthen\ #2\ 
    \algorithmicelse\ #3}
\algnewcommand{\IfThen}[2]{% \IfThenElse{<if>}{<then>}
    \State \algorithmicif\ #1\ \algorithmicthen\ #2}
\pgfplotsset{compat=1.16}


\usepackage{marginnote}
%TODO
%EXPLICAR parametros globales
%Explicar parametros de entrada de cada algoritmo y de salida

\author{AdP, CoinFabrik}
\title{Algorand Protocol Description}

\begin{document}
\maketitle
\tableofcontents

\begin{section}{Introduction}
In the following document we present a detailed pseudocode interpretation 
of the program run by an Algorand node with at least one online (aka. 
participating)
account. We attempt to explain the 5 main stages of the code supporting 
the protocol in a clear and concise way.
This work aims to provide a basis for an Algorand blockchain simulator 
currently in development. \newline

\noindent \textbf{Global parameters}:
\begin{itemize}
    \item $R$ = sortition seed renewal rate (in number of rounds). Set to 2 in the specs
    as of December 2022
    \item $MAX\_STEPS$ = maximum number of allowed steps in the main algorithm. Defined 
    as 255 in the specs.
    \item $\tau_{step}$ = expected number of members on a regular step committee
    \item $\tau_{final}$ = expected number of members on a final consensus achieving committee
    \item $T_{step}$ = fraction of expected members for a voting committee on a given step
    \item $T_{step}$ = fraction of expected members for a voting committee on the final step (step = 2). If observed,
    achieves final consensus on the given block hash
    \item $\lambda_{proposal}$ = time interval for the node to accept block proposals, after
    which it chooses the observed block with the highest priority (lowest hash) 
    \item $\lambda_{block}$ = waiting time for the full block to be received once decided by vote.
    If no full block is received, the node falls back to the empty block.
  \end{itemize}

On top of that, each node may run in favour of different accounts. To do this,
it needs the following parameters. 
Let $A=\{a\}$ be a collection of accounts $a$.
\noindent \textbf{Account parameters}:
\begin{itemize}
    \item A pair of public and private keys $a_{pk}, a_{sk}$ (although the secret key may be unnecessary)
    \item ephemeral keys....
\end{itemize}

\end{section}
% ------------------------------------------------------------------------
\begin{section}{Main algorithm}

Assume right now that a given node is fixed, we are at round $r$,
this node has access to a set of accounts $a\in A$. Moreover,
the account owner has computed for each round a round 
leaf ephemeral key $a_{sk}$.
The main algorithm goes over the following steps on every round.
\begin{itemize}
    \item block creation: each node may assemble a block, which includes 
transactions and metadata.
    \item block proposal: each block is going to run the VRF algorithm
    to decide whether it should participate in the next stage. If it
    gets selected, then it is going to assemble and then send the block 
    proposal to the other nodes.
\end{itemize}

% --------------------------------------------------------------------
\begin{subsection}{Block Creation}

\begin{algorithm}
    \begin{algorithmic}[1]
    \Function{$\mathsf{BlockCreation}()$}{transactionPool}
    
    \State $Pick$ $transactions$ $from$ $transactionPool$
    \State \Return $\mathrm{Block}$    
    \EndFunction
    \end{algorithmic}
    \caption{\underline{Block creation}}
    \label{alg:fuerza_bruta}
\end{algorithm}

\noindent \textbf{Arguments:}
\begin{itemize}
    \item The local pending transaction pool, which should be accesible to the node\\
  \end{itemize}

\noindent \textbf{Description:}\\
The Algorand protocol specs (\cite{cryptoeprint:2017/454}) do not ensure a specific way 
or internal order in which transactions are added to the block.
%In fact, they don't force transactions to be added at all, being entirely possible 
%for a node to propose an empty block.
More research is needed on how block data is put together.
Block metadata is added later (see below \ref{sect:metadata} for more 
details).

\noindent \textbf{Returns:} 
A full block, consisting of a variable number of transactions, and the following metadata:
\begin{itemize}
    \item round $r$
    \item genesis identifier
    \item upgrade vote
    \item timestamp
    \item seed
    \item reward updates
    \item crytographic commitment to txn sequence
    \item crytographic commitment to txn sequence SHA256
    \item previous block hash
    \item txn counter
    \item newly expired participation keys
  \end{itemize}

\end{subsection}
% --------------------------------------------------------------------
\begin{subsection}{Block Gossip}

\begin{algorithm}
    \begin{algorithmic}[1]
    \Function{$BlockProposal$}{$Block$ $B$, $Accounts$ $A$}
        \State $ProposalMsgsSent = \{\}$ //Set of proposal messages sent by this node

        \For{$a \in A$}
            \State $\langle sorthash, \pi, j\rangle\gets 
            \mathsf{Sortition}(
                a_{sk}, 
                \mathsf{getSortitionSeed}(round), 
                t, 
                role, $ \newline
                ${}$ ${\hskip 5.2cm}\mathsf{sortition}_w(a, round), 
                \mathsf{sortitionW}(round)
            )$
            \If{$j > 0$}
                \State $priority \gets \min\{\mathsf{Hash}(sorthash || n):1\le n\le j\}$
                \State $UserPriorityHashTable[a] = priority$

                \State $msg \gets \mathsf{MSG}(a.pk, \mathsf{Signed}_{a.sk}(priority, \langle sorthash, \pi\rangle))$
                \State $ProposalMsgsSent \cup= msg$
                \State $\mathsf{GOSSIP\_MSG}(a.pk, Signed{a.sk}(priority, \langle sorthash, \pi\rangle))$
            \EndIf
        \EndFor\

        \While{$elapsed$ $time$ $< proposal$ $time$}
            \State $incomingMsgs.push(listen())$
        \EndWhile\

        \State $msgs \gets incomingMsgs[round, step=0]$

        \State $lowestHashMsg \gets m\ |\ m.priority = \min
        \{\mathsf{m.priority\ \in incomingMsgs : \forall m \text{ s.t. } $\newline
        ${ }${\hskip 3cm} $\mathsf{verifySortition}}(m.sorthash, m.pi, m.pk) \& \mathsf{ValidateMsg}(m) \}$

        \State $FullBlockToPropose \gets empty\_block(round)$

        \If{$lowestHashMsg \in msgsSent$}
            \State $FullBlockToPropose \gets B$
            \State $FullBlockToPropose.seed \gets \mathsf{ComputeSeed}(ctx, r, B)$
            \State $\mathsf{GOSSIP\_MSG}(a_{pk}, \mathsf{Signed}_{a_{sk}}(B, \langle sorthash, \pi \rangle))$
        \Else
        {
            \While{$elapsed$ $time < fullblock time$}
                \State $incomingMsgs.push(listen())$
                \State $m \gets incomingMsgs.back()$
                \If{$ValidateMsg(m)$ \& $lowestHashMsg.blockHash=\matshf{Hash}(m.FullBlock)$}
                    \State $FullBlockToPropose \gets m.FullBlock$
                \EndIf
            \EndWhile
        }
        \EndIf
        \Return $H(FullBlockToPropose)$
    \EndFunction
    \end{algorithmic}
    \caption{\underline{Block proposal}}
\end{algorithm}\marginpar{Que hace la linea 9. No entiendo}

\newpage
\noindent{\bf Arguments:}
\begin{itemize}
    \item A block $B$ received from the previous stage
    \item A list of online accounts  $A=\{a\}$ associated with this node
    \item ephemeral keys
    \item public key associated to these accounts
  \end{itemize}
\noindent \textbf{Description:}\\
The {\bf block proposal} stage (step 0 on specs) is the first stage of the 
consensus algorithm. 
First, the node loops through all their online accounts ($a\in A$), 
running the sortition subroutine ($\mathsf{sortition}()$).
The sortition subroutine determines if an account $a$ is selected to 
${sorthash}$, a proof of the sortition $\pi$, and an integer $j\ge 0$
that is used to prioritize votes.

If $j>0$ then the address $a$ gets to vote and proceeds as follows.
For this account $a$ and this triplet $\langle sorthash, \pi, j\rangle$
it computes the hashes $\{ \mathsf{Hash}(sorthash \| n):1\le n\le j\}$
and keeps the minimum (line 6), which we set as the $priority$ of this
account for this round. 
By calling the $\mathsf{GOSSIP\_MSG}()$ function, it proceeds to gossip
(broadcast) the priority, sortition hash and proof to other nodes.
\marginpar{Que es la UserPriorityHashTable?? Nunca vuelve a referenciarla}
It further includes the public key $a_{pk}$ for the account $a$ and the
signature of the triplet $(priority, \langle sorthash, \pi\rangle$ with the 
leaf ephemeral key associated with the account $a$ and the round $r$.

In the lines 11 to 15, the algorithm accepts block proposals (in the same 
format as gossiped) from other accounts until $proposal time$ is reached.
\marginpar{De donde sale proposal time?}
For each block proposal received it only keeps the one with the lowest 
priority validating the block before accepting it as a possible proposal.\marginpar{Que quiere decir validar?}

Finally, in lines 16-25, the algorithm will select a block as 
follows. 
Assume the elapsed time has been reached. 
If the selected proposal came from this node, the seed is computed 
and added into the finished block's metadata. 
Then, the complete block is gossipped to the network.
In the most common case where the proposal is not the one selected 
locally by the node, it waits for another pre-designated time to 
receive the full block from the network.
In case of timeout in this last stage, it falls back to the empty block.\\

\noindent \textbf{Returns:}
\begin{itemize}
    \item The hash of a full block, whether a block proposed by a user (including users whose accounts are 
    linked to this node) or an empty block in any of the special cases mentioned above
  \end{itemize}

\begin{algorithm}[H]
    \begin{algorithmic}[H]
    \Function{$SoftVote$}{$BlockHash$}
    
    \State $CommitteeVote(ctx, round, REDUCTION\_ONE, \tau_{step}, BlockHash)$
    \State $hblock \gets CountVotes(ctx, round, REDUCTION\_ONE, T_{step}, \tau_{step}, \lambda_{block} + \lambda_{step})$

    \State $empty\_hash \gets H(Empty(round, H(ctx.last\_block)))$ 
    \If{$hblock = TIMEOUT$}
        \State $CommitteeVote(ctx, round, REDUCTION\_TWO, \tau_{step}, empty\_hash)$
    \Else
        {\State $CommitteeVote(ctx, round, REDUCTION\_TWO, \tau_{step}, hblock)$}
    \EndIf\

    \State $hblock \gets CountVotes(ctx, round, REDUCTION\_TWO, T_{step}, \tau_{step}, \lambda_{step})$ 

    \IfThenElse{$hblock = TIMEOUT$}{$\Return$ $empty\_hash$}{$\Return$ $hblock$}

    \EndFunction
    \end{algorithmic}
    \caption{\underline{Soft Vote}}
\end{algorithm}


\end{subsection}
% --------------------------------------------------------------------
\begin{subsection}{Soft Vote}

\noindent \textbf{Arguments:}
\begin{itemize}
    \item A block hash, $BlockHash$ received from the previous stage (block proposal)
  \end{itemize}

\noindent \textbf{Description:}\\
The soft vote stage (step 1, or labeled as reduction in the ASBAC paper) aims to reduce any ammount of potentially conflicting proposed blocks in the stage prior into a binary choice, either a block proposed by a user or an empty one.
In the first sub-step, each commitee member gossips the proposed block, and then does a preliminary vote count while it waits for other nodes to catch up.
In the second sub-step, committee members vote for the hash that received at least the ammount of votes set by the threshold for this step, or the hash of the default empty block if no hash was observed to receive enough votes.
It relies heavily on the assumption that, if the block proposer was honest, most users will get to the soft vote stage with the same hblock parameter.
However if the proposer was dishonest, then no single hblock may be popular enough to cross the threshold (and therefore this stage will return an empty\_hash).
Therefore, there will at most be one non-empty block that can be returned by soft vote for all honest users.\\

\noindent \textbf{Returns:}
\begin{itemize}
    \item A block hash, chosen by a majority of users in the soft vote / reduction stage 
    (could be the empty block hash)
  \end{itemize}



\end{subsection}
% --------------------------------------------------------------------
\begin{subsection}{Block Certification}
    \begin{algorithm}[H]
        \begin{algorithmic}[H]
        \Function{$CertifyVote$}{$hblock$}
        \State $localBlockHash \gets hblock$
    
        \State $step \gets 2$
        \While{$step < 256$}
            \\
            \State $\langle hblock, bConfirmed \rangle \gets BLOCK\_STEP(hblock, localBlockHash, step)$
            \If{$bConfirmed$}{ $\Return$ $hblock$}
            \EndIf
            \State $step++$\\
       
            \State $ \langle hblock, bConfirmed \rangle \gets EMPTY\_STEP(hblock,step)$
            \If{$bConfirmed$}{ $\Return$ $hblock$}
            \EndIf
            \State $step++$\\
    
            \State $CommonCoinFlipVote(hblock, step)$
            \State $step++$
        \EndWhile
        \State $HangForever()$
        \EndFunction
        \end{algorithmic}
        \caption{\underline{CertifyVote}}
    \end{algorithm}
    
\noindent \textbf{Arguments:}
\begin{itemize}
    \item A block hash, $BlockHash$ received from the previous stage (soft vote)
  \end{itemize}

\noindent \textbf{Description:}\\
The certify vote stage (which potentially encompasses steps 2 through 255) is the core of the BA* algorithm.
The main loop executes a maximum of 254 times (from step 2 to step 255, labeled ``cert'' and ``down'' 
respectively on the specs).
This is to avoid an attacker indefinitely postponing consensus in a compromised network, giving them a 
small chance to force consensus on their desired block with each iteration.
The main algorithm is comprised of three important procedures: the block step, where, if selected as a 
committee member, votes for the block selected in the soft voting stage and then attempts to confirm it 
by listening to other cast votes until a threshold is met.
If this step times out and no consensus is reached, it moves on to the empty step. Very similar in nature 
to the previous one, in this procedure a vote is cast for the value in hblock and then it attempts to 
confirm an empty block.
Finally, if no consensus is reached on the empty block, it arrives to the common coin procedure, where 
it attempts another vote and vote count for the empty block. If here, no consensus is reached, it uses 
the pseudo-randomness of the VRF hash output to "flip a coin" by looking at the last bit of the lowest 
sortition hash owned by observed committee members.
This makes it so even tho the coin flip is random, most users will observe the same outcome and will 
in turn set their hblock values according to the observed bit. In turn, this prevents an adversary 
from being able to easily predict beforehand what the next vote of a user would be if they were a 
committee user, and therefore the attacker can't force consensus 
sending their vote messages to targeted users in a scenario where the voting is split pretty evenly 
but no block has quite enough votes to push the threshold.\\

\noindent \textbf{Returns:}
\begin{itemize}
    \item A block hash certified by a majority of users, to be confirmed and added to the ledger in the next stage as TENTATIVE or FINAL depending
    on the observed voting share
  \end{itemize}


\end{subsection}
% --------------------------------------------------------------------
\begin{subsection}{Block Confirmation}

\begin{algorithm}[H]
    \begin{algorithmic}[H]
    \Function{$BlockConfirmation$}{$hblock$}

    \State $r \gets CountVotes(ctx, round, FINAL, T_{final}, \tau_{final}, lstep)$
    \If{$r = hblock$}
        \State \Return $\langle FINAL, BlockOfHash(hblock)\rangle$ 
    \Else
    {
        \State \Return $\langle TENTATIVE, BlockOfHash(hblock)\rangle $
    }
    \EndIf
    \EndFunction
    \end{algorithmic}
    \caption{\underline{BlockConfirmation}}
\end{algorithm}


\noindent \textbf{Arguments:}
\begin{itemize}
    \item A block hash, $BlockHash$ received from the previous stage (certify vote)
  \end{itemize}

\noindent \textbf{Description:}\\
Finally, the proposed block (be it an empty block or a specific one 
proposed by a designated user) is confirmed and added to the ledger.
We introduce the notions of FINAL and TENTATIVE consensus.
Specifically, if a block is confirmed in the very first step of the 
certify vote stage, its vote is cast as FINAL.
If enough users reproduce this behavior, the vote count on line 2 for 
votes cast in this fashion is over the required threshold, and the 
consensus is labeled as FINAL.
This means that the block is simultaneously added to the ledger and 
confirmed, as well as immediately confirming any prior blocks that 
could have been labeled TENTATIVE.
If this node is not able to ensure that enough users considered the 
block represented by hblock as FINAL, the consensus is labeled as 
TENTATIVE, and it may be confirmed by a later FINAL block.
The BlockOfHash() function outputs the full block for the provided 
hash, either by returning a locally available copy or by requesting 
it from other users.\\

\noindent \textbf{Returns:}
\begin{itemize}
    \item A full block to be added to the ledger, along with a flag indicating if
    the consensus achieved is TENTATIVE or FINAL in nature
  \end{itemize}


\end{section}
% ------------------------------------------------------------------------------------
\begin{section}{Subroutines}

\begin{algorithm}[H]
    \begin{algorithmic}[H]
    \Function{$CountVotes$}{$ctx, round, step, T, \tau, \lambda$}

    \State $startTime \gets currentTime()$

    \State $counts \gets \{\}$ // hash table, new keys mapped to 0
    \State $voters \gets \{\}$
    \State $msgs \gets incomingMsgs[round,step]$

    \While{$TRUE$}
        \State $m \gets msgs.next()$
        \If{$m = \bot$}
            \If{$ElapsedTime > startTime + \lambda$}
                \State $\Return$ $TIMEOUT$
            \EndIf
        \Else
            \State $ \langle votes, value, sorthash \rangle \gets ProcessMsg(ctx, \tau, m)$
            \IfThen{$m.pk \in voters \lor votes = 0$}{$continue$}
            \State $voters$ $\cup=$ $\{m.pk\}$
            \State $counts[value] += votes$
            \IfThen {$counts[value] \geq T * \tau$}{$\Return$ $value$}
        \EndIf
    \EndWhile
    \EndFunction
    \end{algorithmic}
    \caption{\underline{CountVotes}}
\end{algorithm}

\noindent \textbf{Arguments:}
\begin{itemize}
    \item $ctx$ = a helper structure to retrieve ledger context information (e.g. the last confirmed block)
    \item $round$ = current round number
    \item $step$ = current step number
    \item $T$ = fraction of expected committee members to get the confirmation threshold
    \item $\tau$ = expected number of committee members
    \item $\lambda$ = maximum time to keep running the vote count and awaiting for network messages
  \end{itemize}

\noindent \textbf{Description:}\\
This subroutine counts the votes for any observed block hash value, for a given round and step numbers.
It returns as soon as it finds a value exceeding the specified threshold (which will also vary according to round and step).
If no value is observed to have the required ammount of votes in the predetermined temporal window, it finishes with a TIMEOUT.
It's important to notice that every committee user's vote is processed at most once for the given context.\\

\noindent \textbf{Returns:}
\begin{itemize}
    \item the first block hash value observed to achieve the required threshold, or a TIMEOUT constant if none was found in the
    required time window
  \end{itemize}

\begin{algorithm}[H]
    \begin{algorithmic}[H]
    \Function{$CommitteeVote$}{$ctx, round, step, T, \tau, \lambda$}
    \State $role \gets \langle {committee},round,step\rangle$
    \State $\langle sorthash,\pi,j\rangle \gets Sortition(user.sk,ctx.seed,\tau ,role,ctx.weight[user.pk],ctx.W)$
    // only committee members originate a message
    \If{$j > 0$}
        \State $GOSSIP\_MSG(user.pk, Signed_{user.sk} (round,step,sorthash,\pi,H(ctx.last_{block}),value))$
    \EndIf
    \EndFunction
    \end{algorithmic}
    \caption{\underline{CommitteeVote}}
\end{algorithm}

\noindent \textbf{Arguments:}
\begin{itemize}
    \item $ctx$ = a helper structure to retrieve ledger context information (e.g. the last confirmed block)
    \item $round$ = current round number
    \item $step$ = current step number
    \item $T$ = fraction of expected committee members to get the confirmation threshold
    \item $\tau$ = expected number of committee members
    \item $\lambda$ = maximum time to keep running the vote count and awaiting for network messages
  \end{itemize}

\noindent \textbf{Description:}\\
This subroutine verifies that the caller is a member of the specified committee (for a given round and step number), 
and in that case casts a vote for the block passed as argument.\\

\noindent \textbf{Returns:}\\
Has no return value, only gossips the specified vote if the caller is a committee member


\begin{algorithm}[H]
    \begin{algorithmic}[H]
    \Function{$ComputeSeed$}{$ctx, round, B$}
        \If{$B \neq empty\_block$} 
            \State $\Return$ $VRF_{getSKu(ctx, r)}(ctx.LastBlock.seed||r$)
        \Else
            \State $\Return$ $H(ctx.LastBlock.seed||r)$
        \EndIf
    \EndFunction
    \end{algorithmic}
    \caption{\underline{ComputeSeed}}
\end{algorithm}


\noindent \textbf{Arguments:}
\begin{itemize}
    \item $ctx$ = a helper structure to retrieve ledger context information (e.g. the last confirmed block)
    \item $round$ = current round number
    \item $B$ = the block whose seed is being computed (that will be added as metadata)
  \end{itemize}


\noindent \textbf{Description:}\\
This subroutine computes the required sortition seed for the given round number, which goes in the proposed block's metadata.
If the block is empty, the seed is a hash of the previous block's seed.
The $get_{SKu}(ctx, round)$ helper function gets the relevant user's secret key (according to the signing scheme described in specs).
That is, the secret key from a round b time before block $r-1-(r mod R)$, where $R$ is the sortition seed's renewal rate, $r$ is the current round's number,
and $b$ is the upper bound for the loss of strong synchrony (according to the weak synchrony assumption, that is, $s < b$).\\

TODO: reescribir detallando mejor el proceso de selección de la seed

\noindent \textbf{Returns:}
\begin{itemize}
    \item the computed seed for the given block, ledger context and round
  \end{itemize}

\begin{algorithm}[H]
    \begin{algorithmic}[H]
    \Function{$Sortition$}{$sk, seed, \tau, role, w, W$}
        \State $ \langle hash, \pi \rangle \gets VRF(seed||role)$
        \State $p \gets \frac{t}{W}$
        \State $j \gets 0$
        \While{$\frac{hash}{2^{hashlen}}\notin [ \sum_{k=0}^jB(k;w,p), \sum_{k=0}^{j+1}B(k;w,p))$}
            \State $j++$
        \EndWhile
        \Return $ \langle hash,\pi,j \rangle$
    \EndFunction
    \end{algorithmic}
    \caption{\underline{Sortition}}
\end{algorithm}


\noindent \textbf{Arguments:}
\begin{itemize}
    \item $sk$ = a user's secret key (an ephemeral key for the given round, according to key specs)
    \item $seed$ = the sortition seed to be used
    \item $\tau$ = the expected committee size for the given role
    \item $role$ = a flag specifying the role for the sortition to take place (e.g. block proposer)
    \item $w$ = the user's weight (aka. it's relevant stake)
    \item $W$ = the total relevant stake for the given round
\end{itemize}

\noindent \textbf{Description:}\\
The Sortition procedure is one of the most important subroutines in the main algorithm, as it's used in multiple stages and contexts.
Generally, it manages to pseudo-randomly but verifiably (through the use of a Verifiable Random Function) select a user with probability proportional
to their weight (aka. stake) by returning a j parameter, which indicates the number of times that specific user was chosen.
Algorithmically, every monetary unit the user has is considered a "sub-user", and then each one of them is selected with probability $p = \frac{\tau}{W}$,
where $\tau$ is the expected ammount of users to be selected for the given role.
The semi-open interval $[0,1)$ is then split into consecutive intervals using an accumulated binomial distribution, and wherever the fraction $\frac{hash}{2^{hashlen}}$
belongs to the interval, that's the ammount of chosen sub-users for the subroutine caller.\\

\noindent \textbf{Returns:}
\begin{itemize}
    \item an integer $j$ that will be positive (larger than 0) if the user has been selected, and it's size corresponds to the ammount
    of sub-users for a given committee member
  \end{itemize}

\begin{algorithm}[H]
    \begin{algorithmic}[H]
    \Function{$VerifySortition$}{$pk, seed, \tau, role, w, W$}
        \IfThen{$\neg VerifyVRF_{pk}(hash, \pi, seed||role)$}{$\Return 0$}
        \State $p \gets \frac{t}{W}$
        \State $j \gets 0$
        \While{$\frac{hash}{2^{hashlen}} \notin [\sum_{k=0}^jB(k;w,p), \sum_{k=0}^{j+1}B(k;w,p))$}
            \State $j++$
        \EndWhile
        \Return $j$
    \EndFunction
    \end{algorithmic}
    \caption{\underline{VerifySortition}}
\end{algorithm}

\noindent \textbf{Arguments:}
\begin{itemize}
    \item $pk$ = a user's public key (their address)
    \item $seed$ = the sortition seed to be used
    \item $\tau$ = the expected committee size for the given role
    \item $role$ = a flag specifying the role for the sortition to take place (e.g. block proposer)
    \item $w$ = the user's weight (aka. it's relevant stake)
    \item $W$ = the total relevant stake for the given round
  \end{itemize}

\noindent \textbf{Description:}\\
The sortition verification procedure takes Sortition's output and utilizes VRF properties to verify the validity of said output.
Once the check is passed, it repeats Sortition's sub-user selection procedure, and outputs the ammount of times the user was chosen
according to their respective observed stake.\\

\noindent \textbf{Returns:}
\begin{itemize}
    \item an integer $j$ that will be positive (larger than 0) if the user has been selected, and it's size corresponds to the ammount
    of sub-users for a given committee member
  \end{itemize}


\begin{algorithm}[H]
    \begin{algorithmic}[H]
    \Function{$BLOCK\_STEP$}{$hblock, blockHash, step$}
        \State $bConfirmed \gets FALSE$
        \State $r \gets hblock$

        \State $CommitteeVote(ctx, round, step, \tau_{step}, r)$
        \State $r \gets CountVotes(ctx,round,step,T_{step},\tau_{step},\lambda_{step})$
        \If{$r = TIMEOUT$}
            \State $r \gets blockHash$
        \ElsIf{$r \neq emptyHash$}
            \For{$step < s^\prime \leq step + 3$}
                \State $CommitteeVote(ctx, round, s^\prime, \tau_{step}, r)$
            \EndFor
            \If {$step = 1$}
                \State $CommitteeVote(ctx, round, FINAL, \tau_{final}, r)$
            \EndIf
            \State $bConfirmed \gets TRUE$
        \EndIf
        $\Return$ $ \langle r, bConfirmed \rangle$
    \EndFunction
    \end{algorithmic}
    \caption{\underline{BLOCK\_STEP}}
\end{algorithm}

\noindent \textbf{Arguments:}
\begin{itemize}
    \item $hblock$ = a block hash value to be voted on
    \item $blockHash$ = the block hash value locally observed by the node to be the winning choice
    \item $step$ = currently executing step
  \end{itemize}

\noindent \textbf{Description:}\\
The BLOCK\_STEP subroutine handles the first part of the certifyVote's main loop.
It first casts a vote on the observed hblock value (possibly coming off of a coin toss vote -see commonCoinFlipVote-).
It then attempts to count incoming votes. In case of a timeout (aka. no block passed the threshold), it returns the block hash.
Otherwise, and assuming the highest voted value is not an empty block hash, it casts votes for the next three steps for the block seen as selected.
Then, in the special scenario where we are in step 1, we cast our vote as FINAL, suggesting that this block is a candidate for a final consensus (if enough committee members observe this fact).
Finally, the procedure returns the selected block amd a flag to either continue or return from the main procedure with a certified vote.

\noindent \textbf{Returns:}
\begin{itemize}
    \item a tuple $\langle r, bConfirmed \rangle$, comprised of a block hash value and a boolean flag to assert whether the given value was
    observed to be confirmed in any way or if further steps are needed
  \end{itemize}

\begin{algorithm}[H]
    \begin{algorithmic}[H]
    \Function{$EMPTY\_STEP$}{$hblock, step$}
        \State $bConfirmed \gets FALSE$
        \State $r \gets hblock$

    \State $CommitteeVote(ctx, round, step, \tau_{step}, r)$
    \State $r \gets CountVotes(ctx,round,step,T_{step},\tau_{step},\lambda_{step})$
    \If{$r = TIMEOUT$}
        \State $r \gets emptyHash$
    \ElsIf{$r = emptyHash$}
        \For{$step < s^\prime \leq step+3$}
            \State $CommitteeVote(ctx, round, s^\prime, \tau_{step}, r)$
        \EndFor
        \State $bConfirmed \gets TRUE$
    \EndIf
    $\Return$ $\langle r, bConfirmed \rangle$
    \EndFunction
    \end{algorithmic}
    \caption{\underline{EMPTY\_STEP}}
\end{algorithm}

\noindent \textbf{Arguments:}
\begin{itemize}
    \item $hblock$ = a block hash value to be voted on
    \item $step$ = currently executing step
  \end{itemize}

\noindent \textbf{Description:}\\
The EMPTY\_STEP procedure works in a very similar fashion to BLOCK\_STEP, with two main differences: 
the block to attempt to confirm is the empty block, and there is no final consensus achievable in this scenario.

\noindent \textbf{Returns:}
\begin{itemize}
    \item a tuple $\langle r, bConfirmed \rangle$, comprised of a block hash value and a boolean flag to assert whether the given value was
    observed to be confirmed in any way or if further steps are needed
  \end{itemize}

\begin{algorithm}[H]
    \begin{algorithmic}[H]
    \Function{$CommonCoinFlipVote$}{$hblock, blockHash, step$}
        \State $r \gets hblock$
    
        \State $CommitteeVote(ctx, round, step, \tau_{step}, r)$
        \State $r \gets CountVotes(ctx,round,step,T_{step},\tau_{step},\lambda_{step})$
        \If{$r = TIMEOUT$}
            \If{$CommonCoin(ctx,round,step,T_{step},\tau_{step},\lambda_{step}) = 0$}
                \State $r \gets blockHash$
            \Else
                \State $r \gets emptyHash$
            \EndIf
        \EndIf
    \EndFunction
    \end{algorithmic}
    \caption{\underline{CommonCoinFlipVote}}
\end{algorithm}

\noindent \textbf{Arguments:}
\begin{itemize}
    \item $hblock$ = a block hash value to be voted on
    \item $blockHash$ = the block hash value locally observed by the node to be the winning choice
    \item $step$ = currently executing step
  \end{itemize}

\noindent \textbf{Description:}\\
This procedure casts a vote for the previous step's selected block, then does a vote count,
and finally flips a coin (last bit of lowest sortition hashed user, see CommonCoin) that's random,
but consensuated between a majority of users. This guarantees that an attacker could not guess what the
next vote will be for a given user, and introduces a tool to facilitate reaching a tentative consensus in the next stages.

\noindent \textbf{Returns:}
\begin{itemize}
    \item a block hash value, decided randomly in between the locally chosen block hash or an empty hash, to be voted on
    in the immediately following step
  \end{itemize}


\begin{algorithm}[H]
    \begin{algorithmic}[H]
    \Function{$CommonCoin$}{$ctx, round, step, \tau$}

    \State $minhash \gets 2^{hashlen}$
    \For{$m \in incomingMsgs[round, step]$}
        \State $\langle votes,value,sorthash\rangle \gets ProcessMsg(ctx,\tau,m)$
        \For{$1 \leq j < votes$}
                \State $h \gets H(sorthash||j)$
                \IfThen{$h < minhash$}{$minhash \gets h$}
        \EndFor
    \EndFor
    $\Return$ $minhash$ $mod$ $2$
    \EndFunction
    \end{algorithmic}
    \caption{\underline{CommonCoin}}
\end{algorithm}


\noindent \textbf{Arguments:}
\begin{itemize}
    \item $ctx$ = a helper structure to retrieve ledger context information (e.g. the last confirmed block)
    \item $round$ = current round number
    \item $step$ = current step number
    \item $\tau$ = the expected committee size for the given role
  \end{itemize}

\noindent \textbf{Description:}\\\\
The CommonCoin procedure takes advantage of the randomness of sortition hashes, and attempts to
get a consensus random bit (a coin toss) getting the least significant bit of the lowest hashed
sortition hash concatenated with sub-user index, for all committee voters in the given round and step.
Since sortition hashes are random, even if an attacker happened to be a committee member with the lowest observable hash,
the coin value's randomness would still be preserved, and in successive steps the probability of them being chosen again and
able to manipulate this stage would severely diminish.\\

\noindent \textbf{Returns:}
\begin{itemize}
    \item a random bit (either 0 or 1), observed to be the least significant bit of the hashed sortition hash of a committee member for the given step,
    that should be observed by a majority of users to be the same (conceptually, a consensus coin toss)
  \end{itemize}

\end{section}
\end{document}