\documentclass[10pt,a4paper]{article}
\usepackage[utf8]{inputenc} % para poder usar tildes en archivos UTF-8
\usepackage[spanish]{babel} % para que comandos como \today den el resultado en castellano
\usepackage{a4wide} % márgenes un poco más anchos que lo usual
\usepackage{caratula}
% \usepackage[left=3cm,right=3cm,bottom=3cm,top=3cm]{geometry}

% Comandos para simbolos matematicos.
\usepackage{amsmath, amssymb, tabularx}

% Comandos para referencias
\usepackage{natbib}

% Comandos para Figuras, Graficos, Tikz etc.
\usepackage{tikz}
\usepackage{epsfig}
\usepackage{pgfplots}
\usepackage{graphicx}
\usepackage{epsfig}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{svg}
\setsvg{inkscape=inkscape -z -D}

% Comandos para teoremas etc.
\usepackage{amsthm}
\newtheorem{theorem}{Teorema}
\newtheorem{lemma}[theorem]{Lema}
\newtheorem{proposition}[theorem]{Proposición}
\newtheorem{remark}{Observación}
\newtheorem{corollary}{Corolario}
% \newproof{proof}{Demostración}

% Comandos para algoritmos.
\usepackage[noend]{algpseudocode}
\usepackage{algorithm}
\algnewcommand{\IfThenElse}[3]{% \IfThenElse{<if>}{<then>}{<else>}
    \State \algorithmicif\ #1\ 
    \algorithmicthen\ #2\ 
    \algorithmicelse\ #3}
\algnewcommand{\IfThen}[2]{% \IfThenElse{<if>}{<then>}
    \State \algorithmicif\ #1\ \algorithmicthen\ #2}
\pgfplotsset{compat=1.16}





\begin{document}

\section{Introduction}

In the following document we present a detailed pseudocode interpretation of the program run by an Algorand node with at least one online (aka. participating)
account. We attempt to explain the 5 main stages of the code supporting the protocol in a clear and concise way.
This work aims to provide a basis for an Algorand blockchain simulator currently in development.

\section{Main algorithm}


\begin{algorithm}
    \begin{algorithmic}[1]
    \Function{$BlockCreation()$}{}
    
    \State $Pick$ $transactions$ $from$ $transactionPool$
    
    \EndFunction
    \end{algorithmic}
    \caption{\underline{Block creation}}
    \label{alg:fuerza_bruta}
\end{algorithm}

The algorand protocol specs don't ensure a specific way or internal order in which transactions are added to the block.
In fact, they don't force transactions to be added at all, being entirely possible for a node to propose an empty block.
More research is needed on how block data is put together.
Block metadata is well documented, but is added into it later in the block proposal stage.

\begin{algorithm}
    \begin{algorithmic}[H]
    \Function{$BlockProposal$}{$Block$ $B$, $Accounts$ $A$}
        \State $ProposalMsgsSent = \{\}$ //Set of proposal messages sent by this node

        \For{$a \in A$}
            \State $<sorthash, \pi, j>\gets Sortition(a.sk, getSortitionSeed(round), t, role, $ \newline
            $sortition_w(a, round), sortitionW(round))$
            \If{$j > 0$}
                \State $priority \gets Min_{n \in [1,j]}{Hash(sorthash || n)}$
                \State $UserPriorityHashTable[a] = priority$

                \State $msg \gets MSG(a.pk, Signed{a.sk}(priority, <sorthash, \pi>))$
                \State $ProposalMsgsSent \cup= msg$
                \State $GOSSIP\_MSG(a.pk, Signed{a.sk}(priority, <sorthash, \pi>))$
            \EndIf
        \EndFor\


        \While{$elapsed$ $time$ $< proposal$ $time$}
            \State $incomingMsgs.push(listen())$
        \EndWhile\

        \State $msgs \gets incomingMsgs[round, step=0]$


        \State $lowestHashMsg \gets m\ |\ m.priority = Min_{m.priority\ \in\ incomingMsgs}$ \newline
        ${\{verifySortition(m.sorthash, m.pi, m.pk)\ \& ValidateMsg(m)\}}$

        \State $FullBlockToPropose \gets empty\_block(round)$

        \If{$lowestHashMsg \in msgsSent$}
            \State $FullBlockToPropose \gets B$
            \State $FullBlockToPropose.seed \gets ComputeSeed(ctx, r, B)$
            \State $GOSSIP\_MSG(a.pk, Signed{a.sk}(B, <sorthash, \pi>))$
        \Else
        {
            \While{$elapsed$ $time < fullblock$ $time$}
                \State $incomingMsgs.push(listen())$
                \State $m \gets incomingMsgs.back()$
                \If{$ValidateMsg(m)$ \& $lowestHashMsg.blockHash$ $=$ $H(m.FullBlock)$}
                    \State $FullBlockToPropose \gets m.FullBlock$
                \EndIf
            \EndWhile
        }
        \EndIf

        \Return $H(FullBlockToPropose)$

    \EndFunction
    \end{algorithmic}
    \caption{\underline{Block proposal}}
\end{algorithm}

The block proposal stage (step 0 on specs) is the first stage of the consensus algorithm per se. Nodes loop through all their online accounts, running sortition to determine which accounts will be proposing the assembled block (if any).
It then proceeds to gossip the priority, sortition hash and proof of the designated accounts (signed with their leaf ephemeral keys according to the signature scheme described on specs).
Afterwards, it waits for a designated time to receive other block proposals, validates them and keeps the one with the lowest observed hash (maximum priority).
Once the time is reached, if the selected proposal came from this node, the seed is computed and added into the finished block's metadata. Then, the complete block is gossipped to the network.
In the most common case where the proposal is not the one selected locally by the node, it waits for another pre-designated time to receive the full block from the network.
In case of timeout in this last stage, it falls back to the empty block.

\begin{algorithm}
    \begin{algorithmic}[H]
    \Function{$SoftVote$}{BlockHash}
    
    %\State $CommitteeVote(ctx, round, REDUCTION\_ONE, tstep, hblock)$
    \State $hblock \gets CountVotes(ctx, round, REDUCTION\_ONE, Tstep, tstep, lblock+lstep)$

    \State $empty\_hash \gets H(Empty(round, H(ctx.last\_block)))$ 
    \If{$hblock = TIMEOUT$}
        \State $CommitteeVote(ctx, round, REDUCTION\_TWO, tstep, empty\_hash)$
    \Else
        {\State $CommitteeVote(ctx, round, REDUCTION\_TWO, tstep, hblock)$}
    \EndIf\

    \State $hblock \gets CountVotes(ctx, round, REDUCTION\_TWO, Tstep, tstep, lblock+lstep)$ 

    \IfThenElse{$hblock = TIMEOUT$}{$\Return$ $empty\_hash$}{$\Return$ $hblock$}

    \EndFunction
    \end{algorithmic}
    \caption{\underline{Soft Vote}}
\end{algorithm}

The soft vote stage (step 1, or labeled as reduction in the ASBAC paper) aims to reduce any ammount of potentially conflicting proposed blocks in the stage prior into a binary choice, either a block proposed by a user or an empty one.
In the first sub-step, each commitee member gossips the proposed block, and then does a preliminary vote count while it waits for other nodes to catch up.
In the second sub-step, committee members vote for the hash that received at least the ammount of votes set by the threshold for this step, or the hash of the default empty block if no hash was observed to receive enough votes.
It relies heavily on the assumption that, if the block proposer was honest, most users will get to the soft vote stage with the same hblock parameter.
However if the proposer was dishonest, then no single hblock may be popular enough to cross the threshold (and therefore this stage will return an empty\_hash).
Therefore, there will at most be one non-empty block that can be returned by soft vote for all honest users.


\begin{algorithm}
    \begin{algorithmic}[H]
    \Function{$CertifyVote$}{$hblock$}
    \State $blockHash \gets hblock$

    \State $step \gets 2$
    \While{$step < 256$}
        \\
        \State $<hblock, bConfirmed> \gets BLOCK\_STEP(hblock, blockHash, step)$
        \If{$bConfirmed$}{ $\Return$ $hblock$}
        \EndIf
        \State $step++$\\
   
        \State $<hblock, bConfirmed> \gets EMPTY\_STEP(hblock,step)$
        \If{$bConfirmed$}{ $\Return$ $hblock$}
        \EndIf
        \State $step++$\\

        \State $CommonCoinFlipVote(hblock, step)$
        \State $step++$
    \EndWhile

\State $HangForever()$
    
    \EndFunction
    \end{algorithmic}
    \caption{\underline{CertifyVote}}
\end{algorithm}

The certify vote stage (which potentially encompasses steps 2 through 255) is the core of the BA* algorithm.
The main loop executes a maximum of 254 times (from step 2 to step 255, labeled \"cert\" and \"down\" respectively on the specs).
This is to avoid an attacker indefinitely postponing consensus in a compromised network, giving them a small chance to force consensus on their desired block with each iteration.
The main algorithm is comprised of three important procedures: the block step, where, if selected as a committee member, votes for the block selected in the soft voting stage and then attempts to confirm it by listening to other cast votes until a threshold is met.
If this step times out and no consensus is reached, it moves on to the empty step. Very similar in nature to the previous one, in this procedure a vote is cast for the value in hblock and then it attempts to confirm an empty block.
Finally, if no consensus is reached on the empty block, it arrives to the common coin procedure, where it attempts another vote and vote count for the empty block. If here, no consensus is reached, it uses the pseudo-randomness of the VRF hash output to "flip a coin" by looking at the last bit of the lowest sortition hash owned by observed committee members.
This makes it so even tho the coin flip is random, most users will observe the same outcome and will in turn set their hblock values according to the observed bit. In turn, this prevents an adversary from being able to easily predict beforehand what the next vote of a user would be if they were a committee user, and therefore the attacker can't force consensus 
sending their vote messages to targeted users in a scenario where the voting is split pretty evenly but no block has quite enough votes to push the threshold.\\
\\
\\

\begin{algorithm}
    \begin{algorithmic}[H]
    \Function{$BlockConfirmation$}{$hblock$}

    \State $r \gets CountVotes(ctx, round, FINAL, Tfinal, tfinal, lstep)$
    \If{$r = hblock$}
        \State \Return $<FINAL, BlockOfHash(hblock)>$ 
    \Else
    {
        \State \Return $<TENTATIVE, BlockOfHash(hblock)>$
    }
    \EndIf
        
    \EndFunction
    \end{algorithmic}
    \caption{\underline{BlockConfirmation}}
\end{algorithm}



Finally, the proposed block (be it an empty block or a specific one proposed by a designated user) is confirmed and added to the ledger.
We introduce the notions of FINAL and TENTATIVE consensus.
Specifically, if a block is confirmed in the very first step of the certify vote stage, its vote is cast as FINAL.
If enough users reproduce this behavior, the vote count on line 2 for votes cast in this fashion is over the required threshold, and the consensus is labeled as FINAL.
This means that the block is simultaneously added to the ledger and confirmed, as well as immediately confirming any prior blocks that could have been labeled TENTATIVE.
If this node is not able to ensure that enough users considered the block represented by hblock as FINAL, the consensus is labeled as TENTATIVE, and it may be confirmed by a later FINAL block.
The BlockOfHash() function outputs the full block for the provided hash, either by returning a locally available copy or by requesting it from other users.\



\section{Subroutines}


\begin{algorithm}
    \begin{algorithmic}[H]
    \Function{$CountVotes$}{$ctx, round, FINAL, Tfinal, tfinal, lstep$}

    \State $counts \gets \{\}$ // hash table, new keys mapped to 0
    \State $voters \gets \{\}$
    \State $msgs \gets incomingMsgs[round,step]$

    \While{$TRUE$}
        \State $m \gets msgs.next()$
        \If{$m = \bot$}
            \If{$ElapsedTime > startTime + lambda$}
                \State $\Return$ $TIMEOUT$
            \EndIf
        \Else
        {
            \State $<votes, value, sorthash> \gets ProcessMsg(ctx, t, m)$
            \IfThen{$m.pk \in voters \lor votes = 0$}{$continue$}
            \State $voters$ $\cup=$ ${m.pk}$
            \State $counts[value] += votes$
            \IfThen {$counts[value] \geq T * \tau$}{$\Return$ $value$}
        }
        \EndIf

    \EndWhile

    \end{algorithmic}
    \caption{\underline{CountVotes}}
\end{algorithm}

This subroutine counts the votes for any observed block hash value, for a given round and step numbers.
It returns as soon as it finds a value exceeding the specified threshold (which will also vary according to round and step).
If no value is observed to have the required ammount of votes in the predetermined temporal window, it finishes with a TIMEOUT.
It's important to notice that every committee user's vote is processed at most once for the given context.

\begin{algorithm}
    \begin{algorithmic}[H]
    \Function{$CommitteeVote$}{$ctx, round, FINAL, Tfinal, tfinal, lstep$}
    
    
    \State $role \gets ⟨“committee”,round,step⟩$
    \State $⟨sorthash,π,j⟩ \gets Sortition(user.sk,ctx.seed,τ ,role,ctx.weight[user.pk],ctx.W)$
    // only committee members originate a message
    \If{$j > 0$}
        \State $GOSSIP\_MSG(user.pk, Signed_{user.sk} (round,step,sorthash,\pi,H(ctx.last_block),value))$
    \EndIf
    
    \end{algorithmic}
    \caption{\underline{CommitteeVote}}
\end{algorithm}

This subroutine verifies that the caller is a member of the specified committee (for a given round and step number), 
and in that case casts a vote for the block passed as argument.

\begin{algorithm}
    \begin{algorithmic}[H]
    \Function{$ComputeSeed$}{$ctx, round, B$}
        \If{$B \neq empty\_block$} 
            \State $\Return$ $VRF_{getSKu(ctx, r)}(ctx.LastBlock.seed||r$)
        \Else
            \State $\Return$ $H(ctx.LastBlock.seed||r)$
        \EndIf
    \end{algorithmic}
    \caption{\underline{ComputeSeed}}
\end{algorithm}

This subroutine computes the required sortition seed for the given round number, which goes in the proposed block's metadata.
If the block is empty, the seed is a hash of the previous block's seed.
The $get_{SKu}(ctx, round)$ helper function gets the relevant user's secret key (according to the signing scheme described in specs).
That is, the secret key from a round b time before block $r-1-(r mod R)$, where $R$ is the sortition seed's renewal rate, $r$ is the current round's number,
and $b$ is the upper bound for the loss of strong synchrony (according to the weak synchrony assumption, that is, $s < b$).


\begin{algorithm}
    \begin{algorithmic}[H]
    \Function{$Sortition$}{$sk, seed, \tau, role, w, W$}
        \State $<hash, \pi> \gets VRF(seed||role)$
        \State $p \gets \frac{t}{W}$
        \State $j \gets 0$
        \While{$\frac{hash}{2^{hashlen}}$ \notin $[ \sum{}_{k=0}^{j}B(k;w,p), \sum{}_{k=0}^{j+1}B(k;w,p))$}
            \State $j++$
        \EndWhile
        \Return $<hash,\pi,j>$

    \end{algorithmic}
    \caption{\underline{Sortition}}
\end{algorithm}


The Sortition procedure is one of the most important subroutines in the main algorithm, as it's used in multiple stages and contexts.
Generally, it manages to pseudo-randomly but verifiably (through the use of a Verifiable Random Function) select a user with probability proportional
to their weight (aka. stake) by returning a j parameter, which indicates the number of times that specific user was chosen.
Algorithmically, every monetary unit the user has is considered a "sub-user", and then each one of them is selected with probability $p = \frac{\tau}{W}$,
where $\tau$ is the expected ammount of users to be selected for the given role.
The semi-open interval $[0,1)$ is then split into consecutive intervals using an accumulated binomial distribution, and wherever the fraction $\frac{hash}{2^{hashlen}}$
belongs to the interval, that's the ammount of chosen sub-users for the subroutine caller.


\begin{algorithm}
    \begin{algorithmic}[H]
    \Function{$VerifySortition$}{$pk, seed, \tau, role, w, W$}
        \IfThen{$\neg VerifyVRF_{pk}(hash, \pi, seed||role)$}{$\Return 0$}
        \State $p \gets \frac{t}{W}$
        \State $j \gets 0$
        \While{$\frac{hash}{2^{hashlen}}$ \notin $[ \sum{}_{k=0}^{j}B(k;w,p), \sum{}_{k=0}^{j+1}B(k;w,p))$}
            \State $j++$
        \EndWhile
        \Return $j$
    \end{algorithmic}
    \caption{\underline{VerifySortition}}
\end{algorithm}

The sortition verification procedure takes Sortition's output and utilizes VRF properties to verify the validity of said output.
Once the check is passed, it repeats Sortition's sub-user selection procedure, and outputs the ammount of times the user was chosen
according to their respective observed stake.


\begin{algorithm}
    \begin{algorithmic}[H]
    \Function{$BLOCK\_STEP$}{$hblock, step, blockHash$}
        \State $bConfirmed \gets FALSE$
        \State $r \gets hblock$

        \State $CommitteeVote(ctx, round, step, \tau_{step}, r)$
        \State $r \gets CountVotes(ctx,round,step,Tstep,τstep,λstep)$
        \If{$r = TIMEOUT$}
            \State $r \gets blockHash$
        \ElsIf{$r \neq emptyHash$}
            \For{$step < s^{\′} \leq step+3$}
                \State $CommitteeVote(ctx, round, s^{\′}, τstep, r)$
            \EndFor
            \If {$step = 1$}
                \State $CommitteeVote(ctx, round, FINAL, \tau_{final}, r)$
            \EndIf
            \State $bConfirmed \gets TRUE$
        \EndIf
        $\Return$ $<r, bConfirmed>$
    \end{algorithmic}
    \caption{\underline{BLOCK\_STEP}}
\end{algorithm}

The BLOCK\_STEP subroutine handles the first part of the certifyVote's main loop.
It first casts a vote on the observed hblock value (possibly coming off of a coin toss vote -see commonCoinFlipVote-).
It then attempts to count incoming votes. In case of a timeout (aka. no block passed the threshold), it returns the block hash.
Otherwise, and assuming the highest voted value is not an empty block hash, it casts votes for the next three steps for the block seen as selected.
Then, in the special scenario where we are in step 1, we cast our vote as FINAL, suggesting that this block is a candidate for a final consensus (if enough committee members observe this fact).
Finally, the procedure returns the selected block amd a flag to either continue or return from the main procedure with a certified vote.


\begin{algorithm}
    \begin{algorithmic}[H]
    \Function{$EMPTY\_STEP$}{$hblock, step$}
        \State $bConfirmed \gets FALSE$
        \State $r \gets hblock$

    \State $CommitteeVote(ctx, round, step, \tau_{step}, r)$
    \State $r \gets CountVotes(ctx,round,step,Tstep,τstep,λstep)$
    \If{$r = TIMEOUT$}
        \State $r \gets emptyHash$
    \ElsIf{$r = emptyHash$}
        \For{$step < s^{\′} \leq step+3$}
            \State $CommitteeVote(ctx, round, s^{\′}, τstep, r)$
        \EndFor
        \State $bConfirmed \gets TRUE$
    \EndIf
    $\Return$ $<r, bConfirmed>$
    \end{algorithmic}
    \caption{\underline{EMPTY\_STEP}}
\end{algorithm}

The EMPTY\_STEP procedure works in a very similar fashion to BLOCK\_STEP, with two main differences: 
the block to attempt to confirm is the empty block, and there is no final consensus achievable in this scenario.


\begin{algorithm}
    \begin{algorithmic}[H]
    \Function{$CommonCoinFlipVote$}{$hblock, step, blockHash$}
        \State $r \gets hblock$
    
        \State $CommitteeVote(ctx, round, step, \tau_{step}, r)$
        \State $r \gets CountVotes(ctx,round,step,Tstep,τstep,λstep)$
        \If{$r = TIMEOUT$}
            \If{$CommonCoin(ctx,round,step,Tstep,\tau_{step},lambdaStep) = 0$}
                \State $r \gets blockHash$
            \Else
                \State $r \gets emptyHash$
            \EndIf
        \EndIf

    \end{algorithmic}
    \caption{\underline{CommonCoinFlipVote}}
\end{algorithm}

This procedure casts a vote for the previous step's selected block, then does a vote count,
and finally flips a coin (last bit of lowest sortition hashed user, see CommonCoin) that's random,
but consensuated between a majority of users. This guarantees that an attacker could not guess what the
next vote will be for a given user, and introduces a tool to facilitate reaching a tentative consensus in the next stages.

\begin{algorithm}
    \begin{algorithmic}[H]
    \Function{$CommonCoin$}{$ctx, round, step, \tau$}

    \State $minhash \gets 2^{hashlen}$
    \For{$m \in incomingMsgs[round, step]$}
        \State $⟨votes,value,sorthash⟩ \gets ProcessMsg(ctx,\tau,m)$
        \For{$1 \leq j < votes$}
                \State $h \gets H(sorthash||j)$
                \IfThen{$h < minhash$}{$minhash \gets h$}
        \EndFor
    \EndFor
    $\Return$ $minhash$ $mod$ $2$

    \end{algorithmic}
    \caption{\underline{CommonCoin}}
\end{algorithm}

The CommonCoin procedure takes advantage of the randomness of sortition hashes, and attempts to
get a consensus random bit (a "coin toss") getting the least significant bit of the lowest hashed
sortition hash concatenated with sub-user index, for all committee voters in the given round and step.
Since sortition hashes are random, even if an attacker happened to be a committee member with the lowest observable hash,
the coin value's randomness would still be preserved, and in successive steps the probability of them being chosen again and
able to manipulate this stage would severely diminish.
\end{document}