\documentclass[10pt,a4paper]{article}

\usepackage[utf8]{inputenc} % para poder usar tildes en archivos UTF-8
\usepackage[english]{babel}
\usepackage{a4wide} % márgenes un poco más anchos que lo usual
\usepackage{hyperref}
\usepackage{float}
% Comandos para simbolos matematicos.
\usepackage{amsmath, amssymb}%, tabularx}

% Comandos para algoritmos.
\usepackage[noend]{algpseudocode}
\usepackage{algorithm}
\algnewcommand{\IfThenElse}[3]{% \IfThenElse{<if>}{<then>}{<else>}
    \State \algorithmicif\ #1\ 
    \algorithmicthen\ #2\ 
    \algorithmicelse\ #3}
\algnewcommand{\IfThen}[2]{% \IfThenElse{<if>}{<then>}
    \State \algorithmicif\ #1\ \algorithmicthen\ #2}
%\pgfplotsset{compat=1.16}

% index of words
\usepackage{imakeidx}
\makeindex

\usepackage[fulladjust]{marginnote}
%\renewcommand{\marginpar}[1]{\marginpar{\raggedleft\small #1}}

\setlength{\parskip}{4pt}%
\setlength{\parindent}{0pt}%

% ---------------------------------------------------------------------------------------
\author{Argimiro, CoinFabrik}
\title{Algorand Protocol Description}

\begin{document}
\maketitle
\tableofcontents

% ---------------------------------------------------------------------------------------
\begin{section}{Introduction}
We aim to describe how the Algorand protocol works. 
This document is meant to reflect how the Algorand mainnet is behaving
today. 
To our knowledge, there is no accurate and up-to-date technical description 
of the protocol. 

We relied on Algorand's documents (\cite{DBLP:conf/sosp/GiladHMVZ17},
\cite{DBLP:journals/corr/Micali16} and
\href{https://github.com/algorandfoundation/specs}{Algorand's official specifications})
but mostly we consulted the code for the node (in the official repository) and probed 
the network when information was unclear or unavailable.

Algorand is a proof-of-stake blockchain cryptocurrency protocol 
using a decentralized By\-zan\-tine Agreement protocol that leverages 
pure proof of stake for consensus. 
Protocol parties are represented by accounts, which may represent users
or smart contracts. 

The Algorand blockchain is operated by nodes. Users register their accounts 
in nodes. It is the nodes which call the actions. 
When an account sends a transaction, it sends it to a node. 

The structure of a node is simple: 
it has a consensus algorithm,
a virtual machine (the Algorand Virtual Machine or AVM) and 
XXX.
Basically, the node receives transactions in its transaction pool,
validates their signature and processes them (in no protocol-imposed order)
via the AVM, probably altering the ledger and 

The node maintains a ledger, which encodes the protocol status,
that is modified via consensus.
In particular, this ledger encodes how many {\sf ALGO tokens}\index{ALGO token} 
(the native token) holds each account.

Blocks encode the status of the ledger. Starting on the genesis\index{blocks}
block (round 0) that encodes the first state of the network, 
on each round the participation nodes vote on what will the next
block be. 
Mainnet runs one blockchain that is univocally identified by the ID of
the genesis block (i.e. a hash value).

Algorand blockchain is designed so that the voting power is proportional
to the stake (in {\sf ALGO}) held by the accounts associated to the node.
In practice, not all accounts are registered live, so the voting power
is proportional to the tokens held by (the subset) of online accounts.
At the genesis of the Algorand blockchain, 10Bn {\sf ALGO} were minted. 
As of September 2022, circulating supply is approximately 6.9b {\sf ALGO}, 
distributed through different forms as ecosystem support and community
incentives.
The remaining {\sf ALGO} tokens are held by the Foundation in secure wallets 
assigned to 
Community and Governance Rewards (\%53), 
Ecosystem Support (\%36), and 
Foundation endowment (\%11).

In the following document we present a detailed pseudocode interpretation 
of the program run by an Algorand node managing at least one online (i.e., 
participating) account. We attempt to explain the different states the node x
can be in, as well as all kinds of events that cause transitions and network 
output. This work aims to provide a basis for an Algorand blockchain simulator 
currently in development. 

% ---------------------------------------------------------------------
% quizas hay que reubicar esta sect. ver luego
\begin{subsection}{Vanilla run}\label{subsect:vanilla-run}
Let as assume a genesis block was generated, the blockchain has been running and
has already generated blocks, with a set of nodes and accounts. 
We are now at round $r-1$ ($r>2$), meaning
that $r-1$ blocks have been generated and confirmed by the blockchain.
Moreover, the nodes have received transactions which have been signed 
by Algorand accounts, and has added it to its transaction pool and 
relayed them to other nodes.
For this section, we assume that all nodes behave according to protocol
and that they are in synch (e.g., the context $(r,s,p)$ for all nodes is 
the same).

The node keeps some values in memory or storage. In particular the 
timer, which we assume is now at $timer=0$,
a round number $r\in\mathbb{Z}_{\ge 0}$, 
a step $s:=0\in\mathbb{Z}_{\ge 0}$,
a period $p:=0\in\mathbb{Z}_{\ge 0}$, 
a last finished step $\bar{s}:=0\in\mathbb{Z}_{\ge 0}$, and 
a pinned vote $v:=\bot$.

We further assume that the node
has been receiving transactions which it stored in the transaction pool. 

The main algorithm for consensus is an event handler that receives two
types of input from the node. It receives messages, and it is also able
to read the timer.
% adp: La unidad de todas las constantes temporales en lo que escribí estan en segundos.
% Esta librado a la implementacion, pero los specs. asumen un clock, que es el del sistema de cada nodo.
% (Ver: https://github.com/algorand/go-algorand/blob/d82691daa34160ddc91f9b590ad16ad5f1d6d026/util/timers/interface.go#L25)
% Cabe mencionar que las specs no asumen "sincronizacion" de ningun tipo de los clocks de cada nodo, 
% y de hecho puede estar completamente desincronizado (si se asume que todos los relojes se mueven a una velocidad 
% "similar" segun los viejos papers).
% El 0 es un decir, en realidad hay un tiempo inicial. Seria mas bien time=ZeroedTime() o time=CurrentTime() si queremos ser mas rigurosos, y todo
% Son deltas respecto de este, pero me parecio razonable plantearlo asi por una cuestion de legibilidad
% En el sim esta implementado asi, como incrementos desde un tiempo inicial medido al principio de proposal
%
% DUDA:
% pero el clock del sistema va en ms! y en algun lugar me parecio ver que miraba milisegundos.
% Mi duda es que el event handler labura con = y claro, es raro que justo hagas un query al timer en el momento en 
% el que da FilterTimeout(p) o 4\lambda
%
% aw: calculo e'? BT'? L'?
% adp: En este momento BT y L son contextualmente los que hayan resultado del round anterior. Digamos que estan en un estado inicial BT_r, L_r.
% Al bloque (e) yo lo modelé como calculado al principio de la proposal, en si se calcula antes del consenso y tiene un tiempo limite
% luego del cual deja la propuesta vacia, lo que implica no poder participar de proposal ya que el output del step 0 no puede ser
% un bloque vacio.
% Estaba pensando por ahi es importante aclarar la diferencia entre un EMPTY_BLOCK, que seria el que corresponde con el EMPTY_PROPOSAL_VALUE, 
% y un bloque sin transacciones, que puede pasar si no hay txns en la txn pool, pero no seria igual a EMPTY_BLOCK +
% porque tendria todo el resto de valores calculados (semilla, hash al anterior, etc.)

% $V=\{\,\}$, P=\{\,\}, BT, L, $r_{old}$, $p_{old}$, a pinned value $\bar v:=\bot$.

% timer = 0
% event handler
As the main algorithm runs, it checks the timer and since the condition $timer=0$ holds,
then the algorithm calls the Block Proposal Algorithm (Algorithm~\ref{algo:block-proposal}).
% block assembly
The $\mathsf{BlockProposal}()$ algorithm runs, moving directly to the 
block assembly step (Algorithm \ref{algo:assemble-block}), which in short, computes a 
block $e$ associated to a proposal $proposal$ (see Section~\ref{sect:avm})\marginpar{que 
onda, aca tiene un clon del estado que presenta como candidato?}.
%adp
%Bueno esto es interesante. El bloque define todo lo necesario para un cambio de estado.
%En realidad por specs. los cambios de estado de Ledger y BT (o sea, de las cosas que no
%son de funcionamiento del consenso en si -p,s,V,P,etc.-) se aplican sobre el nodo al confirmar un bloque.
%El nodo puede cachear algunos de estos valores por performance (ej, tener un cache de los cambios de balance
%ya que ya los calculo) pero no esta enforceado. 
%Un caso especial es la avm. Esta ejecuta codigo en dos momentos distintos potencialmente: 
%cuando recibe una txn o cuando recibe un bloque, como parte de la validacion de ambos respectivamente.
%
%En recepcion de txn:
%Cuando recibe una txn, si es una logicsig, ejecuta ese codigo (como parte de la verif. de la firma) y como
%las logicsig son stateless, ese nodo ya no va a ejecutar ese codigo mas, la encola en la txn pool y ya esta.
%Cabe aclarar aca que toda txn pusheada en la txnPool esta YA validada individualmente (aplica para grupos tambien).
%Si la transaccion era una appcall, corre el codigo. Si falla obviamente se descarta, pero si aprueba la txn
%esta validada INDIVIDUALMENTE nada mas, pero como depende del contexto, si la txn no entra al proximo bloque
%el codigo se tiene que correr de nuevo en el proximo round.
%
%En recepcion/armado de bloque:
%cuando recibe un bloque, valida individualmente todas las txns que no figuren en la txn pool en orden.
%Miro el txnPool. Si ya la tengo me ahorro todo chequeo de validacion que no sea contexto-dependiente (verif. de firmas
%es uno en particular importante porque es caro). Esto implica que si tiene una logicsig, no la ejecuto.
%Ahora si es una appCall, no importa, la tengo que volver a correr, ya que la appCall es dependiente del ctx. y
%aca parte de la validacion es que el orden sea coherente. Aplica tambien para los pays, los transfers, en fin,
%cualquier cosa contextual.
%(Ver: https://forum.algorand.org/t/which-protocol-steps-have-teal-execution/8860/2)
%
% aw:
% no me queda claro si ademas de ejecutar las tranasacciones stateful, tambien aplica cambios. como quien cuando?
%
% sortition
It next loops over all the accounts that are registered to the node. 
For each account $a$, the node runs $\mathsf{Sortition}(a, proposal)$ (Algo.~\ref{algo:sortition}) 
which basically runs a Verifiable Random Function in order to decide whether this account 
can vote (by picking a random value) and provide a proof that the random value was generated according
to protocol.
% j>0
If sortition for a particular account returns the zero value, this means the account has
not been selected for block proposal. %block creation or voting,
If after running sortition for every online account managed by the node, no positive integer value is returned,
the algorithm exits and the node will no longer be a proposer in the proposal step.
%adp: el nodo sigue participando del round, solo que no propone
%aw: pero como? Si no propone ni vota! Qué mas hay para hacer?
%adp: en realidad se me habia pasado que decía block creation _or voting_, 
    %aca estamos corriendo sortition solo para block proposal (el step que estoy corriendo, s=0). 
    %Sortition es dependiente del contexto r,p,s en el que corremos (eso garantiza 
    %que no haya previsibilidad, ej. soy un atacante y veo que salieron las cuentas 
    %A_0...A_t como committee members en el soft vote para el primer periodo. 
    %Logro forzar un segundo periodo -o espero a que se de "naturalmente"- y despues solo 
    %necesito comprometer una cantidad muy pequeña de cuentas para controlar el softvote, y ya esta puedo colgar todo para siempre)
    %Entonces que un nodo no participe de un step no garantiza que no participe de otros steps del mismo periodo (ni de otros periodos, 
    %pero eso no importa para la vanilla run).
    %Incluso si no participa *proponiendo* un bloque, e incluso si tampoco sale nadie sorteado para votar soft o cert, 
    %va a participar en el sentido de que va a recibir proposal votes, va a hacer un filtering, va a recibir soft votes,
    %va a armar un soft bundle, va a recibir cert votes y va a armar un cert bundle. Cuando reciba la propuesta (bloque completo) ademas,
    %la va a reenviar ya que esto no depende de la pertenencia al comité.
When it is nonzero, the node participates in the proposal voting representing the account.
%En esta vanilla run, el period es siempre 0, asi que modifico la primera partecita para reflejar eso.
%If either the period is zero ($p=0$) or the node received a bundle $\mathsf{Bundle}(r,p-1,s,\bot)$
%for some number of steps $s\in\Z_{\ge 0}$, then
In a vanilla run scenario and at this point, the period is zero ($p=0$). 
The algorithm sets $v$ as the proposal value obtained from the block $e$ and does two separate 
broadcasts for $Vote(a.I, r,p, proposal, v, cred)$ and $e$.

% adp:
%Cabe aclarar aca que si tenes dos o mas cuentas seleccionadas para participar, queda a discreción de la impl.
%si jugar por las dos cuentas, o tratar de optimizar el comportamiento de la red mandando solo la de mejor prioridad
%y descartando la/s otra/s (que serian votos por la misma propuesta pero con los valores account dependientes -vrf output,
%proposer address- de las otras cuentas)
%
% aw: interesante. Yo lo omitiria en la vanilla run, y lo aclararia luego

%\bar v is the pinned value, which will be the special empty proposal value $\bot$ in a $0$th period, 
%or a value for which a soft or recovery ($\mathsf{next}_s$, $late$ or $redo$) bundle has been observed in the previous period.

% 0 < timer < FilterTimeout(p)
% main algorithm: Handle Proposal
Assume that some time has passed and now $0<timer<\mathsf{FilterTimeout}(p)$, and that 
the node received a block proposal $e^\prime$ which was broadcasted from another node. 
Then, the event handler runs $\mathsf{HandleProposal}(e^\prime)$ (Algorithm~\ref{algo:handle-proposal}).
This algorithm receives the proposal $e^\prime$ and unpacks its contents,
including the execution state $(r^\prime,p^\prime,s^\prime)$.
Per assumptions, we have that $r=r^\prime$ and $p=p^\prime=0$.
The algorithm checks if the proposal is valid, calling $\mathsf{VerifyProposal}(v^\prime)$ 
on $v^\prime=Proposal_{value}(e^\prime)$ (see Algorithm~\ref{algo:verify-proposal} for more details),
it also checks if periods differ ($p\neq p^\prime$), exiting if not. However, both checks pass per 
the vanilla run assumptions.
%Next it returns if any of the following conditions hold:
%a) $v^\prime$ was observed in a soft bundle for the current context $(r,p)$ (EXPLICAR MEJOR),
%b) if it agrees with the pinned value proposal, or
%c) if the hash underlying proposal $e^prime$ agrees with the lowest hash seen for this
%context. (EXPLICAR MEJOR)
%Assume that this is the first block received, and hence none of the above conditions are
%attained.
Next, if $e^\prime\in P$, it returns; else $\mathsf{HandleProposal}$ re-broadcasts $e^\prime$, 
adds $e^\prime$ to a set $P$ of stored proposals, and exits.

% revisar: porque broadcastea e y recibe vt?

% 0 < timer < FilterTimeout(p)
% main algorithm: Handle Vote
Let us say that the node received a broadcasted vote $vt$ (e.g., as those sent by the $\mathsf{HandleProposal}$ 
algorithm) and assume that $0<timer<\mathsf{FilterTimeout}(p)$ still holds.
The event handler for the main algorithm thus calls $\mathsf{HandleVote}(vt)$ (Algorithm~\ref{algo:handle-vote}).
The algorithm exits on checks --which are passed with the vanilla run assumptions.
It also exits if the vote received has already been recorded in the votes set $V$.
If it is new, the node adds the vote to the votes set $V$ and broadcasts the vote 
to other nodes.
Since nodes are synchronized, it holds that $vt.s=0=proposal$, the algorithm checks if 
$Proposal(vt.v)\in P$ and broadcasts this proposal if it is, ignoring if it is not.
%aw: a ver, entendamos que pasa aca: si estamos en el ppio, solo deberia agregar el voto a V y broadcastear. No?
%adp: claro, si estamos en un vanilla run y estamos llamando al vote handler con un proposal vote (s=0), 
    % solo observa (aka agrega el voto a V) y broadcastea ese voto.
    %Condicionalmente broadcastea la propuesta completa (el bloque que corresponde al vt.v), si la tiene.
    %
    %Aca voy a estar potencialmente recibiendo un monton de propuestas y sus respectivos votos, 
    %no puedo garantizar el orden de los mensajes (incluso en una vanilla run).
    %En el handler, quizas se podrian obviar todos los chequeos en un vanilla run, porque:
        %asumimos honestidad de los nodos (todos los votos son correctos y verifican OK)
        %asumimos por lo mismo de arriba que no hay equivocations
        %el step no es mayor que 0 en esta porcion que estamos describiendo(vt.s=0),
        %asumimos que todos los nodos estan en el mismo round, luego vt.r = r
        %mismo caso que arriba
    %Hay complicaciones posibles. Podria ser que mi nodo este desactualizado y reciba votos para steps futuros, que tiene que reconsiderar mas adelante.
    %Podemos agregar el caveat de que vanilla run asume cierta sincronizacion de los clocks de todos los nodos, para que todos esten
    %mas o menos en el mismo momento.
    %TODO: implementar desync en la simulacion! Puede ser un caso interesante para simular.


%aca en el medio falta algo. Cuando el event handler recibe un voto, y time < FilterTimeout(p), el handler lo va 
%a observar y demas.
%Cuando el event handler recibe un timeout event = FilterTimeout(p), filtra (se queda con el proposal value que 
%minimice la funcion de prioridad) y emite un soft vote (o sea llama la subrutina softVote()).
%Cuando el event handler recive un voto y time > FilterTimeout(p) (o sea, ya filtro), observa el voto. 
% Aca va a estar recibiendo soft votes de otros, y step=1 (el step se cambio a 1 dentro de softVote()).
%Si ya observo un soft bundle, emite un cert vote y ahi step \gets 2 (tanto del voto como
%en el contexto de ejecucion del nodo). Entre FilterTimeout(p) y el primer timeout de next
%2*max(\lambda, \Lambda) + esa pequeña variacion de distr. uniforme, va a observar en el caso vanilla run un cert bundle,
%ahi viene eso ultimo

Until $timer\ge \mathsf{FilterTimeout}(p)$ the main algorithm will execute the above steps
whenever a vote or a proposal are received, always recording new events and this happens.

% timer = FilterTimeout(p)
% main algorithm: soft vote
Eventually, the timer is at $timer=\mathsf{FilterTimeout}(p)$ and the main algorithm calls 
$\mathsf{SoftVote()}$ (Algorithm~\ref{algo:soft-vote}).
The soft vote is about selecting a priority block and voting it in, and it proceeds as follows.
It initializes to an empty vote $v=\bot$ and with the lowest observed hash at infinity ($lowestObservedhash:=\infty$).
The node will go through all the votes $vt^\prime\in V$ in its votes set that are in the
proposal step ($vt^\prime.s=0$).
Given the credentials for the vote $vt^\prime.credential=(sh,\pi, j)$, where $sh$ is the hash,
$\pi$ is the proof and $j\in\mathbb{Z}_{ge 0}$, the algorithm computes the priority hash
$$
priorityHash:=\min\{\mathsf{Hash}(sh\| i): 0\le i<j\},
$$
and whenever this value (as an integer) is lower than the recorded 
$lowestObservedHash$ it sets 
$lowestObservedHash:=priorityHash$ and $v:=vt^\prime.v$.
Next, if there was at least one vote in $V$, for every registered account $a\in A$
it computes \marginpar{fix notation!}
$$
(sh,\pi,j):=credential^{\prime\prime}:=\mathsf{Sortition}(a,soft)=\mathsf{Sortition}(a,1)
$$
and, if $j>0$ it broadcasts $Vote(r,p,soft,v,credential^{\prime\prime})$.
Moreover, if the proposal $p:=Proposal(v)$ is in $P$, it also broadcasts $p$.

% timer > FilterTimeout(p), s=1=proposal. handle-poposal
When the main algorithm receives a message of type vote 
$Proposal(Vote(r,p,soft,v,credential))$ as above, it will
run the handle proposal algorithm as before.

% timer > FilterTimeout(p), s=1=proposal. handle-vote
When the main algorithm receives a message of type vote 
$Vote(r,p,soft,v,credential)$ as above, it relays the vote, adds it to the
votes set (if it is new) and checks whether it can form a bundle from the 
votes in V, i.e., it checks if there is a vote $v$ such that for all the votes 
$vt\in V$ with round $vt.r=r, vt.p=0, vt.s=proposal$ that have the same vote $vt.v$ 
and such that the sum of its weights is bigger than the committee 
threshold. \marginpar{improve expl.}
It will broadcast the proposal if it is not in the proposal set $P$,
and then commit $v$, calling $\mathsf{Commit}(v)$, set $r_{old}:=r$,
and calls $\mathsf{StartNewRound}(r+1)$ and $\mathsf{GarbageCollect}(r_{old},p)$
ending the round.
Calling the new round algorithm (Algo.~\ref{algo:start-new-round}) will
reset variables as: $\bar s:=s$, $\bar{v}:=\bot$, $r:=r+1$, $p:=0$ and
$s:=proposal=1$;
and calling the garbage collection algorithm (Algo.~\ref{algo:garbage-collect}) 
will compute 
$$
\begin{array}{rl}
V_{(r,p-1)} & :=\{vt\in V : vt.r < r \text{ or } (vt.r = r \text{ and } vt.p+1 < p)\}\\
P_{(r,p-1)} & :=\{pr\in PP: pr.r < r \text{ or } (pr.r = r \text{ and } pr.p + 1 < p)\}
\end{array}
$$\marginpar{esto es $pr_{p+1}$ o $pr_p+1$?}
and then remove these sets from the votes and participation sets: $V:=V\setminus V_{(r,p-1)}$,
$P = P\setminus P_{(r,p-1)}$.



% handle proposal con p++
% checks if $v^\prime$ is committable (i.e., running Algorithm~\ref{algo:is-commitable} 
% $\mathsf{IsCommittable}(v^\prime)$ returns {\tt true}), 
% and if the step is the certification or smaller (it is, because $s=0$ and $cert=2$, see table (\ref{table:s})). 
% Since both checks are true in this run, the algorithm iterates over every account $a$ registered 
% to the node, running the sortition algorithm in each case to compute 
% $cred:=\mathsf{Sortition}(a, cert)=\mathsf{Sortition}(a, 2)$\marginpar{ver HandleProposal: es cert o s?}
% %aca es cert pero porque esta linea se ejecutaria recien en el hipotetico caso de que estes parado con un 
% %cert bundle esperando que te llegue la propuesta completa correspondiente para commitear el bloque, cosa que
% %podriamos asumir no deberia pasar en el vanilla run (esta linea se ejecuta solo si IsCommitable(...))
% %Para la vanilla run, lo unico que va a hacer este handler es observar (agregar a P) la proposal recibida,
% %y enviarla a los peers (excluyendo al que la propuso, por eso el relay en vez de broadcast). Para esto
% %no es necesario sortition porque es simplemente forwardear.
% extract $cred.j$ and, if it is nonzero, broadcast the vote:
% $$
%     \mathsf{Broadcast}(Vote(a.I,r,p,cert,v,cred))
% $$
% else do nothing.
% After this, the algorithm finishes and the event handler is called again.



\end{subsection}

\end{section}
% ---------------------------------------------------------------------
\begin{section}{Strutcture}
The Algorand protocol is implemented in a network over the Internet, where nodes 
form a peer-to-peer network. More explicitly, a set of whitelisted relay nodes 
interact with participation nodes where the latter receive transactions and
implement the protocol while the former simply relay whatever they receive from
the nodes.

A participation node includes:
\begin{itemize}
    \item a timer which may receive a $\mathsf{reset()}$ order or a $\mathsf{time()}$
order. It will record the current time when reset is called (e.g., by querying
the OS where the node runs) and will report the elapsed time since the last reset
in the latter case.
    \item A virtual machine, the Algorand Virtual Machine, which can process TEAL bytecode
etc etc
    \item a network interface
    \item A XX implementing the consensus algorithm
    \item A database engine including at least the following tables:
\end{itemize}



A participation node keeps a transaction pool. Whenever a transaction arrives, its signature
is verified, and it is stored in the transaction pool. Nodes do have a limit, e.g, they will
keep 1,000 transactions and ignore the rest.\marginpar{is this ok?}
These transactions are processed by the node as follows.
\begin{itemize}
    \item The node orders the transactions as they arrive.
    \item The node verifies the signature of the transaction (i.e., the transaction has an 
    address as its source, this address also identifies a public key that may be used to 
    verify the signature); if it is a logicsig, it is verified; if it is an app call, then
    the run is simulated.
    \item At some point, the node starts assembling the node. It will now rerun all transactions
    (but no logicsigs) the transaction is interpreted by the AVM. It will either succeed or
    fail. If it succeeds, it may alter the ledger and balances for the next block. These 
    changes are recorded.. Changes to the balances and ledger are temporary recorded and
    checked for inconsistencies (e.g., local to the block creation)
    \item Once a timeout is reached, the node will collect all the changes into a block 
    proposal. e.
\end{itemize}

During consensus, a node that receives an e it will validate same as above.

Once consensus accepted a block, e, it needs to run all transactions again
but now modifies de ledger and balances. 


{\bf Standards and Conventions:}
Algorand protocols make use of two hash functions of the SHA-2 family
as defined in \cite{NIST.FIPS.180-4}: SHA256 and SHA512/256.

    
% ---------------------------------------------------------------------    
\begin{subsection}{Network}
A network is formed of two kinds of nodes: {\sf relay nodes}\index{relay nodes}
and {\sf participation nodes}\index{participation nodes}. 
Both nodes operate on servers that are connected to the internet and run publicly
available code from \href{https://github.com/algorand/go-algorand}{Algorand's code repository}.
Participation nodes can connect only to relay nodes, they run an instance
of the Aglorand Virtual Machine (AVM)\index{Algorand Virtual Machine}.\marginpar{el voting y demas esta afuera de la avm?}

%el voting y demas esta afuera de la avm? Si, todo el mecanismo de consenso corre completamente independiente de la AVM.
%La AVM solo ejecuta los smart contracts o logicsigs y esto es a nivel de txn, previo a la ejecucion del algoritmo total
%o sea, es en la validacion de txns (y txn groups), que se da Antes del block assembly.
%Las txns llegan y las encola un handler, y por lo que entendi del codigo se pasan a la txn pool ya validadas.
%La txn pool tiene un limite tambien, despues del cual empieza a droppear. Esto parece ser implementativo, en el sim
%es un parametro y estoy usando 1000 (lo saque del unit test del txn pool).
%Cuando se ensambla el bloque tambien se valida, pero ya no las txns individuales sino que tenga coherencia el orden.
%La creacion de bloque tambien tiene un tiempo maximo pero ese parametro no esta especificado en ningun lado, creo que
%esta dejado a libre implementacion. En el sim por ahora esoy asumiendo creacion instantanea en cuanto a tiempo de
%simulacion.

They are non-archival in nature, meaning they don't keep\index{archival node}\index{non-archival node}
the whole ledger in memory at all times. At the time of this writing,
participation nodes keep the latest 1000 blocks.
Any queries that require blocks prior to those, need to be made
through one of the relay nodes they are connected to.
These nodes are responsible for running the consensus algorithm that
will be outlined in this document.
Relay nodes on the other hand, are archival (meaning they have immediate
access to the whole ledger), but do not participate in consensus.
They function as network level facilitators, collecting messages sent by participation
nodes or other relay nodes and distributing them across the network.

Currently, any individual or entity is able to run a participation node, 
but relay nodes are permissioned. They must be {\em whitelisted} by 
Algorand Foundation.\marginpar{validar que es AF quien whitelistea}

When a participation node is booted up, it establishes a peer-to-peer (P2P) 
channel with at least one relay (4 on average), using a phone book which is included
as part of the node's code. 
Relay nodes manage a significantly higher number of connections, as they 
are responsible for keeping the network's high throughput.

Accounts are managed by participation nodes. Accounts should be registered in at least one participation
node only, however this is not enforced.
In order for an account to participate in consensus, it needs to switch its status to "online". 
That is achieved by sending a special {\tt keyreg} transaction,\index{{\tt keyreg} transaction}
which registers a participation key for the account and creates a two-level ephemeral key tree.
It is important to note that the registered account will only start participating in consensus
$\delta_b$ rounds after the key registration transaction is approved.
Any account participating in consensus does so with their full balance. There is no risk
associated to participation, nor there are any rewards for running a node.


TODO: maybe include some voting stats?

\end{subsection}
% ------------------------------------------------------------------------
\begin{subsection}{The Algorand Virtual Machine}\label{sect:avm}
    
    \begin{quote} 
        {\em``The Algorand virtual machine (AVM) runs on every node in the Algorand blockchain. 
    This virtual machine contains a stack engine that evaluates smart contracts and smart 
    signatures against the transactions they're called with. These programs either fail 
    and reject the transaction or succeed and apply changes according to the logic and 
    contents of the transactions.''} From \href{https://developer.algorand.org/docs/get-details/dapps/avm/}{Algorand.org}
    \end{quote}
    
The AVM receives signed transactions that may or may not alter the 
state of the blockchain and interprets TEAL, or the Transaction Execution 
Approval Language, an assembly-like language designed by Algorand 
for the blockchain.,

\end{subsection}
% --------------------------------------------------------------------------------------
\begin{subsection}{Keys}
    Algorand nodes interact with 3 types of keys:
    Root or spending keys,
    Voting or participation keys and
    VRF selection keys.

    %comentario general sobre como funciona un esquema de firma publica/privada
    %podria estar mejor
    Generally all keys will be in pairs, in a public / private cryptographic scheme.
    This scheme supports a signing procedure, which uses the private key and outputs a signature, 
    and a verification procedure, which uses a public key and outputs a boolean value, and allows
    a node to certify that the data was indeed signed by the specified participant.

    Spending keys are 32 byte keys used by accounts to sign and verify transactions
    on behalf of accounts. Nodes interact only with public spending keys, out of which
    Algorand addresses are derived. Private spending keys are used to sign transactions
    and should be kept privately by the user managing the relevant account, unless the account
    is rekeyed in which case the private key of the account designated by the rekeying operation
    is the key authorized to sign transactions on behalf of this account.

    Participation keys are used to sign all consensus messages. They are organized in a tree scheme.
    %(generated through the goal addpartkey command). 
    The private keys in the scheme are stored as secrets by the node,
    while their public keys are a mandatory part of online account records.
    They correspond to the ed25119 eliptic curve cryptographic standard (TODO: CITAR standard).
    Previous to online account registration, the node generates a root participation key, a batch of subkeys
    of size n, and n sub-batches of ephemeral keys (each one of size k), according to the key dilution field.
    A keyreg transaction needs the root public participation key as a valid field.
    Ephemeral keys are leaves of the two level tree, and are used to sign consensus messages for a given round.
    They are deleted after the succesful advancement of a round.
    An agreement vote message is valid only when it is signed with the correct voting key.

    %https://github.com/algorand/go-algorand/blob/9af066b4e9fc43329d23faa5735f16f2543c4687/crypto/onetimesig.go

    Selection or VRF keys are keys used for committee membership selection and verification.
    VRF public keys are kept inside account records (in the $BT$),
    and are needed in order for an account to vote, as they will be
    used to verify committee membership by nodes receiving votes.
    They make use of an Algorand fork of the Sodium C library (citar!), implementing VRF signing, verification and
    key generation functions.
    The account's private keys are kept as secrets by the node, and are guaranteed to be non-persistant in memory.

    %https://github.com/algorand/go-algorand/blob/9af066b4e9fc43329d23faa5735f16f2543c4687/crypto/vrf.go



\end{subsection}
% --------------------------------------------------------------------------------------
\begin{subsection}{Node as a State Machine}
A network participation node can be modeled as a state machine.
In this section we will define all primitives and data structures necessary to define the state
of a node; the rest of the work will be spent on describing the rules and interrelations that
make nodes transition from and into different states.

Online accounts are registered to a node. This node takes care of voting for these accounts.
Hence, the state for these accounts, is the state of the node. As many accounts may be 
registered in one node, the node will manage the participation for all of these accounts 
concurrently.

The {\sf state of a node} \index{node's state}\index{state of a node}
is given by the {\sf execution state} which is defined as the 3-tuple of nonnegative integers $(r, p, s)$, 
an observed proposal, $P$, 
an observed vote, $V$, 
a Ledger $L$ and 
a balance table $BT$.
Explicitly, we define the state of a node, $S$, as a tuple of values, 
$$
S = (r, p, s, V, P, \bar{v}, \bar{s}, L, BT)
$$ 
where
\begin{itemize}
    \item 
    $r\in\mathbb{Z}_{\ge 0}$ is the current round and recorded as a 64-bits integer. 
    The round variable start as $r=0$, when the genesis block is generated, and increases
    by one after each block is accepted.\marginpar{revisar wording}
    
    \item 
    $p\in\mathbb{Z}_{\ge 0}$ is the current period within the round and recorded as 
    a 64-bits integer. When the round starts, $p$ is set to 0 ($p=0$), and it is 
    increased via the function $\mathcal(F)$ (see \ref{fun:compute-p}).
    
    \item 
    $s\in\mathbb{Z}, 0\le s\le 256$ is the current {\sf step}\index{step} within the round
    and recorded as a 64-bits integer. When the round starts, $s$ is set to 0 ($s=0$), 
    and it is increased via the function $\mathcal(F)$ (see \ref{fun:compute-s}) and 
    labeled according to table (see (\ref{table:s})).
    
    \item
    $V$ is the set of all {\sf valid observed votes}\index{valid observed votes} and 
    {\sf equivocation votes}\index{equivocation votes} in the current execution state
    ($(r,p,s)$)
    
    \item
    $P$ is the set of all {\sf valid observed proposals}\index{valid observed proposals}
    in the current execution state ($(r,p,s)$)
    
    \item
    $\bar{v}$ is the pinned proposal-value
    
    \item
    $\bar{s}\in\mathbb{Z}_{\ge 0}$, a 64-bits integer, is the {\sf last finished step}\index{last finished step}
    
    \item
    $L$ is the {\sf ledger}, a structure that holds a sequence of states comprising the common
    information established by the current instantiation of the Algorand protocol.
    \footnote{Note that, thanks to the genesis hash and previous 
    hash components, a ledger state unambiguously defines the whole history of state changes.}. 
    
    \item
    $BT$ is the current balance table as described above.
    
    \item
    $TP$ is the node's transaction pool

    \item 
    The current time $\mathtt{time}$ in seconds, and the elapsed time since the last
    time reset was called.
\end{itemize}
The first 7 values are the {\sf consensus state parameters},\index{consensus state parameters}
whereas $L$ and $BT$ are {\sf ledger state parameters}.\index{ledger state parameters}

Let round and period number, $r$ and $p$, be unsigned 64-bits integers. 
step number, $s$, be an unsigned 8 bits integer.
For convenience and readability, we define the following enumeration for step number:
\begin{equation}\label{table:s}
\left\{    
    \begin{array}{ll}
        \mathsf{proposal}&\mbox{if }s=0 \\
        \mathsf{soft}&\mbox{if }s=1 \\
        \mathsf{cert}&\mbox{if }s=2\\
        \mathsf{next}_{s-3}&\mbox{if }s\in [3, 252]\\
        \mathsf{late}&\mbox{if }s=253\\
        \mathsf{redo}&\mbox{if }s=254\\
        \mathsf{down}&\mbox{if }s=255
    \end{array}
\right.
\end{equation}

% ledger
It is identified by a string called the genesis identifier, as well as a genesis hash that cryptographically 
commits to the starting state of the ledger.
Besides the already defined round number $r$, which indexes into the Ledger's sequence of states,
a Ledger's state is defined by the following components:
\begin{itemize}
    \item Genesis identifier and genesis hash, unambiguously defining the ledger 
    to which the state belongs.
    \item Protocol version and update state.
    \item Timestamp (in milliseconds since genesis block), identifying when the state was first proposed.
    \item A 64-byte seed, source of randomness for the consensus algorithm.
    \item The current reward state, which describes the policy at which incentives
    are distributed to participants.
    \item The current box state, which holds mappings from (app id, name) tuples
    to box contents of arbitrary bytes.
\end{itemize}

% balance
A {\sf balance table}\index{balance table}, $BT$, is a mapping of addresses to 
account records where an {\sf account record}\index{account record} comprises 
 a 64-bits unsigned integer raw balance, 
 a 3-state flag status (can be ``online'', ``offline'', or ``non-participating''),
 its registered voting keys (more info on subsection~\ref{sect:Keys}, keys) and 
 two 64-bits unsigned integers $r_{start}$ and $r_{last}$, which represent the 
   validity interval (in rounds)\marginpar{Pero la part key donde esta guardada?}
   for the participation key (which acts as the root voting key for the Merkle 
   tree).\marginpar{Cu\'al merkle t. no se definio!}

A node may query the current state of a particular account by indexing the balance 
table by address, or it might query a previous round's account state by adding a 
round indexing. 
Note that past account states are always computable by iterating over the Ledger
sequence of blocks and reverting transaction updates. Internally however, certain
past records might be cached and maintained to improve performance.

For convenience, we assume that each node maintains an account list that provide 
easy iteration access to all updated balance records for the accounts it manages 
which are flagged as online and have a valid participation key registered on this
node. 
This array is named $A$ from now on, and each entry $a\in A$ has an account address 
$a.I$, and all the information in its mapped balance record, $BT[a.I]$.

% transaction pool
The Transaction pool, $TP$, which is a set of live unconfirmed transactions, $txn_k$, (where 
$k$ is an account's address, the creator and sender of the transaction), either
sent by accounts that are managed by the node itself or obtained from the network 
(broadcast by other nodes).
For the purpose of this article, transactions are an otherwise opaque object, with the 
attribution of modifying account records.

% block
A {\sf block} is a data structure which specifies the transition between states.
The data in a block is divided between the block header and its block body.
A block header holds the following data:
\begin{itemize}
    \item
    The block's round, which matches the round of the state it is transitioning
    into. (The block with round 0 is special in that this block specifies not
    a transition but rather the entire initial state, which is called the genesis
    state. This block is correspondingly called the genesis block).
    
    \item
    The block's genesis identifier and genesis hash, constant and decided on
    Ledger creation.
    
    \item
    The block's upgrade vote, which results in the new upgrade state. The
    block also duplicates the upgrade state of the state it transitions into.
    
    \item
    The block's timestamp, which matches the timestamp of the state it transitions into. 
    The timestamp is decided by the proposer of the block using their own internal clock. 
    To be valid, a timestamp must be greater than the last committed block's timestamp 
    and must not be more than 25 seconds away from said time.
    
    \item
    The block's seed, which matches the seed of the state it transitions into.
    
    \item
    The block's reward updates, which results in the new reward state. The
    block also duplicates the reward state of the state it transitions into.
    
    \item
    A cryptographic vector commitment, using SHA512/256 hash function,
    to the block's transaction sequence.
    
    \item
    A cryptographic vector commitment, using SHA256 hash function, to the block's
    transaction sequence (useful for compatibility with systems where SHA512/256 
    is not supported).
    
    \item
    The block's previous hash, which is the cryptographic hash of the previous
    block in the sequence. (The previous hash of the genesis block is 0).\marginpar{cual de los dos hashes? sha256 o sha512/256?}
    
    \item
    The block's transaction counter, which is the total number of transactions
    issued prior to this block. This count starts from the first block with a
    protocol version that supported the transaction counter.
    
    \item
    The block's expired participation accounts, which contains an optional slice
    of public keys of accounts. These accounts are expected to have their
    participation key expire by the end of the round (or was expired before
    the current round).
    The block's expired participation accounts slice is valid as long as the participation keys 
    of all the accounts in the slice are expired by the end of the round or
    were expired before, the accounts themselves would have been online at the end
    of the round if they were not included in the slice, and the number of elements
    in the slice is less or equal to 32. A block proposer may not include all such
    accounts in the slice and may even omit the slice completely
\end{itemize}
While a block's body is the block's transaction sequence, which describes the sequence
of updates to the account state and box state.\marginpar{los account records no tienen states!}
%adp: tecnicamente los local y global states son account updates, 
%los local states viven en en el account record y tenes uno por cada app 
%a la que estes opted in, los global funcionan similar para la cuenta del contrato
%los boxes los maneja como algo separado por eso estan aparte
%
% aw: pero fijate que en la definicion de account record, solo tiene keys y alguna
% cosa mas pero nada de memoria de este tipo.

% hashmap: address\mapsto 
% ( balance, 
% online/offline/nonparticipating, 
% lista de ASA IDs a los que estes optinieado y sus balances, 
% apps IDs a las que estes optineado y los local states,
% ) en el caso de que sea un smart contract es el globarl state y los boxes

Applying a valid block to a state produces a new state by updating each of its components.
A Ledger's evolution in time can then be specified as an ordered sequence of blocks.

A proposal-value is a tuple $v = (I, p, H(e), H(Encoding(e)))$ where 
$I$ is an address (the ``original proposer''), 
$p$ is a period (the ``original period''), 
{\bf Definir e}
and
$H(\,)$ is a cryptographic hash function (implemented as SHA512/256). 
The special proposal where all fields are the zero-string is called the bottom 
proposal $\bot$. 
It also includes the authentication information for the original proposer, that is, 
a signature and VRF proof of the proposal-value.


%claro, deberia ser que corresponde especificamente a la parte del Hash(e) de v. Ahi lo corregi abajo
For convenience, we define the function $Proposal:v\mapsto{Proposal}(v)$ for a given proposal value 
$v$,  such that $Proposal(v) = e$ if, and only if, $e$ is the proposal that, when hashed, corresponds 
to the block hash $H(e)$ of the proposal value $v$. \marginpar{ENtonces $H(e)=v$?}
The $Proposal()$ function has an inverse, $Proposal_{value}(e)$, such that
$Proposal_{value}(e) = v$ if $Proposal(v) = e$.
$Proposal()$ is not a bijective function (as hashes can theoretically collide), however we assume the inverse
exists and has a defined output whenever the relevant proposal has been observed by the node
(and is such that $e \in P$).\marginpar{Que es el cjto P?}

%where P is the set of all observed proposals in a given round and period (en realidad tenes las del periodo anterior y el
%siguiente disponibles tambien).


We define an auxiliary structure, $credentials$, useful in voting, with the following fields:
\begin{itemize}
    \item $sh$ is the sortition hash (64-byte string).
    \item $\pi$ is the sortition proof (32-byte string).
    \item $j$ is a 64-bit unsigned integer that represents the vote's weight.
\end{itemize}
An object of this type is output by the $\mathsf{Sortition}()$ procedure.

A vote $vt$, constructed as $Vote(I,r,p,s,v,cred)$ is a tuple with the following members:
\begin{itemize}
    \item $I$ is a valid Algorand address (in 32-byte format).
    \item $r$ is the vote's round (64-bit integer).
    \item $p$ is the vote's period (64-bit integer).
    \item $s$ is the vote's step (8-bit integer).
    \item $v$ is the vote's proposal value.
    \item $cred$, of type $credentials$, the committee credentials of the voter.
\end{itemize}

In practice, votes are broadcast wrapped in a structure called ``Unauthenticated Vote'', 
where the $credentials$ field is added, containing only the voter's sortition proof and 
address.
The rest of relevant data is reconstructed as part of the verification process, 
where a node authenticates the received vote and obtains the vote weight and sortition hash.
For the sake of simplicity we abstract away this step and assume availability of all 
$credentials$ fields.


% equivocation vote
Let $I$ be an address, $r, s, p\in\mathbb{Z}_{\ge 0}$, $cred$ a credential, and $v_0,v_1$ different
vote proposals.
An {\sf equivocation vote}\index{equivocation vote} happens when a pair of votes
$vt_0 = Vote(I, r, p, s, v_0, cred)$ and $vt_1 = Vote(I, r, p, s, v_1, cred)$.
An equivocation vote is valid if both of its constituent votes are valid.
It is important to keep in mind that nodes are forbidden from equivocating 
on any steps $s \neq soft$.\marginpar{What does this mean? How do nodes enforce this?}

% bundle
A {\sf bundle}\index{bundle} is a set $b = Bundle(r,p,s,v)$ such that for any pair of distinct values 
$vt_0, vt_1 \in b$ the following conditions hold: 
a) $vt_0.r = vt_1.r $, 
b) $vt_0.p = vt_1.p$,
c) $vt_0.s = vt_1.s$,
d) for each pair of distinct elements, either $vt_0.I \neq vt_1.I \land vt_0.v = vt_1.v$ or the pair $vt_0$, $vt_1$ 
is an equivocation vote, and
e) the number of votes in $b$ is such that the sum of weights for each vote in $b$ is greater or equal to the
committee threshold of the votes in the set.

% highest priority
For convenience, we define two special values: $\mu(r,p)$ and $\sigma(r,p)$.
$\mu(r,p)$ is the highest priority observed proposal-value in the current $(r,p)$ context 
(lowest hashed according to the function outlined in the $\mathsf{BlockProposal}$ algorithm), 
or $\bot$ if no valid proposal vote has been observed by the node.
$\sigma(r,p)$ is the sole proposal-value for which a soft bundle has been observed (again, 
in the current $(r,p)$ context), or $\bot$ if no valid soft bundle has been observed by the 
node.
\end{subsection}

\end{section}
% ------------------------------------------------------------------------
\begin{section}{Main algorithm}
% Broadcast(e) = Event(type=proposal-payload, data=e, sign=Signature(pk_sender, e))
% Broadcast(Vote(....)) = Event(type=vote, data=Vote(....), sign=Signature(pk_sender, Vote(....)))
%
% Broadcast(Bundle) = Event(type=bundle, data={v for v in Bundle}, sign=Signature(pk_sender, {v for v in Bundle}))

The node is reactive. The main algorithm for the node, thus, starts when it receives 
any input, it makes computations --probably modifying the state of the node-- and 
may end by broadcasting data to other nodes.

\begin{algorithm}[H]
    \caption{\underline{Main node algorithm}}
    \label{algo:main}
    \begin{algorithmic}[1]
    \Function{$\mathsf{EventHandler}(Event \ ev)$}{}
    
    \If{$ev \ is \ TimeoutEvent$}
        \State $time \gets ev.time$
        \If{$time = 0$}
            \State $\mathsf{BlockProposal}()$
        \ElsIf{$time = \mathsf{FilterTimeout}(p)$}
            \State $\mathsf{SoftVote}()$
        \ElsIf{$time = \max\{4\lambda, \Lambda \}$}
            \State $\mathsf{Recovery}(next_0)$
        \ElsIf{$time = \max\{4\lambda, \Lambda \} + 2^{st-3}\lambda + r, st \in [4, 252], r \in U[0, 2^{st-3}\lambda]$}
            \State $\mathsf{Recovery}(next_{st-3})$
        \ElsIf{$time = k\lambda_f + r, k \in \mathbb{Z} \land k>0, r \in U[0, \lambda_f]$}
            \State $\mathsf{FastRecovery}()$
        \EndIf
    \Else \ //ev is MessageEvent
        \State $msg \gets ev.msg$
        \If{$msg \ is \ of \ type \ Proposal \ p$}
            \State $\mathsf{HandleProposal}(p)$
        \ElsIf{$msg\ is \ of\ type\  Vote \ v$}
            \State $\mathsf{HandleVote}(v)$
        \ElsIf{$msg\ is\ of\ type\ Bundle \ b$}
            \State $\mathsf{HandleBundle}(b)$
        \EndIf
    \EndIf

    \EndFunction
    \end{algorithmic}
\end{algorithm}

On a higher level, we can think of a step as a defined part of the consensus algorithm. The first three steps
($proposal$, $soft$ and $cert$)
are the fundamental parts, and will be the only steps run in normal, ``healthy'' functioning conditions.
The following steps are recovery procedures in case there's no observable consensus before their trigger times.
$next_{s-3}$ with $s \in [3, 252]$ are recovery steps and the last three ($late$, $redo$ and $down$)
are special ``fast'' recovery steps.
A period is an execution of a subset of steps, ran in order until one of them achieves 
a bundle for a specific value. A round always starts with a $proposal$ step and finishes with a $cert$
step (when a block is certified and commited to the ledger). However, multiple periods might
be run inside a round until a certification bundle ($Bundle(r,p,s,v) $ where $s = cert$) is observable by the network.

\medskip
Events are the only way in which the node state machine is able to both internally transition and produce output.
In case an event is not identified as misconstrued or malicious in nature, it will certainly produce a state change,
and it will almost certainly cause a receiving node to produce and then broadcast or relay an output, to be consumed
by its peers in the network.
There are two kinds of events: Timeout events, which are produced once the internal clock of a node reaches a certain
time since the start of the current period; and Message events, which is output produced by nodes in response to some stimulus
(including the receiving node itself).
Internally, we consider the relevant data of an event to be:
\begin{itemize}
    \item A floating point number representing time in seconds, from the start of the current period, in which the event
    has been triggered.
    \item An event type, from an enumeration of two options (either $TIMEOUT$ or $MESSAGE$)
    \item An attached data type, an enumeration of four options: $NONE$ (chosen in case of an event of main type $TIMEOUT$), 
    $VOTE$, $PROPOSAL\_PAYLOAD$ and $BUNDLE$. It indicates the type of data attached.
    \item Attached data, plain bytes to be cast and interpreted according to the attached data type, or empty in case of a
    timeout event.
\end{itemize}

$\mathbf{Timeout \ Events}$ are events that are triggered after a certain time has elapsed after the start of a new period.
\begin{itemize}
    \item $soft$ Timeout (aka. Filtering): The filter timeout is run after a timeout of $FilterTimeout(p)$ is observed 
    (where $p$ is the currently running period). Note that it only depends on the period as far as if it's the first
    period in a round or a subsequent one.
    Will perform a filtering action, finding the highest priority proposal observed to produce a soft vote, as detailed
    in the soft vote algorithm.

    \item $next_0$ Timeout: it's the first recovery step, only executed if no consensus for a specific value was observed,
    and no $cert$ bundle is constructible with observed votes. It plays after observing a timeout of $\max\{4\lambda, \Lambda \}$.
    In it, the node will next vote a value and attempt to reach a consensus for an $next_0$ bundle, that would in turn kickstart
    a new period.

    \item $next_{st}$ Timeout: this family of timeouts runs whenever the elapsed time since the start of the period reaches
    $\max\{4\lambda, \Lambda \} + 2^{st-3}\lambda + r$, where $st\in [4, 252]$ and $r \in [0, 2^{st-3}\lambda]$, a random 
    delta sampled uniformly at random that represents network variability.
    The algorithm run is exactly the same as in the $next_0$ step.

    \item Fast recovery Timeout ($late$, $redo$ and $down$ steps): On observing a timeout of $k\lambda_f + r$ with $r$ a uniform random sample in $[0, \lambda_f]$ and
    $k$ a positive integer, the fast recovery algorithm is executed. It works in a very similar way to $next_k$ timeouts, with some subtle differences (besides trigger time).
    For a detailed description refer to its own subsection.
\end{itemize}


$\mathbf{Message \ Events}$ Are events triggered after observing a certain message carrying data.
There are 3 kinds of messages: votes, proposal payloads, and bundles, and each carry
the corresponding construct (coinciding with their attached data type field).

% --------------------------------------------------------------------
\begin{subsection}{Block Proposal}\label{ssect:blockproposal}

    \begin{algorithm}
        \caption{\underline{Block proposal}}
        \label{algo:block-proposal}
        \begin{algorithmic}[1]
        \Function{$\mathsf{BlockProposal}$}{}

            \State $\mathsf{ResynchronizationAttempt}()$

            \For{$a \in A$}
                \State $cred \gets 
                \mathsf{Sortition}(a, proposal)$
                \If{$cred.j > 0$}
                    \If{$p = 0 \lor \exists s^\prime \textfractionsolidus Bundle(r, p-1, s^\prime, \bot) \subset V$}
                        \State $e \gets \mathsf{AssembleBlock}()$
                        \State $v \gets Proposal_{value}(e)$
                        \State $\mathsf{Broadcast}(Vote(a.I, r, p, proposal, v, cred))$
                        \State $\mathsf{Broadcast}(e)$
                    \Else
                        %VER. Convencerme de que siempre es el pinned value
                        %\State $v \gets v_0 \textfractionsolidus \exists s, Bundle(r,p-1,s,v_0) \subset V$
                        \State $\mathsf{Broadcast}(Vote(a.I, r, p, proposal, \bar{v}, cred))$
                        \If{$Proposal(\bar{v}) \in P$}
                            \State $\mathsf{Broadcast}(Proposal(\bar{v}))$
                            % proposal(\bar v) es un broadcast de un e 
                        \EndIf
                    \EndIf
                \EndIf
            \EndFor
        \EndFunction
        \end{algorithmic}
    \end{algorithm}

\newpage
% porposal = s
\noindent \textbf{Description:}\\
Block proposal is the first step, and the starting stage of the algorithm on every period.
First, on line 2, the node attempts a resynchronization (described in \ref{sect:soubroutines}). 
This only has any effect on periods $p > 0$.
Afterwards, the node loops through all of its managed online accounts, Functionally
"playing" for each of the accounts. This is a pattern that we'll see in every other
main algorithm subroutine that performs any form of committee voting.

Lines 6 to 14 are the core proposal algorithm. On lines 6 to 10, 
if the node's on a first period, or it observed a bundle for the bottom proposal on the previous 
period (meaning there is no valid pinned value), then it will assemble a block, compute the proposal-value for the 
previously assembled block, broadcast a proposal vote by the selected account for this value, and 
broadcast the full block in a proposal payload message.
Otherwise, the node is at least on a second period and it has a pinned value available, supported by a 
bundle observed in the period immediately before, being the observation of this bundle the event to trigger 
a period change in the first place. On line 12 the node gets this value explicitly, which coincides with the pinned
value $\bar{v}$. 
%P*? CAN the pinned value at this stage, by some manipulation of equivocation votes, not be unique? meaning there
%is more than one full bundle for the past period.
Then, for every account selected, a proposal vote for this pinned value is broadcast. Afterwards, 
if the corresponding full proposal has been observed, then it is also broadcast.


\end{subsection}
% ---------------------------------------------------------------------------------------------------
\begin{subsection}{Soft Vote}\label{ssect:softvote}

\begin{algorithm}[H]
    \caption{\underline{Soft Vote}}
    \label{algo:soft-vote}
    \begin{algorithmic}[1]
    \Function{$\mathsf{SoftVote}$}{}
    \State $lowestObservedHash \gets \infty$
    \State $v \gets \bot$ 

    \For{$vt^\prime \in V \text{ with } vt^\prime.step = proposal$}
        \State $priorityHash \gets \min_{i \in [0, vt^\prime.cred.j)} \{ \mathsf{H}(vt^\prime.cred.sh || i)\}$
        \If{$priorityHash < lowestObservedHash$}
            \State $lowestObservedHash \gets priorityHash$
            \State $v \gets vt.v$
        \EndIf    
    \EndFor

    \If {$lowestObservedHash < \infty$}
        \For{$Account \ a \in A$}
            \State $cred \gets \mathsf{Sortition}(a, soft)$
            \If{$cred.j > 0$}
                \State $\mathsf{Broadcast}(Vote(r, p, soft, v, cred))$
                \If{$Proposal(v) \in P$}
                    \State $\mathsf{Broadcast}(Proposal(v))$
                \EndIf
            \EndIf
        \EndFor
    \EndIf

    \EndFunction
    \end{algorithmic}
\end{algorithm}

\noindent \textbf{Description:}\\
The soft vote stage (also known as ``filtering'') is run after a timeout of $\mathsf{FilterTimeout}(p)$
(where $p$ is the executing period of the node) is observed by the node. 
That is to say, filtering is triggered after either a $2\cdot\lambda_0$ or $2\cdot\lambda$ timeout is observed according 
to whether $p=0$ or $p>0$ respectively.
Let $V*$ be all proposal votes received. 
With the aid of a priority hash function, this stage performs a filtering action,
keeping the lowest hashed value observed.
The priority function (lines 4 to 8) should be interpreted as follows. Consider every proposal vote $vt$ in $V*$.
Given the sortition hash $sh$ output by the $\mathsf{VRF}$ for the proposer account, and for each sub-user unit $i$ 
in the interval from $0$ (inclusive) to the vote weight (exclusive; the $j$ output of $\mathsf{Sortition}()$ inside 
the $cred$ credentials structure), the node hashes the concatenation of $sh$ and $i$, $\mathsf{H}(sh||i)$ 
(where $\mathsf{H}()$ is the node's general cryptographic hashing function). On lines 6 to 8, 
then, it keeps track of the proposal-value that minimizes this concatenation and subsequent hashing procedure.
After running the filtering algorithm for all proposal votes observed, and assuming there was at least one vote
in $V*$, the broadcasting section of the filtering algorithm is executed (lines 9 to 15).
For every online managed account selected to be part of the $soft$ voting committee, a $soft$ vote is
broadcast for the previously found filtered value $v$. If the full proposal has been observed and is available in $P$,
it is also broadcast. 
If the previous assumption of non-empty $V*$ does not hold, no broadcasting is performed and the node produces no
output in its filtering step.

\end{subsection}

% --------------------------------------------------------------------
\begin{subsection}{HandleProposal}\label{ssect:handle-proposal}

    \begin{algorithm}[H]
        \caption{\underline{HandleProposal}}
        \label{algo:handle-proposal}
        \begin{algorithmic}[1]
        \Function{$\mathsf{HandleProposal}$}{$Proposal \ e$}

            \State $v \gets Proposal_{value}(e)$

            %relays proposal if its for a future round (but does not process it)
            \If{$\sigma(r+1, 0) = v$}
                \State $\mathsf{Relay}(e)$  %relay broadcasts to everyone except proposal sender
                \State $\mathsf{return}$  //do not observe, as it's for a future round (we're behind)
            \EndIf

            %ignores proposal if it's invalid or if it has already been observed
            \If{$\lnot \mathsf{VerifyProposal}(e) \lor e \in P$ }
                \State $\mathsf{return}$  //ignore proposal
            \EndIf

            %ignores proposal if its proposal value is not either 
            %the current sigma, the pinned value or the current mu
            \If{$v \notin \{ \sigma(r,p), \bar{v}, \mu(r,p)\}$}
                \State $\mathsf{return}$ //ignore proposal
            \EndIf

            %we need to relay (broadcast to everybody but ourselves and o.g. sender), and observe p
            \State $\mathsf{Relay}(e)$
            \State $P \gets P \cup e$

            %all checks passsed, produce output
            \If{$\mathsf{IsCommitable}(v) \land s \leq cert$}
                \For{$a \in A$}
                    \State $cred \gets 
                    \mathsf{Sortition}(a, cert)$
                    \If{$cred.j > 0$}
                        \State $\mathsf{Broadcast}(Vote(a.I, r, p, cert, v,  cred))$
                    \EndIf
                \EndFor    
            \EndIf

        \EndFunction
        \end{algorithmic}
    \end{algorithm}
    
    
    \noindent \textbf{Description:}\\
The proposal handler is triggered when a node receives a message containing a full proposal.
It starts by performing a series of checks, after which it will either ignore the received
proposal, discarding it and emitting no output; or relay, observe and produce an output
according to the proposal's characteristics and the current context.
The first check (lines 3 to 5) is a special case, where if the proposal is from the next round's 
first period, the node relays it and then ignores it for the purpose of the current round. 
Whenever the node catches up (observes a round change), and only if necessary, it will request 
this proposal back from the network.
Lines 6 and 7 check if the proposal is invalid, or if it has been observed already. Any one of those
conditions are sufficient to discard and ignore the proposal.
Finally, on lines 8 and 9 it checks if the associated proposal value is either of the special values for the current
round and period ($\sigma$, $\mu$, or the pinned proposal value $\bar{v}$). Any proposal whose proposal value does not match
one of these is ignored.
Once the checks have been surpassed, the node is ready to relay the proposal and observe it by adding
it to the observed proposals set, $P$ (lines 10 and 11).
Once relayed and observed, the proposal is then processed for further output.
Here, and only if the proposal value has become committable and the current executing node's step is lower or equal
to a certification step (it's not yet in a recovery step), the node plays for each account performing sortition
to select committee members for the certification step. For each selected member, a corresponding certify vote for
the current proposal value is cast.


\end{subsection}

% --------------------------------------------------------------------

\begin{subsection}{HandleVote}\label{ssect:HandleVote}

    \begin{algorithm}[H]
        \caption{\underline{HandleVote}}
        \label{algo:handle-vote}
        \begin{algorithmic}[1]
        \Function{$HandleVote$}{$Vote \ vt$}

            % //P*? como funciona la penalizacion del jugador en este caso (funcion PenalizePeer())?
            
            % //P*? que pasa si vt.round $>$ r+1? Crash? Hay algun mecanismo de bootstrapping a ese punto?
            
            % //P*? cómo funciona la operación de relay? Sólo reenvía, o es un broadcast?
            
            % //P*? cómo funciona internamente el request for proposal?

            % //P*? si el voto es repetido, el nodo lo ignora verdad? Esto no esta especificado asi, pero es quizas un error?
            % \\

            \If{$\mathbf{not}\; \mathsf{VerifyVote}(vt)$}
                \State $\mathsf{PenalizePeer}(SENDER\_PEER(vt))$ \ //optional
                \State $\mathsf{return}$ \ //ignore invalid vote
            \EndIf

            \If{$vt.step = 0 \land (vt \in V \lor \mathsf{IsEquivocation}(vt))$}
                \State $\mathsf{return}$ \ //ignore vote, equivocation not allowed in proposal votes
            \EndIf

            \If{$vt.step > 0 \land \mathsf{IsSecondEquivocation}(vt) $}
                \State $\mathsf{return}$ \ //ignore vote if it's a second equivocation
            \EndIf

            \If{$vt.round < r $}
                \State $\mathsf{return}$ \ //ignore vote of past round
            \EndIf

            \If{$vt.round = r+1 \land (vt.period > 0 \lor vt.step \in (cert, late))$}
                \State $\mathsf{return}$ \ //ignore vote of next round if non-zero period or $next_k$ step
            \EndIf

            \If{$vt.round = r \land (vt.period \notin [p-1, p+1] \lor$ \\
            $(vt.period = p+1 \land vt.step \in (next_0, late)) \lor$ \\
            $(vt.period = p \land vt.step \in (next_0, late) \land vt.step \notin [s-1, s+1]) \lor$ \\
            $(vt.period = p-1 \land vt.step \in (next_0, late) \land vt.step \notin [\bar{s}-1, \bar{s}+1]))$}
                \State $return$ \ //ignore vote
            \EndIf

            \State $V \gets V \cup vt$ \ //observe vote
            \State $\mathsf{Relay}(vt)$

            \If{$vt.step = proposal$}
                \If{$Proposal(vt.v) \in P$}
                    %P*? Que onda el sortition aca?
                    \State $\mathsf{Broadcast}(Proposal(vt.v))$
                \EndIf
            \ElsIf{$vt.step = soft$}
                %check if soft bundle has been achieved
                \If{$\exists v | Bundle(vt.round,vt.period,soft,v) \subset V$}
                    %Try to emit a certification vote
                    \For{$a \in A$}
                        \State $cred \gets 
                        \mathsf{Sortition}(a_{sk}, cert)$
                        \If{$cred.j > 0$}
                            \State $\mathsf{Broadcast}(Vote(a.I, r, p, cert, v, cred))$
                        \EndIf
                    \EndFor
                \EndIf
            \ElsIf{$vt.step = cert$}
                %check if cert bundle has been achieved
                \If{$\exists v | Bundle(vt.round,vt.period,cert,v) \subset V$}
                    \If{$Proposal(v) \notin P$}
                        \State $\mathsf{RequestProposal}(v)$ //waits or keeps playing without voting power
                    \EndIf
                    \State $\mathsf{Commit}(v)$  %ver que pasa si no se pudiera commitear
                    \State $r_{old} \gets r$
                    \State $\mathsf{StartNewRound}(vt.round+1)$
                    \State $\mathsf{GarbageCollect}(r_{old}, p)$
                \EndIf
            \ElsIf{$vt.step > cert$}
                \If{$\exists v | Bundle(vt.round,vt.period,vt.step,v) \subset V$}
                    \State $p_{old} \gets p$
                    \State $\mathsf{StartNewPeriod}(vt.period)$
                    \State $\mathsf{GarbageCollect}(r, p_{old})$
                \EndIf
            \EndIf

        \EndFunction
        \end{algorithmic}
    \end{algorithm}
    
    
    \noindent \textbf{Description:}\\
The vote handler is triggered when a node receives a message containing a vote for a given proposal value, round, period and step.
It first performs a series of checks, and if the received vote passes all of them, then it's broadcast by all accounts selected
as the appropriate committee members.
On line 2, it checks if the vote is valid by itself. If invalid, the node can optionally penalize the sender of the vote
(by disconnecting or blacklisting it, for example).
Equivocation votes on a proposal step are not allowed, so a check for this condition is performed on line 5.
Furthermore, second equivocations are never allowed (line 7).
Any votes for rounds prior to the current round are discarded (line 9).
On the special case that we received a vote for a round immediately after the current round, we observe it only if its a first period,
proposal, soft, cert, late, down or redo vote (discarding votes for further periods or votes for a $next_k$ step).
Finally, the checks on lines 13 to 16 check that, if the vote's round is the currently executing round, and one of:
\begin{itemize}
    \item vote's period is not a distance of one or less away from the node's current period,
    \item vote's period is the next period, but its step is $next_{k}$ with $k \geq 1$,
    \item vote's period is the current period, its step is $next_{k}$ with $k \geq 1$, 
and its step is not within a distance of one away from the currently observed node's step, or
    \item vote's period is one behind the current period, its step is $next_{k}$ with $k \geq 1$, and
its step is not within a distance of one away from the node's last finished step,
\end{itemize}
then the vote is ignored and discarded. \\
Once finished with the series of validation checks, the vote is observed on line 18, relayed on line 19, and then processed.
The node will determine the desired output according to its current context and the vote's step.
If the vote's step is $proposal$, the corresponding proposal for the proposal-value $v$, $Proposal(v)$ is broadcast if it has been observed 
(that is, the player performs a reproposal payload broadcast).
If the vote's step is $soft$ (lines 19 through 24), and a $soft$ Bundle has been observed with the addition of the vote on line 19,
the $Sortition$ subprocedure is run for every account managed by the node (line 23). Afterwards, for each account selected by
the lottery, a $cert$ vote is cast as output (line 25).
If the vote's step is $cert$ (lines 26 through 32), and observing the vote causes the node to observe a $cert$ Bundle for a proposal-value $v$,
then it checks if the full proposal associated to the critical value has been observed (line 28). Note that simultaneous observation of a $cert$ Bundle 
for a value $v$ and of a proposal $e = Proposal(v)$ implies commitability of the associated entry.
Had the full proposal not been observed at this point, the node may stall and request the full proposal from the network.
Once the desired block is commitable, on lines 30:32 the node proceeds to commit, start a new round, and garbage collect all
transient data from the round it just finished.
Finally, if the vote is that of a recovery step (lines 33:36), and a Bundle has been observed for a given proposal-value $v$,
then a new period is started and the currently executing period-specific data garbage collected.



\end{subsection}

% --------------------------------------------------------------------

\begin{subsection}{HandleBundle}\label{ssect:HandleBundle}

    \begin{algorithm}[H]
        \caption{\underline{HandleBundle}}
        label{algo:habdle-bundle}
        \begin{algorithmic}[1]
        \Function{$\mathsf{HandleBundle}$}{$Bundle \ b$}

            % //P*? "Ignores* it if Bundle(r, p, s, v) is invalid." Esta linea esta mal no? en specs. Deberia ser rk, pk, sk

            % //P*? "If there exists a vote which causes the player to observe some bundle Bundle(rk, pk, sk, $v´$) for some sk..."
            % should probably be for some $v´$

            \If{$\neg \mathsf{VerifyBundle}(b)$}
                \State $\mathsf{PenalizePeer}(\mathsf{SENDER\_PEER}(b))$ \ //optional
                \State $\mathsf{return}$
            \EndIf

            \If{$b.r = r \land b.p + 1 \geq p$}
                \For{$vt \in b$}
                    \State $\mathsf{HandleVote}(vt)$
                \EndFor
            \EndIf

            %El relaying del bundle en esta implementación queda implícito, pero como relayeamos cada voto, en teoría si observamos
            %un bundle estamos relay-eando ese bundle voto a voto

        \EndFunction
        \end{algorithmic}
    \end{algorithm}
    
    
    \noindent \textbf{Description:}\\
The bundle handler is invoked whenever a bundle message is received. 
If the received bundle is invalid (line 2), it is immediately discarded. Optionally, the node may
penalize the sending peer (for example, disconnecting from or blacklisting it).
On line 5 a check is performed. If the bundle's round is the node's current round
and it's at most one period behind of the node's current period, 
then the bundle is processed, which is simply calling the vote handler for each 
vote constituting it (lines 6:7). If the check on line 5 is not passed by $b$, no output is produced
and the bundle is ignored and discarded.
Note that handling each vote separately, if a bundle $b\prime = Bundle(b.r, b.p, b.s, v\prime)$ is observed
(where $v\prime$ is not necessarily equal to $b.v$, consider $b$ may contain equivocation votes), then it will be relayed
as each vote was relayed individually, and any output or state changes it produces will be made. All leftover votes 
in $b$ will be processed according to the new state the node is in, e.g. being discarded if $b.r < r$.
    
\end{subsection}

% --------------------------------------------------------------------

\begin{subsection}{Recovery Attempt}
    \label{ssect:Recovery}

    \begin{algorithm}[H]
        \caption{\underline{Recovery}}
        \label{algo:recovery}
        \begin{algorithmic}[1]
        \Function{$\mathsf{Recovery}$}{$uint64 \ k$}

        \State $\mathsf{ResynchronizationAttempt}()$
        \State $s \gets next_k$
    
        \For{$Account \ a \in A$}
            \State $cred \gets 
            \mathsf{\mathsf{Sortition}}(a_{sk}, next_k)$
            \If{$cred.j > 0$}
                \If{$\exists v | \mathsf{IsCommitable}(v)$}
                    \State $\mathsf{Broadcast}(Vote(a.I, r, p, next_k, v, cred))$
                \ElsIf{$\nexists s_0 > cert | Bundle(r, p - 1, s_0, \bot) \subseteq V \wedge$ \newline 
                ${}$ ${\hskip 2.65cm} \exists s_1 > cert | Bundle(r, p - 1, s_1, \bar{v}) \subseteq V$}
                    \State $\mathsf{Broadcast}(Vote(a.I, r, p, next_k, \bar{v}, cred))$
                \Else
                    \State $\mathsf{Broadcast}(Vote(a.I, r, p, next_k, \bot, cred))$
                \EndIf
            \EndIf
        \EndFor
        \EndFunction
        \end{algorithmic}
    \end{algorithm}
    
    
    \noindent \textbf{Description:}\\
The recovery algorithm that is executed periodically every X seconds, 
whenever a $cert$ bundle has not been observed before $\mathsf{FilterTimeout}(p)$ for a given period $p$. \\
On line 2 it starts by making a resynchronization attempt. Then on line 3 the node's step is updated.\\
Afterwards, the node plays for each managed account. For each account that is selected to be a part of the voting committee for the current
step $next_k$, one of three different outputs is produced. \\
If there is a proposal-value $v$ that is commitable in the current context, a $next_k$ vote for $v$ is broadcast by the player. \\
If no proposal-value is commitable, no recovery step Bundle for the empty proposal-value ($\bot$) was observed in the 
previous period, and a recovery step Bundle for the pinned value was observed in the previous period (note that this implies $\bar{v} \neq \bot$),
then a $next_k$ vote for $\bar{v}$ is broadcast by the player. \\
Finally, if none of the above conditions were met, a $next_k$ vote for $\bot$ is broadcast. A player is forbidden
from equivocating in $next$ votes.

\end{subsection}


% --------------------------------------------------------------------
\begin{subsection}{Fast Recovery Attempt}\label{ssect:FastRecovery}

    \begin{algorithm}[H]
        \caption{\underline{FastRecovery}}
        \label{algo:fast-recovery}
        \begin{algorithmic}[1]
        \Function{$FastRecovery$}{}

        %P*? Como se maneja el step number aca? y el bar_step?

        \State $\mathsf{ResynchronizationAttempt}()$
    
        \For{$Account \ a \in A$}
            \If{$\mathsf{IsCommitable}(v)$}
                \State $cred \gets 
                \mathsf{Sortition}(a_{sk}, late)$
                \If{$cred.j > 0$}
                    \State $\mathsf{Broadcast}(Vote(a.I, r, p, late, v, cred))$
                \EndIf

            \ElsIf{$\nexists s_0 > cert | Bundle(r, p - 1, s_0, \bot) \subseteq V \wedge$ \newline 
                ${}$ ${\hskip 2.1cm} \exists s_1 > cert | Bundle(r, p - 1, s_1, \bar{v}) \subseteq V$}
                    \State $cred \gets 
                    \mathsf{Sortition}(a_{sk}, redo)$
                    \If{$cred.j > 0$}
                        \State $\mathsf{Broadcast}(Vote(r,p,redo,\bar{v}, cred))$
                    \EndIf

            \Else
                \State $cred \gets 
                \mathsf{Sortition}(a_{sk}, down)$
                \If{$cred.j > 0$}
                    \State $\mathsf{Broadcast}(Vote(r,p,down,\bot, cred))$
                \EndIf
            \EndIf
        \EndFor

        \EndFunction
        \end{algorithmic}
    \end{algorithm}
    
    
    \noindent \textbf{Description:}\\
    The fast recovery algorithm is executed periodically every integer multiple of $\lambda_f$
    seconds (plus variance).
    Functionally, it's very close to the regular recovery algorithm (outlined in the previous section), 
    performing the same checks and similar outputs. The sole difference is that it emmits votes 
    for any of three different steps ($late$, $redo$ and $down$) according to sortition 
    results for every account.
    It's also important to point out that nodes are forbidden to equivocate for $late$, $redo$ and $down$ votes.
\end{subsection}


% ------------------------------------------------------------------------------------
\end{section}
% ------------------------------------------------------------------------------------
% ------------------------------------------------------------------------------------
\begin{section}{Subroutines}\label{sect:soubroutines}

% ----------------------------------------------------------------------------------------------

\begin{algorithm}[H]
    \caption{\underline{FilterTimeout}}
    \label{algo:filter-timeout}
    \begin{algorithmic}[1]
    \Function{$\mathsf{FilterTimeout}$}{$uint64 \ p$}
        \If{$p = 0$}
            \State $\mathsf{return} \ 2\lambda_0$
        \Else 
            \State $\mathsf{return} \ 2\lambda$
        \EndIf
    \EndFunction
    \end{algorithmic}
\end{algorithm}

\noindent \textbf{Arguments:}
\begin{itemize}
    \item $uint64 \ p$ is a period number
  \end{itemize}

\noindent \textbf{Description:}\\
The function $\mathsf{FilterTimeout}(\;)$\index{$\mathsf{FilterTimeout}(\;)$} provides the timeout 
constant for the filtering (i.e., "soft" or "soft vote") stage.
This timeout depends on the period value; the first period has a special, faster timeout.
If no consensus was achieved, this timeout constant is relaxed in all subsequent periods. 

\noindent \textbf{Returns:}
\begin{itemize}
    \item The time constant used to trigger the filtering stage (according to whether the given
    period $p$ is the first period of the current round or not)
  \end{itemize}

% ----------------------------------------------------------------------------------------------

\begin{algorithm}[H]
    \caption{\underline{General Purpose Hashing Function}}
    \begin{algorithmic}[1]
    \Function{$\mathsf{H}$}{$Hashable \ in$}
        \If{$SHA512/256 \ is \ supported$}
            \State $\mathsf{return SHA512/256}(in)$
        \Else
            \State $\mathsf{return SHA256}(in)$
        \EndIf
    \EndFunction
    \end{algorithmic}
\end{algorithm}

\noindent \textbf{Arguments:}
\begin{itemize}
    \item $Hashable \ in$ = some hashable data (plain bytes)
  \end{itemize}

\noindent \textbf{Description:}\\
General purpose hashing function. If $SHA512/256$ is supported by the underlying system running the node, it's used.
Otherwise falls back to $SHA256$.\\

\noindent \textbf{Returns:}
\begin{itemize}
    \item The result of hashing the input $in$ with the selected algorithm based on underlying system support
  \end{itemize}

% ----------------------------------------------------------------------------------------------

\begin{algorithm}[H]
    \caption{\underline{AssembleBlock}}    
    \label{algo:assemble-block}
    \begin{algorithmic}[1]
    \Function{$\mathsf{AssembleBlock}$}{}

    \State $Block b$
    \State $b.body \gets TP[-s]$

    \EndFunction
    \end{algorithmic}
\end{algorithm}

\noindent \textbf{Description:}\\
Gets a set of transactions out of the transaction pool (prioritizing the highest transaction fee if there were any).
Then, assembles a full ledger entry, setting all the appropriate fields in a block.

% ----------------------------------------------------------------------------------------------

\begin{algorithm}[H]
    \caption{\underline{IsCommitable}}
    \label{algo:is-commitable}
    \begin{algorithmic}[1]
    \Function{$\mathsf{IsCommitable}$}{$Proposal_{value} \ v$}

    \State $\mathsf{return} \ Proposal(v) \in P \land Bundle(r,p,soft,v) \subset V$

    \EndFunction
    \end{algorithmic}
\end{algorithm}


\noindent \textbf{Arguments:}
\begin{itemize}
    \item $Proposal_{value} \ v$, a value to check for commitability
  \end{itemize}

\noindent \textbf{Description:}\\
Checks that the value $v$ is commitable in the current node's context.
To be commitable, the two conditions outlined in line 2 have to be met.
That is, the corresponding proposal that the value refers to has to be
available (have been observed in the current round), and there must
be a valid bundle of soft votes for $v$ observed during the current round and
period. \\

\noindent \textbf{Returns:}
\begin{itemize}
    \item A boolean value indicating commitability of the argument $v$
  \end{itemize}

% ----------------------------------------------------------------------------------------------

\begin{algorithm}[H]
    \begin{algorithmic}[1]
    \Function{$\mathsf{Commit}$}{$Proposal_{value} \ v$}

    \State $L \gets L || Proposal(v)$
    \State $UpdateBT(Proposal(v))$

    \EndFunction
    \end{algorithmic}
    \caption{\underline{Commit}}
\end{algorithm}


\noindent \textbf{Arguments:}
\begin{itemize}
    \item $Proposal_{value} \ v$, a proposal-value to be commited
  \end{itemize}

\noindent \textbf{Description:}\\
Commits the corresponding proposal for the value passed by parameter into the ledger.
As a precondition, the value is commitable (which implies validity and availability of the full
ledger entry and seed).
Afterwards, updates the balance table with all state changes called for in the commited entry.

% ----------------------------------------------------------------------------------------------

\begin{algorithm}[H]\label{algo:verify-vote}
    \begin{algorithmic}[1]
    \Function{$\mathsf{VerifyVote}$}{$Vote \ vt$}
        \State $valid \gets vt.round \leq r+2$
        
        \If{$vt.step = 0$}
            \State $valid \gets valid \land vt.v.p_{orig} \leq vt.period$
            \If{$vt.period = vt.v.p_{orig}$}
                \State $valid \gets valid \land vt.v.I_{orig} = vt.I$
            \EndIf
        \EndIf
        
        \If{$vt.step \in \{propose, soft, cert, late, redo\}$}
            \State $valid \gets valid \land vt.v \neq \bot$
        \ElsIf{$vt.step = down$}
            \State $valid \gets valid \land vt.v = \bot$
        \EndIf


        //TODO: verificacion de firmas, VRFs y rounds de validez

        \State $\mathsf{return} \ valid$
    \EndFunction
    \end{algorithmic}
    \caption{\underline{VerifyVote}}
\end{algorithm}

\noindent \textbf{Description:}\\
Vote verification gets an unauthenticated vote and returns an authenticated vote and a
boolean indicating whether authentication succeeded or failed.


% ----------------------------------------------------------------------------------------------

\begin{algorithm}[H]
    \begin{algorithmic}[1]
    \Function{$\mathsf{Proposal}$}{$Proposal_{value} \ v$}

    \If{$\exists e \in P | Proposal_{value}(e) = v$}
        
    \EndIf

    \EndFunction
    \end{algorithmic}
    \caption{\underline{Proposal}}
\end{algorithm}

\noindent \textbf{Description:}\\ Gets the proposal associated to a given value, if it has been observed.
Otherwise returns undefined. Here we ignore the theoretical possibility of a collision

% ----------------------------------------------------------------------------------------------

\begin{algorithm}[H]\label{proposal-value}
    \begin{algorithmic}[1]
    \Function{$\mathsf{Proposal_{value}}$}{$Proposal \ e$}

    //pack and hash
    \State $proposal_{value} v \gets (I, p, \mathsf{H}(e), \mathsf{H}(Encoding(e)))$

    \State $\mathsf{return} \ v$

    \EndFunction
    \end{algorithmic}
    \caption{\underline{Proposal-value}}
\end{algorithm}

\noindent \textbf{Description:}\\ 

% ----------------------------------------------------------------------------------------------

\begin{algorithm}[H]
    \caption{\underline{VerifyProposal}}
    \label{algo:verify-proposal}
    \begin{algorithmic}[1]
    \Function{$\mathsf{VerifyProposal}$}{$ProposalPayload \ pp$}

    \State $valid \gets \mathsf{ValidEntry}(pp.e, L)$
    \State $valid \gets valid \land \mathsf{VerifySignature}(pp.y)$

    \EndFunction
    \end{algorithmic}
\end{algorithm}

\noindent \textbf{Description:}\\

% ----------------------------------------------------------------------------------------------

\begin{algorithm}[H]\label{algo:verify-bundle}
    \begin{algorithmic}[1]
    \Function{$\mathsf{VerifyBundle}$}{$Bundle \ b$}

    //all individual votes are valid
    \State $valid \gets (\forall vt \in b)(VerifyVote(vt))$
    
    //no two votes are the same
    \State $valid \gets valid \land (\forall i,k \in \mathbb{Z})(vt_i \in b \land vt_k \in b \land vt_i = vt_k \implies i=k)$

    //round, period and step must all match
    \State $valid \gets valid \land (\forall vt \in b)(vt.r = b.r \land vt.p = b.p \land vt.s = b.s)$
  
    %P*? Equivocation vote solo vale para soft bundles. Eso es correcto?
    //all votes should either be for the same value or be equivocation votes
    \State $valid \gets valid \land (\forall vt \in b)(vt.v = b.v \lor (b.s = soft \land IsEquivocation(vt.v, b)))$

    //summation of weights should surpass the relevant threshold
    \State $valid \gets valid \land  \sum_{vt \in b}(vt.w) \geq CommitteeThreshold(b.s)$

    \State $\mathsf{return} \ valid$

    \EndFunction
    \end{algorithmic}
    \caption{\underline{VerifyBundle}}
\end{algorithm}

\noindent \textbf{Description:}\\
Procedure used to verify a received Bundle, through a series 
of checks.
On line 2, it ensures that all individual constituting $b$
are individually valid.
Line 3 checks that the Bundle has no repeat votes.
Line 4 checks that all votes in $b$ match the same $(r,p,s)$
execution context.
Line 5 checks that all votes are towards the same proposal value,
with the exception of equivocation votes which are interpreted as wildcard
towards any proposal value.
%aca: are equiv votes just valid on soft bundles? Preguntar
Finally, on line 6 it checks that the sum of the weight of all constituting
votes is greater or equal to the corresponding committee threshold (otherwise, 
the bundle would not be complete).
After all aformentioned checks have passed, a boolean true value is returned.
If any of them failed, a false value is returned instead, and $b$ is deemed invalid.

% ----------------------------------------------------------------------------------------------

\begin{algorithm}[H]\label{algo:start-new-round}
    \caption{\underline{StartNewRound}}
    \label{algo:start-new-round}
    \begin{algorithmic}[1]
    \Function{$\mathsf{StartNewRound}$}{$uint64 \ newRound$}
    \State $\bar{s} \gets s$
    \State $\bar{v} \gets \bot$
    \State $r \gets newRound$
    \State $p \gets 0$
    \State $s \gets proposal$
    \EndFunction
    \end{algorithmic}
\end{algorithm}

\noindent \textbf{Description:}\\
Procedure used to set all state variables necessary to start a new round.
Last finished step is set to the step where the previous round culminated.
Pinned proposal-value is set to the empty proposal-value as the round is just starting.
The current round number gets updated to the freshly started round.
Period and step number are set to $0$ and $proposal$ respectively.

% ----------------------------------------------------------------------------------------------

\begin{algorithm}[H]\label{algo:start-new-period}
    \begin{algorithmic}[1]
    \Function{$\mathsf{StartNewPeriod}$}{$uint64 \ newPeriod$}

    \State $\bar{s} \gets s$
    \State $s \gets proposal$

    \If{$\exists v,s^\prime \ | \ v \neq \bot \land (s^\prime = soft \lor s^\prime > cert)  
    \land Bundle(r, newPeriod-1, s, v) \subset V$}
        \State $\bar{v} \gets v$
    \ElsIf{$\sigma(r,p) \neq \bot$}
        \State $\bar{v} \gets \sigma(r,p)$
    \EndIf

    \State $p \gets newPeriod$

    \EndFunction
    \end{algorithmic}
    \caption{\underline{StartNewPeriod}}
\end{algorithm}

\noindent \textbf{Description:}\\
Procedure used to set all state variables necessary to start a new period.
Note that we start a new period on observing a recovery bundle for a proposal-value, whether it be
an actual value or the special empty value $\bot$.
On lines 2 and 3, the node sets the last finished step to the currently executing step when a new period's
start was observed, and the current step to $proposal$.
Then it checks for the existence of a non-$cert$ step bundle in the period immediately before the new one (line 4), 
for a proposal-value that's anything but the empty value $\bot$ (note that if the node had observed a $cert$
bundle in the previous period, it would not be starting a new period and it would be instead attempting to commit
the relevant entry and subsequently start a new round). If such bundle for a proposal-value $v$ exists, the pinned 
value is updated to $v$.
Otherwise, and assuming implicitly in this case that the bundle that caused the period switch is of value $\bot$,
a check for the special $\sigma(r,p)$ value is performed on line 6, where $p$ is the period that was being executed 
by the node up until a new period was observed. If $\sigma(r,p)$ is a valid non-empty proposal-value, the pinned 
value $\bar{v}$ is set to this (line 7).
Finally, if none of the above conditions were met, the pinned value remains unchanged going into the new period.
Finally, the node updates $p$ to match the period to start.

% ----------------------------------------------------------------------------------------------

\begin{algorithm}[H]\label{algo:garbage-collect}
    \begin{algorithmic}[1]
    \Function{$\mathsf{GarbageCollect}$}{$r, p$}

    \State $V_{(r,p-1)} \gets \{ vt \in V | vt.r < r \lor (vt.r=r \land vt.p + 1 < p) \}$
    \State $P_{(r,p-1)} \gets \{ pp \in P | pp.r < r \lor (pp.r=r \land pp.p + 1 < p) \}$

    \State $V \gets V\diagdown V_{(r,p-1)}$
    \State $P \gets P\diagdown P_{(r,p-1)}$

    \EndFunction
    \end{algorithmic}
    \caption{\underline{GarbageCollect}}
\end{algorithm}

\noindent \textbf{Description:}\\
Garbage collection algorithm, for the finished $(r,p)\in\mathbb{Z}_{\ge 0}^2$ context.
The procedure discards all votes in $V$ and proposals in $P$ where the round of emission is less than the
new round, or the round of emission is equal to the new round and the period of emission is below the period
directly before the current one.

% ----------------------------------------------------------------------------------------------

\begin{algorithm}[H]\label{algo:request-proposal}
    \begin{algorithmic}[1]
    \Function{$\mathsf{RequestProposal}$}{$Proposal_{value} \ v$}
        //ver como hacer el request...como lo resuelve el nodo?
    \EndFunction
    \end{algorithmic}
    \caption{\underline{RequestProposal}}
\end{algorithm}

\noindent \textbf{Description:}\\
%The Ledger.Wait function (and its variants) seem to be used to wait for the block
% https://github.com/algorand/go-algorand/blob/51f5314422b568526d09fdb74c4c87cfaaa0b4e2/ledger/ledger.go#L747

% ----------------------------------------------------------------------------------------------

\begin{algorithm}[H]\label{algo:penalize-peer}
    \begin{algorithmic}[1]
    \Function{$\mathsf{PenalizePeer}$}{$PEER\_NETWORK\_ID$}
        //ver como resuelve el nodo la desconexion o blacklist de un peer
    \EndFunction
    \end{algorithmic}
    \caption{\underline{PenalizePeer}}
\end{algorithm}

\noindent \textbf{Description:}\\
%Encontre en el codigo un key-value map donde podes asignar valores a peers a nivel network, pero
%tengo que ver mejor para convencerme de si es ahi donde se resuelve esto

% ----------------------------------------------------------------------------------------------

\begin{algorithm}[H]\label{algo:resynchronization-attempt}
    \begin{algorithmic}[1]
    \Function{$\mathsf{ResynchronizationAttempt}$}{}

    %P*? Sortition aca? deberia correrlo? no es claro como funcionaria aca

    \State $Val = \bot$

    \If{$\exists v | Bundle(r, p, soft, v) \subset V$}
        \State $\mathsf{Broadcast}(Bundle(r, p, soft, v))$
        \State $val = v$    
    \ElsIf{$\exists s_0 > cert | Bundle(r, p - 1, s_0, \bot) \subset V$}
        \State $\mathsf{Broadcast}(Bundle(r, p - 1, s_0, \bot))$
    \ElsIf{$\exists s_0, v | s_0 > cert \land v \neq \bot \land Bundle(r, p - 1, s_0, v) \subset V$}
        \State $\mathsf{Broadcast}(Bundle(r, p, s_0, v))$
        \State $val = v$
    \EndIf

    \If{$val \neq \bot \land Proposal(v) \in P$}
        \State $\mathsf{Broadcast}(Proposal(v))$
    \EndIf

    \EndFunction
    \end{algorithmic}
    \caption{\underline{ResynchronizationAttempt}}
\end{algorithm}

\noindent \textbf{Description:}\\
A resynchronization attempt, performed at the start of all recovery algorithms.
If a soft bundle has been observed for a proposal-value $v$, then the bundle is broadcast.
Otherwise, if a recovery step bundle for an empty proposal-value $\bot$ was observed in the previous period,
It's broadcast.
Else, if there is a recovery step $s_0$ and a non-empty proposal-value $v$ for which a bundle was observed in the previous
period, it's broadcast.
Finally, if any Bundles were broadcast for a proposal-value $v$, the corresponding proposal $Proposal(v)$ is broadcast
if it has been observed.

% ----------------------------------------------------------------------------------------------

\begin{algorithm}[H]\label{algo:compute-seed}
    \begin{algorithmic}[1]
    \Function{$ComputeSeed$}{$b$}
        \If{$B \neq empty\_block$} 
            \State $\mathsf{return} \ VRF_{get_{SK_a}(ctx, r)}(ctx.LastBlock.seed||r$)
        \Else
            \State $\mathsf{return} \ \mathsf{Hash}(ctx.LastBlock.seed||r)$
        \EndIf
    \EndFunction
    \end{algorithmic}
    \caption{\underline{ComputeSeed}}
\end{algorithm}


\noindent \textbf{Arguments:}
\begin{itemize}
    \item $b$ = the block whose seed is being computed
  \end{itemize}


\noindent \textbf{Description:}\\
This subroutine computes the required sortition seed for the given round number, 
which goes in the proposed block's metadata.
If the block is empty, the seed is a hash of the previous block's seed.
The $get_{SK_a}(ctx, r)$ helper function gets the relevant account's secret ephemeral keys (according to the signing scheme described in specs, the keys 160 rounds prior to $r$).
This roughly corresponds to the secret key from a round $b$ time before block $r-1-(r\;mod\;R)$, where $R$ is the sortition seed's renewal rate, $r$ is the current round's number,
and $b$ is the upper bound for the maximum ammount of time that the network might be compromised.\\

\noindent \textbf{Returns:}
\begin{itemize}
    \item the computed seed for the given block, ledger context and round
  \end{itemize}

% ----------------------------------------------------------------------------------------------

\begin{algorithm}[H]\label{algo:get-sortition-seed}
    \begin{algorithmic}[1]
        \Function{$getSortitionSeed$}{$ctx, r, a_{pk}$}
        
            $\Return\;ctx.block[r-1-(r\;mod\;R)].seed$

        \EndFunction
    \end{algorithmic}
    \caption{\underline{getSortitionSeed}}
\end{algorithm}

\noindent \textbf{Arguments:}
\begin{itemize}
    \item $ctx$ = a helper structure to retrieve ledger context information (e.g. the last confirmed block)
    \item $round$ = current round number
    \item $a_{pk}$ = the account's public key for the look up table
  \end{itemize}


\noindent \textbf{Description:}\\
This helper function gets the relevant sortition seed for the current round $r$, according to the seed lookback parameter $R$.
Conceptually, it corresponds with the seed computed $R$ rounds prior to $r$, refreshed every $R$ rounds.

\noindent \textbf{Returns:}
\begin{itemize}
    \item a sortition seed to be used in the round $r$
  \end{itemize}

% ----------------------------------------------------------------------------------------------

\begin{algorithm}[H]\label{algo:get-sortition-weight}
    \begin{algorithmic}[1]
        \Function{$getSortition_w$}{$ctx, round, a_{pk}$}

            $\Return\;ctx.balanceTable[r - (R + SL)][a_{pk}]$

        \EndFunction
    \end{algorithmic}
    \caption{\underline{getSortitionWeight}}
\end{algorithm}

\noindent \textbf{Arguments:}
\begin{itemize}
    \item $ctx$ = a helper structure to retrieve ledger context information (e.g. the last confirmed block)
    \item $r$ = current round number
    \item $a_{pk}$ = the account's public key for the look up table
  \end{itemize}


\noindent \textbf{Description:}\\
This helper function retrieves the stake $R + SL$ rounds prior to $r$, for an account
with public key $a_{pk}$

\noindent \textbf{Returns:}
\begin{itemize}
    \item the relevant account's stake
  \end{itemize}


% ----------------------------------------------------------------------------------------------


\begin{algorithm}[H]\label{algo:get-sortition-W}
    \begin{algorithmic}[1]
        \Function{$getSortition_W$}{$ctx, r$}
        
        $\Return \sum_{a_{pk}\;\in\;ctx.balanceTable[r - (R + SL)]}{balanceTable[r - (R + SL)][a_{pk}]}$

        \EndFunction
    \end{algorithmic}
    \caption{\underline{getSortitionTotalStake}}
\end{algorithm}

\noindent \textbf{Arguments:}
\begin{itemize}
    \item $ctx$ = a helper structure to retrieve ledger context information (e.g. the last confirmed block)
    \item $r$ = current round number
  \end{itemize}


\noindent \textbf{Description:}\\
This helper function returns the sum of all stake for $R + SL$ rounds prior to $r$.

\noindent \textbf{Returns:}
\begin{itemize}
    \item the total stake at play in the relevant round (according to lookback parameters)
  \end{itemize}

% ----------------------------------------------------------------------------------------------

\begin{algorithm}[H]
    \caption{Sortition}
    \label{algo:sortition}
    \begin{algorithmic}[1]
    \Function{$\mathsf{Sortition}$}{$Account \ a, uint64 \ step$}
        \State $seed \gets L[r - \delta_s].seed$
        //ACLARAR QUE ESTE BALANCE ES EL DEL LOOKBACK (NO EL ACTUAL)
        \State $w \gets a.balance$ //$BT[a.address][r-\delta_s-\delta_b].balance$
        \State $W \gets \sum_{a \in A_{r-\delta_s-\delta_b}}a.balance$
        \State $\tau \gets \mathsf{CommitteeThreshold}(p)$
        \State $ \langle hash, \pi \rangle \gets \mathsf{VRF_{a_{sk}}}(seed||step)$
        \State $t \gets \frac{\tau}{W}$
        \State $j \gets 0$
        \While{$\frac{hash}{2^{hashlen}}\notin [ \sum_{k=0}^j\mathsf{B}(k;w,t), \sum_{k=0}^{j+1}\mathsf{B}(k;w,t))$}
            \State $j \gets j+1$
        \EndWhile
        \Return $credentials(hash, \pi, j)$
    \EndFunction
    \end{algorithmic}
    \caption{\underline{Sortition}}
\end{algorithm}


\noindent \textbf{Arguments:}
\begin{itemize}
    \item $Account \ a$, an online account's balance table record
    \item $uint64 \ step$, the step to run sortition for
\end{itemize}

%A_0,..., A_algo are the committee members.... que es eso?
\noindent \textbf{Description:}\\
The Sortition procedure is one of the most important subroutines in the main algorithm, as it is 
used in multiple stages and contexts.
Generally, it manages to pseudo-randomly but verifiably (through the use of a Verifiable Random 
Function) select a user with probability proportional
to their weight (i.e., stake) by returning a $j$ parameter, which indicates the number of times that 
specific user was chosen.
Algorithmically, every monetary unit the user has is considered a ``sub-user'', and then each one 
of them is selected with probability $p = \frac{\tau}{W}$,
where $\tau$ is the expected amount of users to be selected for the given role, and $W$ is the total
stake online for the relevant round.
The semi-open interval $[0,1)$ is then split into consecutive intervals using an accumulated 
binomial distribution, and wherever the fraction $\frac{hash}{2^{hashlen}}$
belongs to the interval, that's the amount of chosen sub-users for the subroutine caller.\\

\noindent \textbf{Returns:}
\begin{itemize}
    \item an object of type $credentials$, containing the sortition hash and proof (output of VRF
    computation) and an unsigned integer $j$ representing the weight that player has in the committee,
    for the desired round, period and step.
  \end{itemize}

% ----------------------------------------------------------------------------------------------


\begin{algorithm}[H]
    \begin{algorithmic}[1]
    \Function{$\mathsf{VerifySortition}$}{$pk, seed, \tau, round, period, step, w, W$}
        \IfThen{$\neg \mathsf{VerifyVRF}_{pk}(hash, \pi, seed||round||period||step)$}{$\mathsf{return} \ 0$}
        \State $p \gets \frac{t}{W}$
        \State $j \gets 0$
        \While{$\frac{hash}{2^{hashlen}} \notin [\sum_{k=0}^j\mathsf{B}(k;w,p), \sum_{k=0}^{j+1}\mathsf{B}(k;w,p))$}
            \State $j++$
        \EndWhile
        \Return $j$
    \EndFunction
    \end{algorithmic}
    \caption{\underline{VerifySortition}}
\end{algorithm}

\noindent \textbf{Arguments:}
\begin{itemize}
    \item $pk$ = a user's public key (their address)
    \item $seed$ = the sortition seed to be used
    \item $\tau$ = the expected committee size for the given role
    \item $role$ = a flag specifying the role for the sortition to take place (e.g. block proposer)
    \item $w$ = the user's weight (i.e., its relevant stake)
    \item $W$ = the total relevant stake for the given round
  \end{itemize}

\noindent \textbf{Description:}\\
The sortition verification procedure takes Sortition's output and utilizes 
VRF properties to verify the validity of said output.
Once the check is passed, it repeats Sortition's sub-user selection procedure, 
and outputs the amount of times the user was chosen according to their respective 
observed stake.\\

\noindent \textbf{Returns:}
\begin{itemize}
    \item an integer $j$ that will be positive (larger than 0) if the user has been 
    selected, and it's size corresponds to the amount
    of sub-users for a given committee member
  \end{itemize}


\end{section}
% ----------------------------------------------------------------------------------------------
% \section*{Appendix: Notation}
\begin{section}{Appendix: Notation}


\begin{itemize}
    \item $credentials$, a data structure containing the results of running the sortition algorithm 
    for a specified account
    \item $sh$, the 64-byte sortition hash output by running $VRF_{a_{sk}}$ algorithm over a desired input.
    Usually wrapped inside a $credentials$ structure.
    \item $\pi$, the 32-byte sortition proof output by running $VRF_{a_{sk}}$ algorithm over a desired input.
    Usually wrapped inside a $credentials$ structure.
    \item $j$, an unsigned 64-bit integer, representing the weight of a given account's vote inside a specific committee
    (for a given round, period and step).
    Usually wrapped inside a $credentials$ structure.
    \item $\lambda_0$, time interval for the node to accept block proposals (when $p=0$), after which it 
    chooses the observed block with the highest priority (lowest hash).
    \item $\lambda$, same as $\lambda_0$ but for $p > 0$.
    \item $\delta_s$, sortition seed renewal rate, in number of rounds. Set to $2$ in 
    \href{https://github.com/algorandfoundation/specs}{specs.} as of July 2023.
    \item $\delta_b$, balance lookback interval, in number of rounds. Set to $320$ in 
    \href{https://github.com/algorandfoundation/specs}{specs.}

    % \item Public keys $a_{pk}$ for every account linked to the node (doubles as their respective addresses)
    % \item Public participation keys $a_{p\_partkey}$ for all accounts registered as online (private participation keys are kept
    % securely by respective users and should not be directly accesible by the node)
    % \item Two levels of ephemeral keys, signed according to the signing scheme described in \href{https://github.com/algorandfoundation/specs}{specs.} (where 
    % first level keys are signed with the participation keys, and second level (aka. leaf) ephemeral keys are signed with 
    % first level ephemeral keys). 
    % These keys are used for actual participation in the consensus (abstracted as $a_{sk}$ in the following code)
    % They are ephemeral because they live for a single round, after which they are deleted
    % \item A balance table $BT$ for all accounts linked to the node, for the round $SL + R$ rounds before the one 
    % currently running
\end{itemize}

\end{section}


%makeCredential: Makes unauthenticated credential (aka. calls VRF using secrets.Prove(sel)).
%https://github.com/algorand/go-algorand/blob/f155addc1c522d1464bca71da9af495ed71ce820/data/committee/credential.go#L125
%The selector contains Seed, round, period, step, in a hashable struct
%Prove(hashable h) outputs a VRF proof 
%then Verify() https://github.com/algorand/go-algorand/blob/master/data/committee/credential.go#L75
%is called to obtain weight and VRF hash. In order to decorrelate accounts that might have the same VRF keypair,
%the VRFHash is computed as H(VRFOutputHash || AccountAddress)

% ----------------------------------------------------------------------------------------------

\bibliographystyle{alpha}
\bibliography{bibliography}

% ----------------------------------------------------------------------------------------------
\printindex
\end{document}