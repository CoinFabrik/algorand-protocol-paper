\documentclass[10pt,a4paper]{article}
\usepackage[utf8]{inputenc} % para poder usar tildes en archivos UTF-8
\usepackage{babel} % para que comandos como \today den el resultado en Ingles
\usepackage{a4wide} % márgenes un poco más anchos que lo usual

\usepackage{hyperref}


%\usepackage{caratula}
% \usepackage[left=3cm,right=3cm,bottom=3cm,top=3cm]{geometry}

\usepackage{float}

% Comandos para simbolos matematicos.
\usepackage{amsmath, amssymb}%, tabularx}

% Comandos para referencias
%\usepackage{natbib}

% Comandos para Figuras, Graficos, Tikz etc.
% \usepackage{tikz}
% \usepackage{epsfig}
% \usepackage{pgfplots}
% \usepackage{graphicx}
% \usepackage{epsfig}
% \usepackage{caption}
% \usepackage{subcaption}
% \usepackage{svg}
% \setsvg{inkscape=inkscape -z -D}

% Comandos para teoremas etc.
%\usepackage{amsthm}
% \newtheorem{theorem}{Teorema}
% \newtheorem{lemma}[theorem]{Lema}
% \newtheorem{proposition}[theorem]{Proposición}
% \newtheorem{remark}{Observación}
% \newtheorem{corollary}{Corolario}
% \newproof{proof}{Demostración}

% Comandos para algoritmos.
\usepackage[noend]{algpseudocode}
\usepackage{algorithm}
\algnewcommand{\IfThenElse}[3]{% \IfThenElse{<if>}{<then>}{<else>}
    \State \algorithmicif\ #1\ 
    \algorithmicthen\ #2\ 
    \algorithmicelse\ #3}
\algnewcommand{\IfThen}[2]{% \IfThenElse{<if>}{<then>}
    \State \algorithmicif\ #1\ \algorithmicthen\ #2}
%\pgfplotsset{compat=1.16}


\usepackage{marginnote}

\author{Argimiro, CoinFabrik}
\title{Algorand Protocol Description}

\begin{document}
\maketitle
\tableofcontents

% ---------------------------------------------------------------------------------------
\begin{section}{Introduction}
We aim to describe how the Algorand protocol works. 
This document is meant to reflect how the Algorand mainnet is behaving
today. We relied on Algorand's documents (\cite{DBLP:conf/sosp/GiladHMVZ17},
\cite{DBLP:journals/corr/Micali16} and 
\href{https://github.com/algorandfoundation/specs}{Algorand's official specifications})
but consulted the node's code and probed the network when information was unclear or 
unavailable.

Algorand is a proof-of-stake blockchain cryptocurrency protocol 
using a decentralized Byzantine Agreement protocol that leverages 
pure proof of stake for concensus. The protocol maintains a ledger
that is modified via consensus. In particular, this ledger encodes
how many ALGOs (the native token) holds each account.
Blocks encode the status of the ledger. Starting on the genesis
block (round 0) that encodes the first state of the network, 
on each round the participation nodes vote on what will the next
block be. Their voting power is proportional to the stake (in ALGOs) 
held by the accounts assoicated to the node.

At the genesis of the Algorand blockchain, 10Bn ALGO was minted. 
As of September 2022, circulating supply is approximately 6.9b ALGO, 
distributed through different forms of ecosystem support and 
community incentives. 
The remaining Algos are held by the Foundation in secure wallets 
assigned to 
Community and Governance Rewards (\%53), 
Ecosystem Support (\%36), and 
Foundation endowment (\%11).

A network is formed with two kind of nodes: relay and participation 
nodes. Participation nodes can connect only to relay nodes. 
They listen to one or more participation nodes and they may 
send a message to a relay node. Relay nodes simply listen to participation
nodes connected to them and relay the messages they receive.\marginpar{Explain 
how the network is formed}

In the following document we present a detailed pseudocode interpretation 
of the program run by an Algorand node with at least one online (i.e., 
participating) account. We attempt to explain the 5 main stages of the 
code supporting the protocol in a clear and concise way.
This work aims to provide a basis for an Algorand blockchain simulator 
currently in development. 


\end{section}
% ------------------------------------------------------------------------
\begin{section}{Main algorithm}

Assume right now that a given node is fixed, we are at round $r$,
this node has access to a set of accounts $a\in A$. 
Moreover, the account owner has computed for each round a round 
leaf ephemeral key $a_{sk}$. Assume also the node has access to contextual
information about the ledger state, that being the current last confirmed block,
the last $n > 322$ confirmed blocks, balance and ephemeral keys of all 
online accounts in that interval of rounds. For the sake of clarity and readability, 
we abstract access to that data through a context structure ($ctx$ in code), accesible
at all times by the node.
The main algorithm goes over the following stages on every round.
\begin{itemize}
    \item {\bf block creation:} the node assembles a block with a set of
        transactions and metadata.
    \item {\bf block proposal:} the node runs the Verifiable Random Function 
        (VRF for short) algorithm to decide whether it should participate in 
        the next stage. If it gets selected, then it is sends the block proposal 
        to the other nodes together with the result of the VRF run.
    \item {\bf soft vote:} the node undergos two rounds of voting to 
        reduce all posible block options to a dicotomy: either a block 
        proposed by a chosen online network user or an empty block.
        \marginpar{With this description the next round is superfluous}
    \item {\bf certify vote:} the node undergoes a series of $n$ voting rounds
        ($253 \geq n \geq 1$) to certify either the block received by the 
        prior stage or an empty block. If $n = 1$, the consensus is said 
        to be FINAL. Otherwise, the consensus will be TENTATIVE.
    \item {\bf block confirmation:} the block chosen in the certification 
        stage is added to the ledger, as FINAL or TENTATIVE depending on 
        the amount of users observing it as either (as defined by the 
        threshold parameters for each kind of consensus).\marginpar{What is 
        the effect of a block being tentative?}
\end{itemize} 

The following algorithm outlines the process of running a round for a given node:

\begin{algorithm}[H]
    \begin{algorithmic}[1]
    \Function{$\mathsf{NodeMain}()$}{}
    
    \State $asmBlock \gets \mathsf{BlockCreation}(transactionPool)$
    \State $propBlockHash \gets \mathsf{BlockProposal}(asmBlock, r, accounts\;A)$
    \State $SVBlockHash \gets \mathsf{SoftVote}(propBlockHash)$
    \State $CVBlockHash \gets \mathsf{CertifyVote}(SVBlockHash)$
    \State $\mathsf{BlockConfirmation}(CVBlockHash)$

    \EndFunction
    \end{algorithmic}
    \caption{\underline{Main node algorithm}}
\end{algorithm}

It starts by assembling the block, going through the proposal process,
running both voting stages, and by the time it finishes either a block has been
confirmed and added to the ledger (as TENTATIVE or FINAL), or it gets stuck awaiting for
the recovery protocol to be started by the network.



\begin{subsection}{Notions and Notations}


%  $R$ = sortition seed renewal rate (in number of rounds). 
%     Set to 2 in the \href{https://github.com/algorandfoundation/specs}{specs.}
%     as of December 2022
%     \item $MAX\_STEPS$ = maximum number of allowed steps in the main algorithm. Defined 
%     as 255 in the \href{https://github.com/algorandfoundation/specs}{specs.}
%     \item $\tau_{step}$ = expected number of members on a regular step committee
%     \item $\tau_{final}$ = expected number of members on a final consensus achieving committee
%     \item $T_{step}$ = fraction of expected members for a voting committee on a given step
%     \item $T_{final}$ = fraction of expected members for a voting committee on the final step (step = 2). 
%     If observed, achieves final consensus on the given block hash
%     \item $\lambda_{proposal}$ = time interval for the node to accept block proposals, after
%     which it chooses the observed block with the highest priority (lowest hash) 
%     \item $\lambda_{block}$ = waiting time for the full block to be received once decided by vote.
%     If no full block is received, the node falls back to the empty block.
%     \item $SL$ = the account balances lookback interval, in number of rounds (integer). 
%     Set to 320 in \href{https://github.com/algorandfoundation/specs}{specs.}

    

% On top of that, each node may run in favour of different accounts. To do this,
% it needs the following parameters. 
% Let $A=\{a\}$ be a collection of accounts $a$.\\ \\
% \noindent \textbf{Account parameters}:
%     \item Public keys $a_{pk}$ for every account linked to the node (doubles as their respective addresses)
%     \item Public participation keys $a_{p\_partkey}$ for all accounts registered as online (private participation keys are kept
%     securely by respective users and should not be directly accesible by the node)
%     \item Two levels of ephemeral keys, signed according to the signing scheme described in \href{https://github.com/algorandfoundation/specs}{specs.} (where 
%     first level keys are signed with the participation keys, and second level (aka. leaf) ephemeral keys are signed with 
%     first level ephemeral keys). 
%     These keys are used for actual participation in the consensus (abstracted as $a_{sk}$ in the following code)
%     They are ephemeral because they live for a single round, after which they are deleted
%     \item A balance table $BalanceTable$ for all accounts linked to the node, for the round $SL + R$ rounds before the one 
%     currently running

\end{subsection}

% --------------------------------------------------------------------
\begin{subsection}{Block Creation}\label{ssect:blockcreation}

\begin{algorithm}
    \begin{algorithmic}[1]
    \Function{$\mathsf{BlockCreation}$}{$transactionPool$}
    \State Pick transactions from transactionPool
    \State \Return $\mathrm{Block}$    
    \EndFunction
    \end{algorithmic}
    \caption{\underline{Block creation}}
\end{algorithm}

\noindent \textbf{Arguments:}
\begin{itemize}
    \item The local pending transaction pool, which should be accesible to the node\\
  \end{itemize}

\noindent \textbf{Description:}\\
After confirming a block (and before the genesis block is confirmed) nodes listen to 
transactions that are sent to the {\tt algod REST API} and relay these transactions\marginpar{How does the Algorand client send transactions
to the transaction pool?}. 
At one point, the participation node starts assembling a block.
The Algorand protocol specs (\cite{DBLP:conf/sosp/GiladHMVZ17}) do not ensure 
a specific way or internal order in which transactions are added to the block.
%In fact, they don't force transactions to be added at all, being entirely possible 
%for a node to propose an empty block.
The node will validate the signature and execute the transactions in the Algorand
Virtual Machine (AVM for short) \marginpar{How does this work? Do accounts need to hold
ALGO? So the genesis block already assigned some ALGOs to some accounts without any
block-recorded transaction, right?}
Most of the block metadata is added in this stage, with the exception of the seed
which is computed during the block proposal stage (\ref{ssect:blockproposal}).
Notwithstanding, the official node implementation follows one (undocumented)
algorithm, yet when a node sends a proposal, the official node implementation
does not check the order of the transactions or whether a particular transaction
has been included.

\medskip
\noindent \textbf{Returns:} \newline
A full block, consisting in a variable number of transactions\marginpar{the block 
holds the state, right? not the transactions executied alone}, 
and the following metadata.
\begin{itemize}
    \item A round number, $r$.
    \item The genesis identifier. That is, an ID that identifies univocally the 
        genesis block for this blockchain. For example, Mainnet and Testnet will
        have different genesis identifiers.
    \item upgrade vote.
    \item A timestamp specifying when was the block created.
    \item seed\marginpar{pero como se calcula cada uno de estos bichos?}
    \item reward updates
    \item crytographic commitment to transaction sequence\marginpar{what is this?}
    \item crytographic commitment to txn sequence SHA256.
    \item previous block hash\marginpar{how are these computed?}.
    \item txn counter.
    \item newly expired participation keys.\marginpar{are these also voted?
    who gets to decide which keys expire and how}
  \end{itemize}

\end{subsection}
% --------------------------------------------------------------------
\begin{subsection}{Block Proposal}\label{ssect:blockproposal}

\begin{algorithm}
    \begin{algorithmic}[1]
    \Function{$BlockProposal$}{$Block$ $B$, $r$, $Accounts$ $A$}
        \State $ProposalMsgsSent = \{\}$ //Set of proposal messages sent by this node

        \For{$a \in A$}
            \State $\langle sorthash, \pi, j\rangle\gets 
            \mathsf{Sortition}(
                a_{sk}, 
                \mathsf{getSortitionSeed}(ctx, r), 
                t, 
                role, $ \newline
                ${}$ ${\hskip 5.2cm}\mathsf{getSortition}_w(ctx, r, a_{pk}), 
                \mathsf{getSortition_W}(ctx, r)
            )$
            \If{$j > 0$}
                \State $priority \gets \min\{\mathsf{Hash}(sorthash || n):1\le n\le j\}$

                \State $msg \gets \mathsf{MSG}(a.pk, \mathsf{Signed}_{a.sk}(priority, \langle sorthash, \pi\rangle))$
                \State $ProposalMsgsSent \gets  ProposalMsgsSent\;\cup\;msg$
                \State $\mathsf{GOSSIP\_MSG}(a.pk, Signed{a.sk}(priority, \langle sorthash, \pi\rangle))$
            \EndIf
        \EndFor \\

        \While{$elapsed\;time < \lambda_{proposal}$}
            \State $incomingMsgs.push(listen())$
        \EndWhile

        \State $msgs \gets incomingMsgs[r, step=0]$

        \State $lowestHashMsg \gets m \| m.priority = \min \{m.priority \in incomingMsgs : \forall m \text{ s.t. } $\newline
        ${}$ {\hskip 3cm}  $\mathsf{verifySortition}(m.sorthash, m.pi, m.pk) \& \mathsf{ValidateMsg}(m) \}$ \\

        \State $FullBlockToPropose \gets empty\_block(r)$ 

        \If{$lowestHashMsg \in msgsSent$}
            \State $FullBlockToPropose \gets B$
            \State $FullBlockToPropose.seed \gets \mathsf{ComputeSeed}(ctx, r, B)$
            \State $\mathsf{GOSSIP\_MSG}(a_{pk}, \mathsf{Signed}_{a_{sk}}(B, \langle sorthash, \pi \rangle))$
        \Else
        {
            \While{$elapsed\;time < \lambda_{block}$}
                \State $incomingMsgs.push(listen())$
                \State $m \gets incomingMsgs.back()$
                \If{$\mathsf{ValidateMsg}(m) \& lowestHashMsg.blockHash=\mathsf{Hash}(m.FullBlock)$}
                    \State $FullBlockToPropose \gets m.FullBlock$
                \EndIf
            \EndWhile \\
        }
        \EndIf
        \Return $H(FullBlockToPropose)$
    \EndFunction
    \end{algorithmic}
    \caption{\underline{Block proposal}}
\end{algorithm}

\newpage
\noindent{\bf Arguments:}
\begin{itemize}
    \item A block $B$ received from the previous stage.
    \item The number of round currently executing, $r$.
    \item A list of online accounts  $A=\{a\}$ associated with this node.
    \item ephemeral keys.
    \item public keys associated to these accounts.
  \end{itemize}
\noindent \textbf{Description:}\\
The {\bf block proposal} stage (step 0 on \href{https://github.com/algorandfoundation/specs}{specs.}) is the first stage of the 
consensus algorithm. 
First, the node loops through all their online accounts ($a\in A$), 
running the sortition subroutine ($\mathsf{sortition}()$).
Functions  $\mathsf{Sortition}(), \mathsf{getSortitionSeed}(), \mathsf{sortition_w}()$ and
$\mathsf{sortition_W}()$ described in Section \ref{sect:soubroutines}.
The sortition subroutine determines if an account $a$ is selected to 
${sorthash}$, a proof of the sortition $\pi$, and an integer $j\ge 0$
that is used to prioritize votes.

If $j>0$ then the address $a$ gets to vote and proceeds as follows.
For this account $a$ and this triplet $\langle sorthash, \pi, j\rangle$
it computes the hashes $\{ \mathsf{Hash}(sorthash \| n):1\le n\le j\}$
and keeps the minimum (line 6), which we set as the $priority$ of this
account for this round (here $\mathsf{Hash}()$ is a cryptographic hash
function, assumed to be a random oracle).
The $\mathsf{GOSSIP\_MSG}()$ call which happens next, gossips (broadcasts) 
the priority, sortition hash and proof to other nodes.
It further includes the public key $a_{pk}$ for the account $a$ and the
signature of the triplet $(priority, \langle sorthash, \pi\rangle)$ with the 
leaf ephemeral key associated with the account $a$ and the round $r$.

In the lines 11 to 15, the algorithm accepts block proposals (in the same 
format as gossiped) from other accounts until $\lambda_{proposal}$ is reached.
For each block proposal received it only keeps the one with the lowest 
priority validating the block before accepting it as a possible proposal.

To validate a block proposal, the node verifies the sortition proof and hash
(utilizing the $\mathsf{verifySortition}()$ function).
If the vote message was invalid, the node can decide to flag the proposing user
as malicious and choose to ignore any further messages received from that public address.

Finally, in lines 16-25, the algorithm will select a block as 
follows. Assume the elapsed time has been reached. 
If the selected proposal came from this node, the seed is computed 
calling $\mathsf{ComputeSeed}()$ from the input block $B$, the context helper structure 
$ctx$ and the round number $r$, and the complete block is gossiped to the network.

However, if the proposal did not come from this node, then the node 
waits until $\lambda_{block}$ to receive the full block from other nodes
in the network.
In case of timeout in this last stage, it falls back to the empty block.

\bigskip
\noindent \textbf{Returns:}
\begin{itemize}
    \item The hash of a full block $BlockHash$, whether a block proposed by a user (including users 
    whose accounts are linked to this node) or an empty block in any of the special 
    cases mentioned above. It contains all transactions and metadata added in block creation (\ref{ssect:blockcreation}), 
    as well as the computed seed.
  \end{itemize}
\end{subsection}
% ---------------------------------------------------------------------------------------------------
\begin{subsection}{Soft Vote}\label{ssect:softvote}
The soft vote stage (step 1, called reduction in \cite{DBLP:conf/sosp/GiladHMVZ17}) aims to reduce 
any amount of potentially conflicting proposed blocks in the stage prior into a binary 
choice, either a block proposed by a user or an empty one.

\begin{algorithm}[H]
    \begin{algorithmic}[H]
    \Function{$SoftVote$}{$BlockHash$}
    \State $state \gets 1$
    
    \State $\mathsf{CommitteeVote}(ctx, r, step, \tau_{step}, BlockHash)$
    \State $hblock \gets \mathsf{CountVotes}(ctx, r, step, T_{step}, \tau_{step}, \lambda_{block} + \lambda_{step})$

    \State $empty\_hash \gets \mathsf{Hash}(Empty(r, \mathsf{Hash}(ctx.last\_block)))$ 
    \If{$hblock = TIMEOUT$}
        \State $\mathsf{CommitteeVote}(ctx, r, step, \tau_{step}, empty\_hash)$
    \Else
        {\State $\mathsf{CommitteeVote}(ctx, r, step, \tau_{step}, hblock)$}
    \EndIf\

    \State $hblock \gets \mathsf{CountVotes}(ctx, r, step, T_{step}, \tau_{step}, \lambda_{step})$ 

    \IfThenElse{$hblock = TIMEOUT$}
        {$\Return\; empty\_hash$}
        {$\Return\; hblock$}
    \EndFunction
    \end{algorithmic}
    \caption{\underline{Soft Vote}}
\end{algorithm}

\noindent \textbf{Arguments:}
\begin{itemize}
    \item A block hash, $BlockHash$, received from the previous stage (Sect \ref{ssect:blockproposal}).
  \end{itemize}

\noindent \textbf{Description:}\\
In the first step and with the input block $block\; hash$ as input, together
with other parameters, the node does a preliminary vote count (with $\mathsf{CommitteeVote}()$) and counts votes 
after $\lambda$ seconds have passed using the subroutine $\mathsf{CountVotes}()$ \-both 
subroutines being described in Section \ref{sect:soubroutines} in more detail.

In the second step, committee members vote for the hash that received at least the 
ammount of votes set by the threshold $\tau_{step} * T_{step}$ for this step, or the hash of the default empty
block if no hash was observed to receive enough votes. Here, TIMEOUT is a special value to signify that the vote count
could not observe a threshold surpassing value in the required time window.

% It relies heavily on the assumption that, if the block proposer was honest, most users 
% will get to the soft vote stage with the same hblock parameter.
% However, if some proposers were dishonest, then no single hblock may be popular enough to 
% cross the threshold (and therefore this stage will return an empty\_hash) and there 
% will at most be one non-empty block that can be returned by soft vote 
% for all honest users.\marginpar{porque at most one? Igual, quizas sacaria esta `opinion' de la descrip del algoritmo}

\noindent \textbf{Returns:}
\begin{itemize}
    \item A block hash, chosen by a majority of users in the soft vote / reduction stage 
    (could be the empty block hash)
\end{itemize}

\end{subsection}
% --------------------------------------------------------------------
\begin{subsection}{Vote Certification}\label{ssect:certifyvote}
    \begin{algorithm}[H]
        \begin{algorithmic}[H]
        \Function{$\mathsf{CertifyVote}$}{$blockHash$}
        \State $localBlockHash \gets blockHash$
    
        \State $step \gets 2$
        \While{$step < 256$}
            \\
            \State $\langle blockHash, bConfirmed \rangle \gets \mathsf{BLOCK\_STEP}(blockHash, localBlockHash, step)$
            \If{$bConfirmed$}{ $\Return$ $blockHash$}
            \EndIf
            \State $step++$\\
       
            \State $ \langle blockHash, bConfirmed \rangle \gets \mathsf{EMPTY\_STEP}(blockHash,step)$
            \If{$bConfirmed$}{ $\Return$ $blockHash$}
            \EndIf
            \State $step++$\\
    
            \State $\mathsf{CommonCoinFlipVote}(blockHash, step)$
            \State $step++$
        \EndWhile \\
        
        \While{$True$} \State $NOP$ ${}$ {\hskip 1cm} //await asynchronous recovery
        \EndWhile

        \EndFunction
        \end{algorithmic}
        \caption{\underline{CertifyVote}}
    \end{algorithm}
    
\noindent \textbf{Arguments:}
\begin{itemize}
    \item A block hash, $BlockHash$, received from the previous stage (soft vote)
  \end{itemize}

\noindent \textbf{Description:}\\
The certify vote stage is the core of the voting algorithm.
The main loop executes a maximum of 254 times (from step 2 to step 255, called ``cert'' and ``down'' 
respectively on the \href{https://github.com/algorandfoundation/specs}{specs.}).
This is to avoid an attacker indefinitely postponing consensus in a compromised network, giving them a 
small chance to force consensus on their desired block with each iteration.

The {\sf CertifyVote} algorithm comprises three important procedures: 
\begin{enumerate}
    \item the block step, where, if selected as a committee member, votes for the block selected in 
    the soft voting stage and then attempts to confirm it by listening to other cast votes until a 
    threshold is met. If this step times out and no consensus is reached, it moves on to the empty 
    step. 
    \item Very similar in nature to the previous one, in this procedure a vote is cast for the 
    value in {\em blockHash} and then it attempts to confirm an empty block.
    \item if no consensus is reached on the empty block, it arrives to the common coin procedure, 
    where it attempts another vote and vote count for the empty block. 
    If here, no consensus is reached, it uses the pseudo-randomness of the VRF hash output to ``flip a coin" 
    by looking at the last bit of the lowest sortition hash owned by observed committee members.
    This makes it so even though the coin flip is random, most users will observe the same outcome and will 
    in turn set their {\em blockHash} values according to the observed bit. 
    In turn, this prevents an adversary from being able to easily predict beforehand what the next vote 
    of a user would be if they were a committee user, and therefore the attacker cannot force consensus 
    sending their vote messages to targeted users in a scenario where the voting is split pretty evenly 
    but no block has quite enough votes to push the threshold.
\end{enumerate}
If no consensus is reached before the step counter reaches {\em MAX\_STEPS}, 
the program stops in an infinite loop and awaits for the asynchronous recovery
protocol to kick in.\\

\noindent \textbf{Returns:}
\begin{itemize}
    \item A block hash certified by a majority of users, to be confirmed and added to the ledger in the next stage as TENTATIVE or FINAL depending
    on the observed voting share
  \end{itemize}


\end{subsection}
% --------------------------------------------------------------------
\begin{subsection}{Block Confirmation}\label{ssect:blockconfirmation}

\begin{algorithm}[H]
    \begin{algorithmic}[H]
    \Function{$BlockConfirmation$}{$blockHash$}

    \State $r \gets \mathsf{CountVotes}(ctx, round, FINAL, T_{final}, \tau_{final}, lstep)$
    \If{$r = blockHash$}
        \State \Return $\langle FINAL, BlockOfHash(blockHash)\rangle$ 
    \Else
    {
        \State \Return $\langle TENTATIVE, BlockOfHash(blockHash)\rangle $
    }
    \EndIf
    \EndFunction
    \end{algorithmic}
    \caption{\underline{BlockConfirmation}}
\end{algorithm}


\noindent \textbf{Arguments:}
\begin{itemize}
    \item A block hash, $BlockHash$ received from the previous stage (Sect.~\ref{ssect:certifyvote})
  \end{itemize}

\noindent \textbf{Description:}\\
Finally, the proposed block (be it an empty block or a specific one 
proposed by a designated user) is confirmed and added to the ledger.
We introduce the notions of FINAL and TENTATIVE consensus.
Specifically, if a block is confirmed in the very first step of the
certify vote stage, its vote is cast as FINAL.
If enough users reproduce this behavior, the vote count on line 2 for 
votes cast in this fashion is over the required threshold, and the 
consensus is labeled as FINAL.
This means that the block is simultaneously added to the ledger and 
confirmed, as well as immediately confirming any prior blocks that 
could have been labeled TENTATIVE.
If this node is not able to ensure that enough users considered the 
block represented by hblock as FINAL, the consensus is labeled as 
TENTATIVE, and it may be confirmed by a later FINAL block.
The $\mathsf{BlockOfHash}()$ function outputs the full block for the provided 
hash, either by returning a locally available copy or by requesting 
it from other users.

\noindent \textbf{Returns:}
\begin{itemize}
    \item A full block to be added to the ledger, along with a flag indicating if
    the consensus achieved is TENTATIVE or FINAL in nature
  \end{itemize}

\end{subsection}
\end{section}
% ------------------------------------------------------------------------------------
% ------------------------------------------------------------------------------------
\begin{section}{Subroutines}\label{sect:soubroutines}

\begin{algorithm}[H]
    \begin{algorithmic}[H]
    \Function{$\mathsf{CountVotes}$}{$ctx, round, step, T, \tau, \lambda$}

    \State $startTime \gets \mathsf{currentTime}()$

    \State $counts \gets \{\}$ \text{// hash table, new keys mapped to 0}
    \State $voters \gets \{\}$
    \State $msgs \gets incomingMsgs[round,\,step]$

    \While{$TRUE$}
        \State $m \gets msgs.next()$
        \If{$m = \bot$}
            \If{$ElapsedTime > startTime + \lambda$}
                \State $\Return\;TIMEOUT$
            \EndIf
        \Else
            \State $ \langle votes, value, sorthash \rangle \gets \mathsf{ProcessMsg}(ctx, \tau, m)$
            \IfThen{$m.pk \in voters \lor votes = 0$}{$continue$}
            \State $voters$ $\cup=$ $\{m.pk\}$
            \State $counts[value] += votes$
            \IfThen {$counts[value] \geq T * \tau$}{$\Return$ $value$}
        \EndIf
    \EndWhile
    \EndFunction
    \end{algorithmic}
    \caption{\underline{CountVotes}}
\end{algorithm}


\noindent \textbf{Arguments:}
\begin{itemize}
    \item $ctx$ = a helper structure to retrieve ledger context information (e.g. the last confirmed block)
    \item $round$ = current round number
    \item $step$ = current step number
    \item $T$ = fraction of expected committee members to get the confirmation threshold
    \item $\tau$ = expected number of committee members
    \item $\lambda$ = maximum time to keep running the vote count and waiting for network messages
  \end{itemize}

\noindent \textbf{Description:}\\
This subroutine counts the votes for any observed block hash value, for a given 
round and step numbers.
It returns as soon as it finds a value exceeding the specified threshold (which
will also vary according to round and step).
If no value is observed to have the required amount of votes in the predetermined 
temporal window, it finishes with a TIMEOUT.
It is important to notice that every committee user's vote is processed at most 
once for the given context.\\

Messages $m$ are structured ....\marginpar{completar que es un msj, que es mpk, etc}
The function $\mathsf{ProcessMsg}$ returns....

This subroutine counts the votes for any observed block hash value, for a given 
round and step numbers.
It returns as soon as it finds a value exceeding the specified threshold (which
will also vary according to round and step).
If no value is observed to have the required amount of votes in the predetermined 
temporal window, it finishes with a TIMEOUT.
It is important to notice that every committee user's vote is processed at most 
once for the given context.\\

\noindent \textbf{Returns:}
\begin{itemize}
    \item the first block hash value observed to achieve the required threshold, 
    or a TIMEOUT constant if none was found in the required time window.
  \end{itemize}

% ----------------------------------------------------------------------------------------------

\begin{algorithm}[H]
    \begin{algorithmic}[H]
    \Function{$\mathsf{CommitteeVote}$}{$ctx, round, step, T, \tau, \lambda$}
        \State $role \gets \langle {committee},round,step\rangle$
        \State $\langle sorthash,\pi,j\rangle \gets \mathsf{Sortition}(user.sk,ctx.seed,\tau ,role,ctx.weight[user.pk],ctx.W)$
        \text{// only committee members originate a message}
        \If{$j > 0$}
            \State $\mathsf{GOSSIP\_MSG}(user.pk, \mathsf{Signed}_{user.sk} (round,step,sorthash,\pi,\mathsf{Hash}(ctx.last_{block}),value))$
        \EndIf
    \EndFunction
    \end{algorithmic}
    \caption{\underline{CommitteeVote}}
\end{algorithm}

\noindent \textbf{Arguments:}
\begin{itemize}
    \item $ctx$ = a helper structure to retrieve ledger context information (e.g. the last confirmed block)
    \item $round$ = current round number
    \item $step$ = current step number
    \item $T$ = fraction of expected committee members to get the confirmation threshold
    \item $\tau$ = expected number of committee members
    \item $\lambda$ = maximum time to keep running the vote count and awaiting for network messages
  \end{itemize}

\noindent \textbf{Description:}\\
This subroutine verifies that the caller is a member of the specified committee (for a given round and step number), 
and in that case casts a vote for the block passed as argument.\\

\noindent \textbf{Returns:}\\
The subroutine has no return value, it only gossips the specified vote if the caller is a committee member.

% ----------------------------------------------------------------------------------------------

\begin{algorithm}[H]
    \begin{algorithmic}[H]
    \Function{$ComputeSeed$}{$ctx, r, B$}
        \If{$B \neq empty\_block$} 
            \State $\Return$ $VRF_{get_{SK_a}(ctx, r)}(ctx.LastBlock.seed||r$)
        \Else
            \State $\Return$ $\mathsf{Hash}(ctx.LastBlock.seed||r)$
        \EndIf
    \EndFunction
    \end{algorithmic}
    \caption{\underline{ComputeSeed}}
\end{algorithm}


\noindent \textbf{Arguments:}
\begin{itemize}
    \item $ctx$ = a helper structure to retrieve ledger context information (e.g. the last confirmed block)
    \item $r$ = current round number
    \item $B$ = the block whose seed is being computed
  \end{itemize}


\noindent \textbf{Description:}\\
This subroutine computes the required sortition seed for the given round number, 
which goes in the proposed block's metadata.
If the block is empty, the seed is a hash of the previous block's seed.
The $get_{SK_a}(ctx, r)$ helper function gets the relevant account's secret ephemeral keys (according to the signing scheme described in specs, the keys 160 rounds prior to $r$).
This roughly corresponds to the secret key from a round $b$ time before block $r-1-(r\;mod\;R)$, where $R$ is the sortition seed's renewal rate, $r$ is the current round's number,
and $b$ is the upper bound for the maximum ammount of time that the network might be compromised.\\

\noindent \textbf{Returns:}
\begin{itemize}
    \item the computed seed for the given block, ledger context and round
  \end{itemize}

% ----------------------------------------------------------------------------------------------

\begin{algorithm}[H]
    \begin{algorithmic}[H]
        \Function{$getSortitionSeed$}{$ctx, r, a_{pk}$}
        
            $\Return\;ctx.block[r-1-(r\;mod\;R)].seed$

        \EndFunction
    \end{algorithmic}
    \caption{\underline{getSortitionSeed}}
\end{algorithm}

\noindent \textbf{Arguments:}
\begin{itemize}
    \item $ctx$ = a helper structure to retrieve ledger context information (e.g. the last confirmed block)
    \item $round$ = current round number
    \item $a_{pk}$ = the account's public key for the look up table
  \end{itemize}


\noindent \textbf{Description:}\\
This helper function gets the relevant sortition seed for the current round $r$, according to the seed lookback parameter $R$.
Conceptually, it corresponds with the seed computed $R$ rounds prior to $r$, refreshed every $R$ rounds.

\noindent \textbf{Returns:}
\begin{itemize}
    \item a sortition seed to be used in the round $r$
  \end{itemize}

% ----------------------------------------------------------------------------------------------

\begin{algorithm}[H]
    \begin{algorithmic}[H]
        \Function{$getSortition_w$}{$ctx, round, a_{pk}$}

            $\Return\;ctx.balanceTable[r - (R + SL)][a_{pk}]$

        \EndFunction
    \end{algorithmic}
    \caption{\underline{getSortitionWeight}}
\end{algorithm}

\noindent \textbf{Arguments:}
\begin{itemize}
    \item $ctx$ = a helper structure to retrieve ledger context information (e.g. the last confirmed block)
    \item $r$ = current round number
    \item $a_{pk}$ = the account's public key for the look up table
  \end{itemize}


\noindent \textbf{Description:}\\
This helper function retrieves the stake $R + SL$ rounds prior to $r$, for an account
with public key $a_{pk}$

\noindent \textbf{Returns:}
\begin{itemize}
    \item the relevant account's stake
  \end{itemize}


% ----------------------------------------------------------------------------------------------


\begin{algorithm}[H]
    \begin{algorithmic}[H]
        \Function{$getSortition_W$}{$ctx, r$}
        
        $\Return \sum_{a_{pk}\;\in\;ctx.balanceTable[r - (R + SL)]}{balanceTable[r - (R + SL)][a_{pk}]}$

        \EndFunction
    \end{algorithmic}
    \caption{\underline{getSortitionTotalStake}}
\end{algorithm}

\noindent \textbf{Arguments:}
\begin{itemize}
    \item $ctx$ = a helper structure to retrieve ledger context information (e.g. the last confirmed block)
    \item $r$ = current round number
  \end{itemize}


\noindent \textbf{Description:}\\
This helper function returns the sum of all stake for $R + SL$ rounds prior to $r$.

\noindent \textbf{Returns:}
\begin{itemize}
    \item the total stake at play in the relevant round (according to lookback parameters)
  \end{itemize}

% ----------------------------------------------------------------------------------------------

\begin{algorithm}[H]
    \begin{algorithmic}[H]
    \Function{$\mathsf{Sortition}$}{$sk, seed, \tau, role, w, W$}
        \State $ \langle hash, \pi \rangle \gets \mathsf{VRF}(seed||role)$
        \State $p \gets \frac{t}{W}$
        \State $j \gets 0$
        \While{$\frac{hash}{2^{hashlen}}\notin [ \sum_{k=0}^j\mathsf{B}(k;w,p), \sum_{k=0}^{j+1}\mathsf{B}(k;w,p))$}
            \State $j++$
        \EndWhile
        \Return $ \langle hash,\pi,j \rangle$
    \EndFunction
    \end{algorithmic}
    \caption{\underline{Sortition}}
\end{algorithm}


\noindent \textbf{Arguments:}
\begin{itemize}
    \item $sk$ = a user's secret key (an ephemeral key for the given round, according to key specs)
    \item $seed$ = the sortition seed to be used
    \item $\tau$ = the expected committee size for the given role
    \item $role$ = a flag specifying the role for the sortition to take place (e.g. block proposer)
    \item $w$ = the user's weight (i.e., its relevant stake)
    \item $W$ = the total relevant stake for the given round
\end{itemize}

\noindent \textbf{Description:}\\
The Sortition procedure is one of the most important subroutines in the main algorithm, as it is 
used in multiple stages and contexts.
Generally, it manages to pseudo-randomly but verifiably (through the use of a Verifiable Random 
Function) select a user with probability proportional
to their weight (i.e., stake) by returning a j parameter, which indicates the number of times that 
specific user was chosen.
Algorithmically, every monetary unit the user has is considered a "sub-user", and then each one 
of them is selected with probability $p = \frac{\tau}{W}$,
where $\tau$ is the expected amount of users to be selected for the given role.
The semi-open interval $[0,1)$ is then split into consecutive intervals using an accumulated 
binomial distribution, and wherever the fraction $\frac{hash}{2^{hashlen}}$
belongs to the interval, that's the ammount of chosen sub-users for the subroutine caller.\\

\noindent \textbf{Returns:}
\begin{itemize}
    \item an integer $j$ that will be positive (larger than 0) if the user has been selected, 
    and its size corresponds to the amount of sub-users for a given committee member
  \end{itemize}

% ----------------------------------------------------------------------------------------------


\begin{algorithm}[H]
    \begin{algorithmic}[H]
    \Function{$\mathsf{VerifySortition}$}{$pk, seed, \tau, role, w, W$}
        \IfThen{$\neg \mathsf{VerifyVRF}_{pk}(hash, \pi, seed||role)$}{$\Return 0$}
        \State $p \gets \frac{t}{W}$
        \State $j \gets 0$
        \While{$\frac{hash}{2^{hashlen}} \notin [\sum_{k=0}^j\mathsf{B}(k;w,p), \sum_{k=0}^{j+1}\mathsf{B}(k;w,p))$}
            \State $j++$
        \EndWhile
        \Return $j$
    \EndFunction
    \end{algorithmic}
    \caption{\underline{VerifySortition}}
\end{algorithm}

\noindent \textbf{Arguments:}
\begin{itemize}
    \item $pk$ = a user's public key (their address)
    \item $seed$ = the sortition seed to be used
    \item $\tau$ = the expected committee size for the given role
    \item $role$ = a flag specifying the role for the sortition to take place (e.g. block proposer)
    \item $w$ = the user's weight (i.e., its relevant stake)
    \item $W$ = the total relevant stake for the given round
  \end{itemize}

\noindent \textbf{Description:}\\
The sortition verification procedure takes Sortition's output and utilizes 
VRF properties to verify the validity of said output.
Once the check is passed, it repeats Sortition's sub-user selection procedure, 
and outputs the amount of times the user was chosen according to their respective 
observed stake.\\

\noindent \textbf{Returns:}
\begin{itemize}
    \item an integer $j$ that will be positive (larger than 0) if the user has been 
    selected, and it's size corresponds to the amount
    of sub-users for a given committee member
  \end{itemize}

% ----------------------------------------------------------------------------------------------

\begin{algorithm}[H]
    \begin{algorithmic}[H]
    \Function{$\mathsf{BLOCK\_STEP}$}{$hblock, blockHash, step$}
        \State $bConfirmed \gets FALSE$
        \State $hb \gets hblock$

        \State $\mathsf{CommitteeVote}(ctx, round, step, \tau_{step}, hb)$
        \State $hb \gets \mathsf{CountVotes}(ctx,round,step,T_{step},\tau_{step},\lambda_{step})$
        \If{$hb = TIMEOUT$}
            \State $hb \gets blockHash$
        \ElsIf{$hb \neq emptyHash$}
            \For{$step < s^\prime \leq step + 3$}
                \State $\mathsf{CommitteeVote}(ctx, round, s^\prime, \tau_{step}, hb)$
            \EndFor
            \If {$step = 1$}
                \State $\mathsf{CommitteeVote}(ctx, round, FINAL, \tau_{final}, hb)$
            \EndIf
            \State $bConfirmed \gets TRUE$
        \EndIf
        $\Return$ $ \langle hb, bConfirmed \rangle$
    \EndFunction
    \end{algorithmic}
    \caption{\underline{BLOCK\_STEP}}
\end{algorithm}

\noindent \textbf{Arguments:}
\begin{itemize}
    \item $hblock$ = a block hash value to be voted on
    \item $blockHash$ = the block hash value locally observed by the node to be the winning choice
    \item $step$ = currently executing step
  \end{itemize}

\noindent \textbf{Description:}\\
The BLOCK\_STEP subroutine handles the first part of the certifyVote's main loop.
It first casts a vote on the observed hblock value possibly coming off of a coin toss vote 
(see commonCoinFlipVote).
It then attempts to count incoming votes. In case of a timeout (i.e., no block passed the 
threshold), it returns the block hash.
Otherwise, and assuming the highest voted value is not an empty block hash, it casts votes 
for the next three steps for the block seen as selected.
Then, in the special scenario where we are in step 1, we cast our vote as FINAL, suggesting 
that this block is a candidate for a final consensus (if enough committee members observe 
this fact).
Finally, the procedure returns the selected block and a flag to either continue or return 
from the main procedure with a certified vote.

\noindent \textbf{Returns:}
\begin{itemize}
    \item a tuple $\langle hb, bConfirmed \rangle$, comprised of a block hash value and a 
    boolean flag to assert whether the given value was
    observed to be confirmed in any way or if further steps are needed
  \end{itemize}

% ----------------------------------------------------------------------------------------------

\begin{algorithm}[H]
    \begin{algorithmic}[H]
    \Function{$\mathsf{EMPTY\_STEP}$}{$hblock, step$}
        \State $bConfirmed \gets FALSE$
        \State $hb \gets hblock$

    \State $\mathsf{CommitteeVote}(ctx, round, step, \tau_{step}, hb)$
    \State $hb \gets \mathsf{CountVotes}(ctx,round,step,T_{step},\tau_{step},\lambda_{step})$
    \If{$hb = TIMEOUT$}
        \State $hb \gets emptyHash$
    \ElsIf{$hb = emptyHash$}
        \For{$step < s^\prime \leq step+3$}
            \State $\mathsf{CommitteeVote}(ctx, round, s^\prime, \tau_{step}, hb)$
        \EndFor
        \State $bConfirmed \gets TRUE$
    \EndIf
    $\Return$ $\langle hb, bConfirmed \rangle$
    \EndFunction
    \end{algorithmic}
    \caption{\underline{EMPTY\_STEP}}
\end{algorithm}

\noindent \textbf{Arguments:}
\begin{itemize}
    \item $hblock$ = a block hash value to be voted on
    \item $step$ = currently executing step
  \end{itemize}

\noindent \textbf{Description:}\\
The EMPTY\_STEP procedure works in a very similar fashion to BLOCK\_STEP, 
with two main differences: 
the block to attempt to confirm is the empty block, and there is no final 
consensus achievable in this scenario.

\noindent \textbf{Returns:}
\begin{itemize}
    \item a tuple $\langle hb, bConfirmed \rangle$, comprised of a block hash 
    value and a boolean flag to assert whether the given value was
    observed to be confirmed in any way or if further steps are needed
  \end{itemize}

% ----------------------------------------------------------------------------------------------

\begin{algorithm}[H]
    \begin{algorithmic}[H]
    \Function{$\mathsf{CommonCoinFlipVote}$}{$hblock, blockHash, step$}
        \State $hb \gets hblock$
    
        \State $\mathsf{CommitteeVote}(ctx, round, step, \tau_{step}, hb)$
        \State $hb \gets \mathsf{CountVotes}(ctx,round,step,T_{step},\tau_{step},\lambda_{step})$
        \If{$hb = TIMEOUT$}
            \If{$\mathsf{CommonCoin}(ctx,round,step,T_{step},\tau_{step},\lambda_{step}) = 0$}
                \State $hb \gets blockHash$
            \Else
                \State $hb \gets emptyHash$
            \EndIf
        \EndIf
    \EndFunction
    \end{algorithmic}
    \caption{\underline{CommonCoinFlipVote}}
\end{algorithm}

\noindent \textbf{Arguments:}
\begin{itemize}
    \item $hblock$ = a block hash value to be voted on
    \item $blockHash$ = the block hash value locally observed by the node to be the winning choice
    \item $step$ = currently executing step
  \end{itemize}

\noindent \textbf{Description:}\\
This procedure casts a vote for the previous step's selected block, then does a vote count,
and finally flips a coin (last bit of lowest sortition hashed user, see CommonCoin) that's random,
but consensuated between a majority of users. This guarantees that an attacker could not guess what the
next vote will be for a given user, and introduces a tool to facilitate reaching a tentative consensus in the next stages.

\noindent \textbf{Returns:}
\begin{itemize}
    \item a block hash value, decided randomly in between the locally chosen block hash or an empty hash, to be voted on
    in the immediately following step
  \end{itemize}

% ----------------------------------------------------------------------------------------------

\begin{algorithm}[H]
    \begin{algorithmic}[H]
    \Function{$\mathsf{CommonCoin}$}{$ctx, round, step, \tau$}

    \State $minhash \gets 2^{hashlen}$
    \For{$m \in incomingMsgs[round, step]$}
        \State $\langle votes,value,sorthash\rangle \gets \mathsf{ProcessMsg}(ctx,\tau,m)$
        \For{$1 \leq j < votes$}
                \State $h \gets \mathsf{Hash}(sorthash||j)$
                \IfThen{$h < minhash$}{$minhash \gets h$}
        \EndFor
    \EndFor
    $\Return$ $minhash$ $mod$ $2$
    \EndFunction
    \end{algorithmic}
    \caption{\underline{CommonCoin}}
\end{algorithm}


\noindent \textbf{Arguments:}
\begin{itemize}
    \item $ctx$ = a helper structure to retrieve ledger context information (e.g. the last confirmed block)
    \item $round$ = current round number
    \item $step$ = current step number
    \item $\tau$ = the expected committee size for the given role
  \end{itemize}

\noindent \textbf{Description:}\\\\
The CommonCoin procedure takes advantage of the randomness of sortition hashes, and attempts to
get a consensus random bit (a coin toss) getting the least significant bit of the lowest hashed
sortition hash concatenated with sub-user index, for all committee voters in the given round and step.
Since sortition hashes are random, even if an attacker happened to be a committee member with the lowest observable hash,
the coin value's randomness would still be preserved, and in successive steps the probability of them being chosen again and
able to manipulate this stage would severely diminish.\\

\noindent \textbf{Returns:}
\begin{itemize}
    \item a random bit (either 0 or 1), observed to be the least significant bit of the hashed sortition hash of a committee member for the given step,
    that should be observed by a majority of users to be the same (conceptually, a consensus coin toss)
  \end{itemize}

\end{section}
% ----------------------------------------------------------------------------------------------
\section*{Appendix: Notation}


\begin{itemize}
    \item $R$ = sortition seed renewal rate (in number of rounds). 
    Set to 2 in the \href{https://github.com/algorandfoundation/specs}{specs.}
    as of December 2022
    \item $MAX\_STEPS$ = maximum number of allowed steps in the main algorithm. Defined 
    as 255 in the \href{https://github.com/algorandfoundation/specs}{specs.}
    \item $\tau_{step}$ = expected number of members on a regular step committee
    \item $\tau_{final}$ = expected number of members on a final consensus achieving committee
    \item $T_{step}$ = fraction of expected members for a voting committee on a given step
    \item $T_{final}$ = fraction of expected members for a voting committee on the final step (step = 2). 
    If observed, achieves final consensus on the given block hash
    \item $\lambda_{proposal}$ = time interval for the node to accept block proposals, after
    which it chooses the observed block with the highest priority (lowest hash) 
    \item $\lambda_{block}$ = waiting time for the full block to be received once decided by vote.
    If no full block is received, the node falls back to the empty block.
    \item $SL$ = the account balances lookback interval, in number of rounds (integer). 
    Set to 320 in \href{https://github.com/algorandfoundation/specs}{specs.}
    \item Public keys $a_{pk}$ for every account linked to the node (doubles as their respective addresses)
    \item Public participation keys $a_{p\_partkey}$ for all accounts registered as online (private participation keys are kept
    securely by respective users and should not be directly accesible by the node)
    \item Two levels of ephemeral keys, signed according to the signing scheme described in \href{https://github.com/algorandfoundation/specs}{specs.} (where 
    first level keys are signed with the participation keys, and second level (aka. leaf) ephemeral keys are signed with 
    first level ephemeral keys). 
    These keys are used for actual participation in the consensus (abstracted as $a_{sk}$ in the following code)
    They are ephemeral because they live for a single round, after which they are deleted
    \item A balance table $BalanceTable$ for all accounts linked to the node, for the round $SL + R$ rounds before the one 
    currently running
\end{itemize}



% ----------------------------------------------------------------------------------------------

\bibliographystyle{alpha}
\bibliography{bibliography}


\end{document}