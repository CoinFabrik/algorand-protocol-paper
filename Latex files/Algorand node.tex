\documentclass[10pt,a4paper]{article}

\usepackage[utf8]{inputenc} % para poder usar tildes en archivos UTF-8
\usepackage[english]{babel}
\usepackage{a4wide} % márgenes un poco más anchos que lo usual
\usepackage{hyperref}
\usepackage{float}
% Comandos para simbolos matematicos.
\usepackage{amsmath, amssymb}%, tabularx}

% Comandos para algoritmos.
\usepackage[noend]{algpseudocode}
\usepackage{algorithm}
\algnewcommand{\IfThenElse}[3]{% \IfThenElse{<if>}{<then>}{<else>}
    \State \algorithmicif\ #1\ 
    \algorithmicthen\ #2\ 
    \algorithmicelse\ #3}
\algnewcommand{\IfThen}[2]{% \IfThenElse{<if>}{<then>}
    \State \algorithmicif\ #1\ \algorithmicthen\ #2}
%\pgfplotsset{compat=1.16}

% index of words
\usepackage{imakeidx}
\makeindex

\usepackage[fulladjust]{marginnote}
%\renewcommand{\marginpar}[1]{\marginpar{\raggedleft\small #1}}


\author{Argimiro, CoinFabrik}
\title{Algorand Protocol Description}

\begin{document}
\maketitle
\tableofcontents

% ---------------------------------------------------------------------------------------
\begin{section}{Introduction}
We aim to describe how the Algorand protocol works. 
This document is meant to reflect how the Algorand mainnet is behaving
today. We relied on Algorand's documents (\cite{DBLP:conf/sosp/GiladHMVZ17},
\cite{DBLP:journals/corr/Micali16} and
\href{https://github.com/algorandfoundation/specs}{Algorand's official specifications})
but consulted the node's code and probed the network when information was unclear or
unavailable.

Algorand is a proof-of-stake blockchain cryptocurrency protocol 
using a decentralized By\-zan\-tine Agreement protocol that leverages 
pure proof of stake for consensus. 
Protocol parties are represented by accounts, which may represent users
or smart contracts. 
The protocol maintains a ledger, which encodes the protocol status,
that is modified via consensus.
In particular, this ledger encodes how many {\sf ALGO tokens}\index{ALGO token} 
(the native token) holds each account.

Blocks encode the status of the ledger. Starting on the genesis\index{blocks}
block (round 0) that encodes the first state of the network, 
on each round the participation nodes vote on what will the next
block be. Algorand is designed so that the voting power is proportional
to the stake (in ALGO) held by the accounts associated to the node.

At the genesis of the Algorand blockchain, 10Bn ALGO were minted. 
As of September 2022, circulating supply is approximately 6.9b ALGO, 
distributed through different forms of ecosystem support and 
community incentives. 
The remaining ALGO tokens are held by the Foundation in secure wallets 
assigned to 
Community and Governance Rewards (\%53), 
Ecosystem Support (\%36), and 
Foundation endowment (\%11).

In the following document we present a detailed pseudocode interpretation 
of the program run by an Algorand node managing at least one online (i.e., 
participating) account. We attempt to explain the different states the node 
can be in, as well as all kinds of events that cause transitions and network 
output. This work aims to provide a basis for an Algorand blockchain simulator 
currently in development. 

\end{section}
% ---------------------------------------------------------------------
\begin{section}{Network}
A network is formed of two kinds of nodes: {\sf relay nodes}\index{relay nodes}
and {\sf participation nodes}\index{participation nodes}. 
Both nodes operate on servers that are connected to the internet and run publicly
available code from \href{https://github.com/algorand/go-algorand}{Algorand's code repository}.
Participation nodes can connect only to relay nodes, they run an instance
of the Aglorand Virtual Machine (AVM)\index{Algorand Virtual Machine}.\marginpar{el voting y demas esta afuera de la avm?}
They are non-archival in nature, meaning they don't keep\index{archival node}\index{non-archival node}
the whole ledger in memory at all times. At the time of this writing,
participation nodes keep the latest 1000 blocks.
Any queries that require blocks prior to those, need to be made
through one of the relay nodes they are connected to.
These nodes are responsible for running the consensus algorithm that
will be outlined in this document.
Relay nodes on the other hand, are archival (meaning they have immediate
access to the whole ledger), but do not participate in consensus.
They function as network level facilitators, collecting messages sent by participation
nodes or other relay nodes and distributing them across the network.

Currently, any individual or entity is able to run a participation node, 
but relay nodes are permissioned. They must be {\em whitelisted} by Algorand Foundation.\marginpar{validar que es AF quien whitelistea}

When a participation node is booted up, it establishes a peer-to-peer (P2P) 
channel with at least one relay (4 on average), using a phone book which is included
as part of the node's code. 
Relay nodes manage a significantly higher number of connections, as they 
are responsible for keeping the network's high throughput.

Accounts are managed by participation nodes. Accounts should be registered in at least one participation
node only, however this is not enforced.
In order for an account to participate in consensus, it needs to switch its status to "online". 
That is achieved by sending a special {\tt keyreg} transaction,\index{{\tt keyreg} transaction}
which registers a participation key for the account and creates a two-level ephemeral key tree.
It is important to note that the registered account will only start participating in consensus
$\delta_b$ rounds after the key registration transaction is approved.
Any account participating in consensus does so with their full balance. There is no risk
associated to participation, nor there are any rewards for running a node.

TODO: maybe include some voting stats?

\end{section}
% --------------------------------------------------------------------------------------
\begin{section}{Node as a State Machine}
A network participation node can be modeled as a state machine.
In this section we will define all primitives and data structures necessary to define the state
of a node; the rest of the work will be spent on describing the rules and interrelations that
make nodes transition from and into different states.

Let round and period number, $r$ and $p$, be unsigned 64-bits integers. Let the \marginpar{Define period}
step number, $s$, be an unsigned 8 bits integer.
For convenience and readability, we define the following enumeration for step number:
$$
\left\{    
    \begin{array}{ll}
        \mathsf{proposal}&\mbox{if }s=0 \\
        \mathsf{soft}&\mbox{if }s=1 \\
        \mathsf{cert}&\mbox{if }s=2\\
        \mathsf{next}_{s-3}&\mbox{if }s\in [3, 252]\\
        \mathsf{late}&\mbox{if }s=253\\
        \mathsf{redo}&\mbox{if }s=254\\
        \mathsf{down}&\mbox{if }s=255
    \end{array}
\right.
$$

A ${\sf ledger}$ is a sequence of states which comprise the common information established by some instantiation 
of the Algorand protocol.\index{ledger}
It is identified by a string called the genesis identifier, as well as a genesis hash that cryptographically 
commits to the starting state of the ledger.
Besides the already defined round number $r$, which indexes into the Ledger's sequence of states,
a Ledger's state is defined by the following components:
\begin{itemize}
    \item Genesis identifier and genesis hash, unambiguously defining the ledger 
    to which the state belongs.
    \item Protocol version and update state.
    \item Timestamp (in milliseconds since genesis block), identifying when the state was first proposed.
    \item A 64 byte seed, source of randomness for the consensus algorithm.
    \item The current reward state, which describes the policy at which incentives
    are distributed to participants.
    \item The current box state, which holds mappings from (app id, name) tuples
    to box contents of arbitrary bytes.
\end{itemize}

A Ledger's state is completed by a Balance table, $BT$, a mapping of addresses to account records.
An account record comprises a 64-bits unsigned integer raw balance, a 3-state flag status (can be 
"online", "offline", or "non-participating"), its registered voting keys (more info on subsection~\ref{sect:keys}, keys) and 
two 64-bits unsigned integers $r_{start}$ and $r_{last}$, which represent the validity interval (in rounds)\marginpar{Pero la part key donde esta guardada?}
of the participation key (which acts as the root voting key for the Merkle tree).\marginpar{Cu\'al merkle t. no se definio!}
A node may query the current state of a particular account by indexing the balance table by address, or it might
query a previous round's account state by adding a round indexing. Note that past account states are 
always computable by iterating over the Ledger sequence of blocks and reverting transaction updates. Internally
however, certain past records might be cached and maintained to improve performance.

For convenience, we assume that each node maintains an account list that provide easy iteration access to all 
updated balance records for the accounts it manages which are flagged as online and have a valid participation 
key registered on this node. 
This array is named $A$ from now on, and each entry $a$ has an account address $a.I$, and all the information
in its mapped balance record, $BT[a.I]$, exposed and accessible.

Furthermore, a node possesses a Transaction pool, $TP$, which is a set of live unconfirmed transactions, $txn_k$, (where 
$k$ is an account's address, the creator and sender of the transaction), either
sent by accounts that are managed by the node itself or obtained from the network (broadcast by other nodes).
For the purpose of this report, transactions are an otherwise opaque object, with the attribution of modifying
account records.

A $\bold{block}$ is a data structure which specifies the transition between states.
The data in a block is divided between the block header and its block body.
A block header holds the following data:
\begin{itemize}
    \item The block's round, which matches the round of the state it is transitioning
    into. (The block with round 0 is special in that this block specifies not
    a transition but rather the entire initial state, which is called the genesis
    state. This block is correspondingly called the genesis block).
    \item The block's genesis identifier and genesis hash, constant and decided on
    Ledger creation.
    \item The block's upgrade vote, which results in the new upgrade state. The
    block also duplicates the upgrade state of the state it transitions into.
    \item The block's timestamp, which matches the timestamp of the state it transitions into. 
    The timestamp is decided by the proposer of the block using their own internal clock. 
    To be valid, a timestamp must be greater than the last commited block's timestamp 
    and must not be more than 25 seconds away from said time.
    \item The block's seed, which matches the seed of the state it transitions into.
    \item The block's reward updates, which results in the new reward state. The
    block also duplicates the reward state of the state it transitions into.
    \item A cryptographic commitment to the block's transaction sequence (a vector commitment).\marginpar{En qu\'e se distinguen los cmt?}
    \item A cryptographic commitment, using SHA256 hash function, to the block's
    transaction sequence (useful for compatibility with systems where SHA512/256 is not supported)
    \item The block's previous hash, which is the cryptographic hash of the previous
    block in the sequence. (The previous hash of the genesis block is 0).
    \item The block's transaction counter, which is the total number of transactions
    issued prior to this block. This count starts from the first block with a
    protocol version that supported the transaction counter.
    \item The block's expired participation accounts, which contains an optional slice
    of public keys of accounts. These accounts are expected to have their
    participation key expire by the end of the round (or was expired before
    the current round).
    The block's expired participation accounts slice is valid as long as the participation keys 
    of all the accounts in the slice are expired by the end of the round or
    were expired before, the accounts themselves would have been online at the end
    of the round if they were not included in the slice, and the number of elements
    in the slice is less or equal to 32. A block proposer may not include all such
    accounts in the slice and may even omit the slice completely
\end{itemize}
While a block's body is the block's transaction sequence, which describes the sequence
of updates to the account state and box state.\marginpar{Y los local states? los global states de los contratos, etc?}

Applying a valid block to a state produces a new state by updating each of its components.
A Ledger's evolution in time can then be specified as an ordered sequence of blocks.

A proposal-value is a tuple $v = (I, p, Hash(e), Hash(Encoding(e)))$ where I is\marginpar{Definir e}
an address (the “original proposer”), p is a period (the “original period”), and
Hash is some cryptographic hash function (implemented as SHA512/256). The special proposal where all fields
are the zero-string is called the bottom proposal $\bot$. 
It also includes the authentication information for the original proposer, that is, a signature and VRF proof of the proposal-value.

For convenience, we define the function $Proposal(v)$ for a given proposal value $v$,\marginpar{Pero en el parrafo de arriba v es otra cosa!}
such that $Proposal(v) = e$ iff e is the proposal that, when hashed, corresponds to the proposal
value $v$. The $Proposal()$ function has an inverse, $Proposal_{value}(e)$, such that
$Proposal_{value}(e) = v$ if $Proposal(v) = e$.
$Proposal()$ is not a biyective function (as hashes can theoretically collide), however we assume the inverse
exists and has a defined output whenever the relevant proposal has been observed by the node
(and is such that $e \in P$).\marginpar{Que es el cjto P?}

We define an auxiliary structure, $credentials$, useful in voting, with the following fields:
\begin{itemize}
    \item $sh$ is the sortition hash (64 byte string).
    \item $\pi$ is the sortition proof (32 byte string).
    \item $j$ is a 64 bit unsigned integer that represents the vote's weight.
\end{itemize}
An object of this type is output by the $\mathsf{Sortition}()$ procedure.

A vote $vt$, constructed as $Vote(I,r,p,s,v,cred)$ is a tuple with the following members:
\begin{itemize}
    \item $I$ is a valid Algorand address (in 32 byte format).
    \item $r$ is the vote's round (64 bit integer).
    \item $p$ is the vote's period (64 bit integer).
    \item $s$ is the vote's step (8 bit integer).
    \item $v$ is the vote's proposal value.
    \item $cred$, of type $credentials$, the committee credentials of the voter.
\end{itemize}

In reality all votes are broadcast wrapped in a structure called $UnauthenticatedVote$, where
a $credentials$ field is added, containing only the voter's sortition proof and address.
The rest of relevant data is reconstructed as part of the verification process, 
where a node authenticates the received vote and obtains the vote weight and sortition hash.
For the sake of simplicity we abstract away this step and assume availability of all $credentials$ fields.

Consider now a pair of votes, $vt_0$ and $vt_1$, constructed like
$vt_0 = Vote(I, r, p, s, v_0, cred)$ and $vt_1 = Vote(I, r, p, s, v_1, cred)$, where all values are equivalent
save for the proposal value, that is, $v_0 \neq v_1$. We call this pattern an $\bold{equivocation \ vote}$.
An equivocation vote is valid if both of its constituent votes are valid.
It's important to keep in mind that nodes are forbidden from equivocating on any steps $s \neq soft$.

Let  $b$ be a set of votes, and $vt_0, vt_1 \in b$ then $vt_0.r = vt_1.r \land vt_0.p = vt_1.p \land vt_0.s = vt_1.s$ 
and for each pair of distinct elements, either $vt_0.I \neq vt_1.I \land vt_0.v = vt_1.v$ or the pair $vt_0$, $vt_1$ 
is an equivocation vote. 
Also, the number of votes in $b$ is such that the sum of weights for each vote in $b$ is greater or equal to the
committee threshold of the votes in the set.
A set $b$ with these characteristics is called a $\bold{Bundle}$, constructed $b = Bundle(r,p,s,v)$.

We define a player's state, $S$, as a tuple of values, along with a ledger state $L$ and a balance table $BT$
$S = (r, p, s, V, P, \bar{v}, \bar{s}, L, BT)$ where
\begin{itemize}
    \item $r$ is the current round
    \item $p$ is the current period
    \item $s$ is the current step
    \item $V$ is all valid observed votes and equivocation votes in the current execution state ( $(r,p,s)$ tuple)
    \item $P$ is all valid observed proposals in the current execution state ( $(r,p,s)$ tuple)
    \item $\bar{v}$ is the pinned proposal-value
    \item $\bar{s}$ is the last finished step
    \item $L$ is the Ledger state. Note that, thanks to the genesis hash and previous hash components, a ledger state unambiguously
defines the whole history of state changes.
    \item $BT$ is the current balance table as described above.
    \item $TP$ is the node's transaction pool
\end{itemize}
The first 7 values are the consensus state parameters, whereas $L$ and $BT$ are ledger state parameters.
Note that functionally, a node plays for all online accounts it manages, so all individual
accounts playing in a specific node will be at the same state at all times.

Given all of the above data types and constructs, a node can be modelled as 
a finite state machine. A state is given by a 3-tuple of integers, $(r, p, s)$, 
two sets of objects $P$ and $V$ which we will call observed $proposal$ and $vote$ values, 
a Ledger $L$ and a balance table $BT$.
\\

For convenience, we define two special values: $\mu(r,p)$ and $\sigma(r,p)$.
$\mu(r,p)$ is the highest priority observed proposal-value in the current $(r,p)$ context (lowest hashed according to the function outlined
in the $\mathsf{BlockProposal}$ algorithm), or $\bot$ if no valid proposal vote has been observed by the node.
$\sigma(r,p)$ is the sole proposal-value for which a soft bundle has been observed (again, in the current $(r,p)$ context), or $\bot$ if
no valid soft bundle has been observed by the node.



\end{section}
% ------------------------------------------------------------------------
\begin{section}{Main algorithm}
% Broadcast(e) = Event(type=proposal-payload, data=e, sign=Signature(pk_sender, e))
% Broadcast(Vote(....)) = Event(type=vote, data=Vote(....), sign=Signature(pk_sender, Vote(....)))
%
% Broadcast(Bundle) = Event(type=bundle, data={v for v in Bundle}, sign=Signature(pk_sender, {v for v in Bundle}))

\begin{algorithm}[H]
    \begin{algorithmic}[1]
    \Function{$\mathsf{EventHandler}(Event \ ev)$}{}
    
    \If{$ev \ is \ TimeoutEvent$}
        \State $time \gets ev.time$
        \If{$time = 0$}
            \State $\mathsf{BlockProposal}()$
        \ElsIf{$time = \mathsf{FilterTimeout}(p)$}
            \State $\mathsf{SoftVote}()$
        \ElsIf{$time = \max\{4\lambda, \Lambda \}$}
            \State $\mathsf{Recovery}(next_0)$
        \ElsIf{$time = \max\{4\lambda, \Lambda \} + 2^{st-3}\lambda + r, st \in [4, 252], r \in U[0, 2^{st-3}\lambda]$}
            \State $\mathsf{Recovery}(next_{st-3})$
        \ElsIf{$time = k\lambda_f + r, k \in \mathbb{Z} \land k>0, r \in U[0, \lambda_f]$}
            \State $\mathsf{FastRecovery}()$
        \EndIf
    \Else \ //ev is MessageEvent
        \State $msg \gets ev.msg$
        \If{$msg \ is \ of \ type \ Proposal \ p$}
            \State $\mathsf{HandleProposal}(p)$
        \ElsIf{$msg\ is \ of\ type\  Vote \ v$}
            \State $\mathsf{HandleVote}(v)$
        \ElsIf{$msg\ is\ of\ type\ Bundle \ b$}
            \State $\mathsf{HandleBundle}(b)$
        \EndIf
    \EndIf

    \EndFunction
    \end{algorithmic}
    \caption{\underline{Main node algorithm}}
\end{algorithm}

On a higher level, we can think of a step as a defined part of the consensus algorithm. The first three steps
($proposal$, $soft$ and $cert$)
are the fundamental parts, and will be the only steps run in normal, ``healthy'' functioning conditions.
The following steps are recovery procedures in case there's no observable consensus before their trigger times.
$next_{s-3}$ with $s \in [3, 252]$ are recovery steps and the last three ($late$, $redo$ and $down$)
are special ``fast'' recovery steps.
A period is an execution of a subset of steps, ran in order until one of them achieves 
a bundle for a specific value. A round always starts with a $proposal$ step and finishes with a $cert$
step (when a block is certified and commited to the ledger). However, multiple periods might
be run inside a round until a certification bundle ($Bundle(r,p,s,v) $ where $s = cert$) is observable by the network.

\medskip
Events are the only way in which the node state machine is able to both internally transition and produce output.
In case an event is not identified as misconstrued or malicious in nature, it will certainly produce a state change,
and it will almost certainly cause a receiving node to produce and then broadcast or relay an output, to be consumed
by its peers in the network.
There are two kinds of events: Timeout events, which are produced once the internal clock of a node reaches a certain
time since the start of the current period; and Message events, which is output produced by nodes in response to some stimulus
(including the receiving node itself).
Internally, we consider the relevant data of an event to be:
\begin{itemize}
    \item A floating point number representing time in seconds, from the start of the current period, in which the event
    has been triggered.
    \item An event type, from an enumeration of two options (either $TIMEOUT$ or $MESSAGE$)
    \item An attached data type, an enumeration of four options: $NONE$ (chosen in case of an event of main type $TIMEOUT$), 
    $VOTE$, $PROPOSAL\_PAYLOAD$ and $BUNDLE$. It indicates the type of data attached.
    \item Attached data, plain bytes to be cast and interpreted according to the attached data type, or empty in case of a
    timeout event.
\end{itemize}

$\bold{Timeout \ Events}$ are events that are triggered after a certain time has elapsed after the start of a new period.
\begin{itemize}
    \item $soft$ Timeout (aka. Filtering): The filter timeout is run after a timeout of $FilterTimeout(p)$ is observed 
    (where $p$ is the currently running period). Note that it only depends on the period as far as if it's the first
    period in a round or a subsequent one.
    Will perform a filtering action, finding the highest priority proposal observed to produce a soft vote, as detailed
    in the soft vote algorithm.

    \item $next_0$ Timeout: it's the first recovery step, only executed if no consensus for a specific value was observed,
    and no $cert$ bundle is constructible with observed votes. It plays after observing a timeout of $\max\{4\lambda, \Lambda \}$.
    In it, the node will next vote a value and attempt to reach a consensus for an $next_0$ bundle, that would in turn kickstart
    a new period.

    \item $next_{st}$ Timeout: this family of timeouts runs whenever the elapsed time since the start of the period reaches
    $\max\{4\lambda, \Lambda \} + 2^{st-3}\lambda + r$, where $st\in [4, 252]$ and $r \in [0, 2^{st-3}\lambda]$, a random 
    delta sampled uniformly at random that represents network variability.
    The algorithm run is exactly the same as in the $next_0$ step.

    \item Fast recovery Timeout ($late$, $redo$ and $down$ steps): On observing a timeout of $k\lambda_f + r$ with $r$ a uniform random sample in $[0, \lambda_f]$ and
    $k$ a positive integer, the fast recovery algorithm is executed. It works in a very similar way to $next_k$ timeouts, with some subtle differences (besides trigger time).
    For a detailed description refer to its own subsection.
\end{itemize}


$\bold{Message \ Events}$ Are events triggered after observing a certain message carrying data.
There are 3 kinds of messages: votes, proposal payloads, and bundles, and each carry
the corresponding construct (coinciding with their attached data type field).

% --------------------------------------------------------------------
\begin{subsection}{Block Proposal}\label{ssect:blockproposal}

    \begin{algorithm}
        \begin{algorithmic}[1]
        \Function{$\mathsf{BlockProposal}$}{}

            \State $\mathsf{ResynchronizationAttempt}()$

            \State $e \gets \mathsf{AssembleBlock}()$

            \For{$a \in A$}
                \State $cred \gets 
                \mathsf{Sortition}(a, proposal)$
                \If{$cred.j > 0$}
                    \If{$p = 0 \lor \exists s^\prime \textfractionsolidus Bundle(r, p-1, s^\prime, \bot) \subset V$}
                        \State $v \gets Proposal_{value}(e)$
                        \State $\mathsf{Broadcast}(Vote(a.I, r, p, proposal, v, cred))$
                        \State $\mathsf{Broadcast}(e)$
                    \Else
                        %VER. Convencerme de que siempre es el pinned value
                        %\State $v \gets v_0 \textfractionsolidus \exists s, Bundle(r,p-1,s,v_0) \subset V$
                        \State $\mathsf{Broadcast}(Vote(a.I, r, p, proposal, \bar{v}, cred))$
                        \If{$Proposal(\bar{v}) \in P$}
                            \State $\mathsf{Broadcast}(Proposal(\bar{v}))$
                            % proposal(\bar v) es un broadcast de un e 
                        \EndIf
                    \EndIf
                \EndIf
            \EndFor
        \EndFunction
        \end{algorithmic}
        \caption{\underline{Block proposal}}
    \end{algorithm}

\newpage
% porposal = s
\noindent \textbf{Description:}\\
Block proposal is the first step, and the starting stage of the algorithm on every period.
First, on line 2, the node attempts a resynchronization (described in \ref{sect:soubroutines}). 
This only has any effect on periods $p > 0$. On line 3, a block is assembled.
Afterwards, the node loops through all of its managed online accounts, Functionally
"playing" for each of the accounts. This is a pattern that we'll see in every other
main algorithm subroutine that performs any form of committee voting.

Lines 7 to 15 are the core proposal algorithm. On lines 7 to 10, 
if the node's on a first period, or it observed a bundle for the bottom proposal on the previous 
period (meaning there is no valid pinned value), then it will compute the proposal-value for the 
previously assembled block, broadcast a proposal vote by the selected account for this value, and 
broadcast the full block in a proposal payload message.
Otherwise, the node is at least on a second period and it has a pinned value available, supported by a 
bundle observed in the period immediately before, being the observation of this bundle the event to trigger 
a period change in the first place. On line 12 the node gets this value explicitly, which coincides with the pinned
value $\bar{v}$. 
%P*? CAN the pinned value at this stage, by some manipulation of equivocation votes, not be unique? meaning there
%is more than one full bundle for the past period.
Then, for every account selected, a proposal vote for this pinned value is broadcast. Afterwards, 
if the corresponding full proposal has been observed, then it is also broadcast.


\end{subsection}
% ---------------------------------------------------------------------------------------------------
\begin{subsection}{Soft Vote}\label{ssect:softvote}

\begin{algorithm}[H]
    \begin{algorithmic}[1]
    \Function{$\mathsf{SoftVote}$}{}
    \State $lowestObservedHash \gets \infty$
    \State $v \gets \bot$ 


    \For{$vt \in V \textfractionsolidus vote.step = proposal$}
        \State $priorityHash \gets \min_{i \in [0, vote.cred.j)} \{ \mathsf{H}(vt.cred.sh || i)\}$
        \If{$priorityHash < lowestObservedHash$}
            \State $lowestObservedHash \gets priorityHash$
            \State $v \gets vt.v$
        \EndIf    
    \EndFor

    \If {$lowestObservedHash < \infty$}
        \For{$Account \ a \in A$}
            \State $cred \gets \mathsf{Sortition}(a, soft)$
            \If{$cred.j > 0$}
                \State $\mathsf{Broadcast}(Vote(r, p, soft, v, cred))$
                \If{$Proposal(v) \in P$}
                    \State $\mathsf{Broadcast}(Proposal(v))$
                \EndIf
            \EndIf
        \EndFor
    \EndIf

    \EndFunction
    \end{algorithmic}
    \caption{\underline{Soft Vote}}
\end{algorithm}

\noindent \textbf{Description:}\\
The soft vote stage (also known as "filtering") is run after a timeout of $FilterTimeout(p)$
(where $p$ is the node's currently executing period) is observed by the node. That is to say, filtering
is triggered after either a $2\lambda_0$ or $2\lambda$ timeout is observed according to whether $p=0$ or $p>0$ respectively.
Let $V*$ be all proposal votes received. By a priority hash function, this stage performas a filtering action,
keeping the lowest hashed value observed.
The priority function (lines 4 to 8) should be interpreted as follows. Consider every proposal vote $vt$ in $V*$.
Given the sortition hash $sh$ output by the $\mathsf{VRF}$ for the proposer account, and for each sub-user unit $i$ 
in the interval from $0$ (inclusive) to the vote weight (exclusive; the $j$ output of $\mathsf{Sortition}()$ inside 
the $cred$ credentials structure), the node hashes the concatenation of $sh$ and $i$, $\mathsf{H}(sh||i)$ 
(where $\mathsf{H}()$ is the node's general cryptographic hashing function). On lines 6 to 8, 
then, it keeps track of the proposal-value that minimizes this concatenation and subsequent hashing procedure.
After running the filtering algorithm for all proposal votes observed, and assuming there was at least one vote
in $V*$, the broadcasting section of the filtering algorithm is executed (lines 9 to 15).
For every online managed account selected to be part of the $soft$ voting committee, a $soft$ vote is
broadcast for the previously found filtered value $v$. If the full proposal has been observed and is available in $P$,
it is also broadcast. 
If the previous assumption of non-empty $V*$ does not hold, no broadcasting is performed and the node produces no
output in its filtering step.

\end{subsection}

% --------------------------------------------------------------------

\begin{subsection}{HandleProposal}\label{ssect:HandleProposal}

    \begin{algorithm}[H]
        \begin{algorithmic}[1]
        \Function{$\mathsf{HandleProposal}$}{$Proposal \ e$}

            \State $v \gets Proposal_{value}(e)$

            %relays proposal if its for a future round (but does not process it)
            \If{$\sigma(r+1, 0) = v$}
                \State $\mathsf{Relay}(e)$
                \State $\mathsf{return}$  //do not observe, as it's for a future round (we're behind)
            \EndIf

            %ignores proposal if it's invalid or if it has already been observed
            \If{$\lnot \mathsf{VerifyProposal}(e) \lor e \in P$ }
                \State $\mathsf{return}$  //ignore proposal
            \EndIf

            %ignores proposal if its proposal value is not either 
            %the current sigma, the pinned value or the current mu
            \If{$v \notin \{ \sigma(r,p), \bar{v}, \mu(r,p)\}$}
                \State $\mathsf{return}$ //ignore proposal
            \EndIf

            %we need to relay (broadcast to everybody but ourselves and o.g. sender), and observe p
            \State $\mathsf{Relay}(e)$
            \State $P \gets P \cup e$

            %all checks passsed, produce output
            \If{$\mathsf{IsCommitable}(v) \land s \leq cert$}
                \For{$a \in A$}
                    \State $cred \gets 
                    \mathsf{Sortition}(a, cert)$
                    \If{$cred.j > 0$}
                        \State $\mathsf{Broadcast}(Vote(a.I, r, p, cert, v,  cred))$
                    \EndIf
                \EndFor    
            \EndIf

        \EndFunction
        \end{algorithmic}
        \caption{\underline{HandleProposal}}
    \end{algorithm}
    
    
    \noindent \textbf{Description:}\\
The proposal handler is triggered when a node receives a message containing a full proposal.
It starts by performing a series of checks, after which it will either ignore the received
proposal, discarding it and emitting no output; or relay, observe and produce an output
according to the proposal's characteristics and the current context.
The first check (lines 3 to 5) is a special case, where if the proposal is from the next round's 
first period, the node relays it and then ignores it for the purpose of the current round. 
Whenever the node catches up (observes a round change), and only if necessary, it will request 
this proposal back from the network.
Lines 6 and 7 check if the proposal is invalid, or if it has been observed already. Any one of those
conditions are sufficient to discard and ignore the proposal.
Finally, on lines 8 and 9 it checks if the associated proposal value is either of the special values for the current
round and period ($\sigma$, $\mu$, or the pinned proposal value $\bar{v}$). Any proposal whose proposal value does not match
one of these is ignored.
Once the checks have been surpassed, the node is ready to relay the proposal and observe it by adding
it to the observed proposals set, $P$ (lines 10 and 11).
Once relayed and observed, the proposal is then processed for further output.
Here, and only if the proposal value has become commitable and the current executing node's step is lower or equal
to a certification step (it's not yet in a recovery step), the node plays for each account performing sortition
to select committee members for the certification step. For each selected member, a corresponding certify vote for
the current proposal value is cast.


\end{subsection}

% --------------------------------------------------------------------

\begin{subsection}{HandleVote}\label{ssect:HandleVote}

    \begin{algorithm}[H]
        \begin{algorithmic}[1]
        \Function{$HandleVote$}{$Vote \ vt$}

            % //P*? como funciona la penalizacion del jugador en este caso (funcion PenalizePeer())?
            
            % //P*? que pasa si vt.round $>$ r+1? Crash? Hay algun mecanismo de bootstrapping a ese punto?
            
            % //P*? cómo funciona la operación de relay? Sólo reenvía, o es un broadcast?
            
            % //P*? cómo funciona internamente el request for proposal?

            % //P*? si el voto es repetido, el nodo lo ignora verdad? Esto no esta especificado asi, pero es quizas un error?
            % \\

            \If{$\lnot \mathsf{VerifyVote}(vt)$}
                \State $\mathsf{PenalizePeer}(SENDER\_PEER(vt))$ \ //optional
                \State $\mathsf{return}$ \ //ignore invalid vote
            \EndIf

            \If{$vt.step = 0 \land (vt \in V \lor \mathsf{IsEquivocation}(vt))$}
                \State $\mathsf{return}$ \ //ignore vote, equivocation not allowed in proposal votes
            \EndIf

            \If{$vt.step > 0 \land \mathsf{IsSecondEquivocation}(vt) $}
                \State $\mathsf{return}$ \ //ignore vote if it's a second equivocation
            \EndIf

            \If{$vt.round < r $}
                \State $\mathsf{return}$ \ //ignore vote of past round
            \EndIf

            \If{$vt.round = r+1 \land (vt.period > 0 \lor vt.step \in (cert, late))$}
                \State $\mathsf{return}$ \ //ignore vote of next round if non-zero period or $next_k$ step
            \EndIf

            \If{$vt.round = r \land (vt.period \notin [p-1, p+1] \lor$ \\
            $(vt.period = p+1 \land vt.step \in (next_0, late)) \lor$ \\
            $(vt.period = p \land vt.step \in (next_0, late) \land vt.step \notin [s-1, s+1]) \lor$ \\
            $(vt.period = p-1 \land vt.step \in (next_0, late) \land vt.step \notin [\bar{s}-1, \bar{s}+1]))$}
                \State $return$ \ //ignore vote
            \EndIf

            \State $V \gets V \cup vt$ \ //observe vote
            \State $\mathsf{Relay}(vt)$

            \If{$vt.step = proposal$}
                \If{$Proposal(vt.v) \in P$}
                    %P*? Que onda el sortition aca?
                    \State $\mathsf{Broadcast}(Proposal(vt.v))$
                \EndIf
            \ElsIf{$vt.step = soft$}
                %check if soft bundle has been achieved
                \If{$\exists v | Bundle(vt.round,vt.period,soft,v) \subset V$}
                    %Try to emit a certification vote
                    \For{$a \in A$}
                        \State $cred \gets 
                        \mathsf{Sortition}(a_{sk}, cert)$
                        \If{$cred.j > 0$}
                            \State $\mathsf{Broadcast}(Vote(a.I, r, p, cert, v, cred))$
                        \EndIf
                    \EndFor
                \EndIf
            \ElsIf{$vt.step = cert$}
                %check if cert bundle has been achieved
                \If{$\exists v | Bundle(vt.round,vt.period,cert,v) \subset V$}
                    \If{$Proposal(v) \notin P$}
                        \State $\mathsf{RequestProposal}(v)$ //waits or keeps playing without voting power
                    \EndIf
                    \State $\mathsf{Commit}(v)$  %ver que pasa si no se pudiera commitear
                    \State $r_{old} \gets r$
                    \State $\mathsf{StartNewRound}(vt.round+1)$
                    \State $\mathsf{GarbageCollect}(r_{old}, p)$
                \EndIf
            \ElsIf{$vt.step > cert$}
                \If{$\exists v | Bundle(vt.round,vt.period,vt.step,v) \subset V$}
                    \State $p_{old} \gets p$
                    \State $\mathsf{StartNewPeriod}(vt.period)$
                    \State $\mathsf{GarbageCollect}(r, p_{old})$
                \EndIf
            \EndIf

        \EndFunction
        \end{algorithmic}
        \caption{\underline{HandleVote}}
    \end{algorithm}
    
    
    \noindent \textbf{Description:}\\
The vote handler is triggered when a node receives a message containing a vote for a given proposal value, round, period and step.
It first performs a series of checks, and if the received vote passes all of them, then it's broadcast by all accounts selected
as the appropriate committee members.
On line 2, it checks if the vote is valid by itself. If invalid, the node can optionally penalize the sender of the vote
(by disconnecting or blacklisting it, for example).
Equivocation votes on a proposal step are not allowed, so a check for this condition is performed on line 5.
Furthermore, second equivocations are never allowed (line 7).
Any votes for rounds prior to the current round are discarded (line 9).
On the special case that we received a vote for a round immediately after the current round, we observe it only if its a first period,
proposal, soft, cert, late, down or redo vote (discarding votes for further periods or votes for a $next_k$ step).
Finally, the checks on lines 13 to 16 check that, if the vote's round is the currently executing round, and one of:
\begin{itemize}
    \item vote's period is not a distance of one or less away from the node's current period,
    \item vote's period is the next period, but its step is $next_{k}$ with $k \geq 1$,
    \item vote's period is the current period, its step is $next_{k}$ with $k \geq 1$, 
and its step is not within a distance of one away from the currently observed node's step, or
    \item vote's period is one behind the current period, its step is $next_{k}$ with $k \geq 1$, and
its step is not within a distance of one away from the node's last finished step,
\end{itemize}
then the vote is ignored and discarded. \\
Once finished with the series of validation checks, the vote is observed on line 18, relayed on line 19, and then processed.
The node will determine the desired output according to its current context and the vote's step.
If the vote's step is $proposal$, the corresponding proposal for the proposal-value $v$, $Proposal(v)$ is broadcast if it has been observed 
(that is, the player performs a reproposal payload broadcast).
If the vote's step is $soft$ (lines 19 through 24), and a $soft$ Bundle has been observed with the addition of the vote on line 19,
the $Sortition$ subprocedure is run for every account managed by the node (line 23). Afterwards, for each account selected by
the lottery, a $cert$ vote is cast as output (line 25).
If the vote's step is $cert$ (lines 26 through 32), and observing the vote causes the node to observe a $cert$ Bundle for a proposal-value $v$,
then it checks if the full proposal associated to the critical value has been observed (line 28). Note that simultaneous observation of a $cert$ Bundle 
for a value $v$ and of a proposal $e = Proposal(v)$ implies commitability of the associated entry.
Had the full proposal not been observed at this point, the node may stall and request the full proposal from the network.
Once the desired block is commitable, on lines 30:32 the node proceeds to commit, start a new round, and garbage collect all
transient data from the round it just finished.
Finally, if the vote is that of a recovery step (lines 33:36), and a Bundle has been observed for a given proposal-value $v$,
then a new period is started and the currently executing period-specific data garbage collected.



\end{subsection}

% --------------------------------------------------------------------

\begin{subsection}{HandleBundle}\label{ssect:HandleBundle}

    \begin{algorithm}[H]
        \begin{algorithmic}[1]
        \Function{$\mathsf{HandleBundle}$}{$Bundle \ b$}

            % //P*? "Ignores* it if Bundle(r, p, s, v) is invalid." Esta linea esta mal no? en specs. Deberia ser rk, pk, sk

            % //P*? "If there exists a vote which causes the player to observe some bundle Bundle(rk, pk, sk, $v´$) for some sk..."
            % should probably be for some $v´$

            \If{$\neg \mathsf{VerifyBundle}(b)$}
                \State $\mathsf{PenalizePeer}(\mathsf{SENDER\_PEER}(b))$ \ //optional
                \State $\mathsf{return}$
            \EndIf

            \If{$b.r = r \land b.p + 1 \geq p$}
                \For{$vt \in b$}
                    \State $\mathsf{HandleVote}(vt)$
                \EndFor
            \EndIf

            %El relaying del bundle en esta implementación queda implícito, pero como relayeamos cada voto, en teoría si observamos
            %un bundle estamos relay-eando ese bundle voto a voto

        \EndFunction
        \end{algorithmic}
        \caption{\underline{HandleBundle}}
    \end{algorithm}
    
    
    \noindent \textbf{Description:}\\
The bundle handler is invoked whenever a bundle message is received. 
If the received bundle is invalid (line 2), its immediately discarded. Optionally, the node may
penalize the sending peer (for example, disconnecting from or blacklisting it).
On line 5 a check is performed. If the bundle's round is the node's current round
and it's at most one period behind of the node's current period, 
then the bundle is processed, which is simply calling the vote handler for each 
vote constituting it (lines 6:7). If the check on line 5 is not passed by $b$, no output is produced
and the bundle is ignored and discarded.
Note that handling each vote separately, if a bundle $b\prime = Bundle(b.r, b.p, b.s, v\prime)$ is observed
(where $v\prime$ is not necessarily equal to $\b.v$, consider $b$ may contain equivocation votes), then it will be relayed
as each vote was relayed individually, and any output or state changes it produces will be made. All leftover votes 
in $b$ will be processed according to the new state the node is in, e.g. being discarded if $b.r < r$.
    
\end{subsection}

% --------------------------------------------------------------------

\begin{subsection}{Recovery Attempt}\label{ssect:Recovery}

    \begin{algorithm}[H]
        \begin{algorithmic}[1]
        \Function{$\mathsf{Recovery}$}{$uint64 \ k$}

        \State $\mathsf{ResynchronizationAttempt}()$
        \State $s \gets next_k$
    
        \For{$Account \ a \in A$}
            \State $cred \gets 
            \mathsf{\mathsf{Sortition}}(a_{sk}, next_k)$
            \If{$cred.j > 0$}
                \If{$\exists v | \mathsf{IsCommitable}(v)$}
                    \State $\mathsf{Broadcast}(Vote(a.I, r, p, next_k, v, cred))$
                \ElsIf{$\nexists s_0 > cert | Bundle(r, p - 1, s_0, \bot) \subseteq V \wedge$ \newline 
                ${}$ ${\hskip 2.65cm} \exists s_1 > cert | Bundle(r, p - 1, s_1, \bar{v}) \subseteq V$}
                    \State $\mathsf{Broadcast}(Vote(a.I, r, p, next_k, \bar{v}, cred))$
                \Else
                    \State $\mathsf{Broadcast}(Vote(a.I, r, p, next_k, \bot, cred))$
                \EndIf
            \EndIf
        \EndFor


        \EndFunction
        \end{algorithmic}
        \caption{\underline{Recovery}}
    \end{algorithm}
    
    
    \noindent \textbf{Description:}\\
The recovery algorithm that is executed periodically every X seconds, 
whenever a $cert$ bundle has not been observed before $\mathsf{FilterTimeout}(p)$ for a given period $p$. \\
On line 2 it starts by making a resynchronization attempt. Then on line 3 the node's step is updated.\\
Afterwards, the node plays for each managed account. For each account that is selected to be a part of the voting committee for the current
step $next_k$, one of three different outputs is produced. \\
If there is a proposal-value $v$ that is commitable in the current context, a $next_k$ vote for $v$ is broadcast by the player. \\
If no proposal-value is commitable, no recovery step Bundle for the empty proposal-value ($\bot$) was observed in the 
previous period, and a recovery step Bundle for the pinned value was observed in the previous period (note that this implies $\bar{v} \neq \bot$),
then a $next_k$ vote for $\bar{v}$ is broadcast by the player. \\
Finally, if none of the above conditions were met, a $next_k$ vote for $\bot$ is broadcast. A player is forbidden
from equivocating in $next$ votes.

\end{subsection}


% --------------------------------------------------------------------
\begin{subsection}{Fast Recovery Attempt}\label{ssect:FastRecovery}

    \begin{algorithm}[H]
        \begin{algorithmic}[1]
        \Function{$FastRecovery$}{}

        %P*? Como se maneja el step number aca? y el bar_step?

        \State $\mathsf{ResynchronizationAttempt}()$
    
        \For{$Account \ a \in A$}
            \If{$\mathsf{IsCommitable}(v)$}
                \State $cred \gets 
                \mathsf{Sortition}(a_{sk}, late)$
                \If{$cred.j > 0$}
                    \State $\mathsf{Broadcast}(Vote(a.I, r, p, late, v, cred))$
                \EndIf

            \ElsIf{$\nexists s_0 > cert | Bundle(r, p - 1, s_0, \bot) \subseteq V \wedge$ \newline 
                ${}$ ${\hskip 2.1cm} \exists s_1 > cert | Bundle(r, p - 1, s_1, \bar{v}) \subseteq V$}
                    \State $cred \gets 
                    \mathsf{Sortition}(a_{sk}, redo)$
                    \If{$cred.j > 0$}
                        \State $\mathsf{Broadcast}(Vote(r,p,redo,\bar{v}, cred))$
                    \EndIf

            \Else
                \State $cred \gets 
                \mathsf{Sortition}(a_{sk}, down)$
                \If{$cred.j > 0$}
                    \State $\mathsf{Broadcast}(Vote(r,p,down,\bot, cred))$
                \EndIf
            \EndIf
        \EndFor

        \EndFunction
        \end{algorithmic}
        \caption{\underline{FastRecovery}}
    \end{algorithm}
    
    
    \noindent \textbf{Description:}\\
    The fast recovery algorithm is executed periodically every integer multiple of $\lambda_f$
    seconds (plus variance).
    Functionally, it's very close to the regular recovery algorithm (outlined in the previous section), 
    performing the same checks and similar outputs. The sole difference is that it emmits votes 
    for any of three different steps ($late$, $redo$ and $down$) according to sortition 
    results for every account.
    It's also important to point out that nodes are forbidden to equivocate for $late$, $redo$ and $down$ votes.
\end{subsection}


% ------------------------------------------------------------------------------------
\end{section}
% ------------------------------------------------------------------------------------
% ------------------------------------------------------------------------------------
\begin{section}{Subroutines}\label{sect:soubroutines}

% ----------------------------------------------------------------------------------------------

\begin{algorithm}[H]
    \begin{algorithmic}[1]
    \Function{$\mathsf{FilterTimeout}$}{$uint64 \ p$}
        \If{$p = 0$}
            \State $\mathsf{return} \ 2\lambda_0$
        \Else 
            \State $\mathsf{return} \ 2\lambda$
        \EndIf
    \EndFunction
    \end{algorithmic}
    \caption{\underline{FilterTimeout}}
\end{algorithm}

\noindent \textbf{Arguments:}
\begin{itemize}
    \item $uint64 \ p$ is a period number
  \end{itemize}

\noindent \textbf{Description:}\\
Provides the timeout constant for the filtering (a.k.a. "soft" or "soft vote") stage.
This timeout depends on the period value; the first period has a special, faster timeout.
If no consensus was achieved, this timeout constant is relaxed in all subsequent periods. \\

\noindent \textbf{Returns:}
\begin{itemize}
    \item The time constant used to trigger the filtering stage (according to whether the given
    period $p$ is the first period of the current round or not)
  \end{itemize}

% ----------------------------------------------------------------------------------------------

\begin{algorithm}[H]
    \begin{algorithmic}[1]
    \Function{$\mathsf{H}$}{$Hashable \ in$}
        \If{$SHA512/256 \ is \ supported$}
            \State $\mathsf{return SHA512/256}(in)$
        \Else
            \State $\mathsf{return SHA256}(in)$
        \EndIf
    \EndFunction
    \end{algorithmic}
    \caption{\underline{General Purpose Hashing Function}}
\end{algorithm}

\noindent \textbf{Arguments:}
\begin{itemize}
    \item $Hashable \ in$ = some hashable data (plain bytes)
  \end{itemize}

\noindent \textbf{Description:}\\
General purpose hashing function. If $SHA512/256$ is supported by the underlying system running the node, it's used.
Otherwise falls back to $SHA256$.\\

\noindent \textbf{Returns:}
\begin{itemize}
    \item The result of hashing the input $in$ with the selected algorithm based on underlying system support
  \end{itemize}

% ----------------------------------------------------------------------------------------------

\begin{algorithm}[H]
    \begin{algorithmic}[1]
    \Function{$\mathsf{AssembleBlock}$}{}

    \State $Block b$
    \State $b.body \gets TP[-s]$

    \EndFunction
    \end{algorithmic}
    \caption{\underline{AssembleBlock}}
\end{algorithm}

\noindent \textbf{Description:}\\
Gets a set of transactions out of the transaction pool (prioritizing highest transaction fee if there were any).
Then, assembles a full ledger entry, setting all of the appropriate fields in a block.

% ----------------------------------------------------------------------------------------------

\begin{algorithm}[H]
    \begin{algorithmic}[1]
    \Function{$\mathsf{IsCommitable}$}{$Proposal_{value} \ v$}

    \State $\mathsf{return} \ Proposal(v) \in P \land Bundle(r,p,soft,v) \subset V$

    \EndFunction
    \end{algorithmic}
    \caption{\underline{IsCommitable}}
\end{algorithm}


\noindent \textbf{Arguments:}
\begin{itemize}
    \item $Proposal_{value} \ v$, a value to check for commitability
  \end{itemize}

\noindent \textbf{Description:}\\
Checks that the value $v$ is commitable in the current node's context.
To be commitable, the two conditions outlined in line 2 have to be met.
That is, the corresponding proposal that the value refers to has to be
available (have been observed in the current round), and there must
be a valid bundle of soft votes for $v$ observed during the current round and
period. \\

\noindent \textbf{Returns:}
\begin{itemize}
    \item A boolean value indicating commitability of the argument $v$
  \end{itemize}

% ----------------------------------------------------------------------------------------------

\begin{algorithm}[H]
    \begin{algorithmic}[1]
    \Function{$\mathsf{Commit}$}{$Proposal_{value} \ v$}

    \State $L \gets L || Proposal(v)$
    \State $UpdateBT(Proposal(v))$

    \EndFunction
    \end{algorithmic}
    \caption{\underline{Commit}}
\end{algorithm}


\noindent \textbf{Arguments:}
\begin{itemize}
    \item $Proposal_{value} \ v$, a proposal-value to be commited
  \end{itemize}

\noindent \textbf{Description:}\\
Commits the corresponding proposal for the value passed by parameter into the ledger.
As a precondition, the value is commitable (which implies validity and availability of the full
ledger entry and seed).
Afterwards, updates the balance table with all state changes called for in the commited entry.

% ----------------------------------------------------------------------------------------------

\begin{algorithm}[H]
    \begin{algorithmic}[1]
    \Function{$\mathsf{VerifyVote}$}{$Vote \ vt$}
        \State $valid \gets vt.round \leq r+2$
        
        \If{$vt.step = 0$}
            \State $valid \gets valid \land vt.v.p_{orig} \leq vt.period$
            \If{$vt.period = vt.v.p_{orig}$}
                \State $valid \gets valid \land vt.v.I_{orig} = vt.I$
            \EndIf
        \EndIf
        
        \If{$vt.step \in \{propose, soft, cert, late, redo\}$}
            \State $valid \gets valid \land vt.v \neq \bot$
        \ElsIf{$vt.step = down$}
            \State $valid \gets valid \land vt.v = \bot$
        \EndIf

        //TODO: verificacion de firmas, VRFs y rounds de validez

        \State $\mathsf{return} \ valid$
    \EndFunction
    \end{algorithmic}
    \caption{\underline{VerifyVote}}
\end{algorithm}

\noindent \textbf{Description:}\\

% ----------------------------------------------------------------------------------------------

\begin{algorithm}[H]
    \begin{algorithmic}[1]
    \Function{$\mathsf{Proposal}$}{$Proposal_{value} \ v$}

    \If{$\exists e \in P | Proposal_{value}(e) = v$}
        
    \EndIf

    \EndFunction
    \end{algorithmic}
    \caption{\underline{Proposal}}
\end{algorithm}

\noindent \textbf{Description:}\\ Gets the proposal associated to a given value, if it has been observed.
Otherwise returns undefined. Here we ignore the theoretical posibility of a collision

% ----------------------------------------------------------------------------------------------

\begin{algorithm}[H]
    \begin{algorithmic}[1]
    \Function{$\mathsf{Proposal_{value}}$}{$Proposal \ e$}

    //pack and hash
    \State $proposal_{value} v \gets (I, p, \mathsf{H}(e), \mathsf{H}(Encoding(e)))$

    \State $\mathsf{return} \ v$

    \EndFunction
    \end{algorithmic}
    \caption{\underline{Proposal-value}}
\end{algorithm}

\noindent \textbf{Description:}\\ 

% ----------------------------------------------------------------------------------------------

\begin{algorithm}[H]
    \begin{algorithmic}[1]
    \Function{$\mathsf{VerifyProposal}$}{$ProposalPayload \ pp$}

    \State $valid \gets \mathsf{ValidEntry}(pp.e, L)$
    \State $valid \gets valid \land \mathsf{VerifySignature}(pp.y)$

    \EndFunction
    \end{algorithmic}
    \caption{\underline{VerifyProposal}}
\end{algorithm}

\noindent \textbf{Description:}\\

% ----------------------------------------------------------------------------------------------

\begin{algorithm}[H]
    \begin{algorithmic}[1]
    \Function{$\mathsf{VerifyBundle}$}{$Bundle \ b$}

    //all individual votes are valid
    \State $valid \gets (\forall vt \in b)(VerifyVote(vt))$
    
    //no two votes are the same
    \State $valid \gets valid \land (\forall i,k \in \mathbb{Z})(vt_i \in b \land vt_k \in b \land vt_i = vt_k \implies i=k)$

    //round, period and step must all match
    \State $valid \gets valid \land (\forall vt \in b)(vt.r = b.r \land vt.p = b.p \land vt.s = b.s)$
  
    %P*? Equivocation vote solo vale para soft bundles. Eso es correcto?
    //all votes should either be for the same value or be equivocation votes
    \State $valid \gets valid \land (\forall vt \in b)(vt.v = b.v \lor (b.s = soft \land IsEquivocation(vt.v, b)))$

    //summation of weights should surpass the relevant threshold
    \State $valid \gets valid \land  \sum_{vt \in b}(vt.w) \geq CommitteeThreshold(b.s)$

    \State $\mathsf{return} \ valid$

    \EndFunction
    \end{algorithmic}
    \caption{\underline{VerifyBundle}}
\end{algorithm}

\noindent \textbf{Description:}\\


% ----------------------------------------------------------------------------------------------

\begin{algorithm}[H]
    \begin{algorithmic}[1]
    \Function{$\mathsf{StartNewRound}$}{$uint64 \ newRound$}

    \State $\bar{s} \gets s$
    \State $\bar{v} \gets \bot$
    \State $r \gets newRound$
    \State $p \gets 0$
    \State $s \gets proposal$

    \EndFunction
    \end{algorithmic}
    \caption{\underline{StartNewRound}}
\end{algorithm}

\noindent \textbf{Description:}\\
Procedure used to set all state variables necessary to start a new round.
Last finished step is set to the step where the previous round culminated.
Pinned proposal-value is set to the empty proposal-value as the round is just starting.
The current round number gets updated to the freshly started round.
Period and step number are set to $0$ and $proposal$ respectively.

% ----------------------------------------------------------------------------------------------

\begin{algorithm}[H]
    \begin{algorithmic}[1]
    \Function{$\mathsf{StartNewPeriod}$}{$uint64 \ newPeriod$}

    \State $\bar{s} \gets s$
    \State $s \gets proposal$

    \If{$\exists v,s^\prime \ | \ v \neq \bot \land (s^\prime = soft \lor s^\prime > cert)  
    \land Bundle(r, newPeriod-1, s, v) \subset V$}
        \State $\bar{v} \gets v$
    \ElsIf{$\sigma(r,p) \neq \bot$}
        \State $\bar{v} \gets \sigma(r,p)$
    \EndIf

    \State $p \gets newPeriod$

    \EndFunction
    \end{algorithmic}
    \caption{\underline{StartNewPeriod}}
\end{algorithm}

\noindent \textbf{Description:}\\
Procedure used to set all state variables necessary to start a new period.
Note that we start a new period on observing a recovery bundle for a proposal-value, whether it be
an actual value or the special empty value $\bot$.
On lines 2 and 3, the node sets the last finished step to the currently executing step when a new period's
start was observed, and the current step to $proposal$.
Then it checks for the existance of a non-$cert$ step bundle in the period immediately before the new one (line 4), 
for a proposal-value that's anything but the empty value $\bot$ (note that if the node had observed a $cert$
bundle in the previous period, it would not be starting a new period and it would be instead attempting to commit
the relevant entry and subsequently start a new round). If such bundle for a proposal-value $v$ exists, the pinned 
value is updated to $v$.
Otherwise, and assuming implicitly in this case that the bundle that caused the period switch is of value $\bot$,
a check for the special $\sigma(r,p)$ value is performed on line 6, where $p$ is the period that was being executed 
by the node up until a new period was observed. If $\sigma(r,p)$ is a valid non-empty proposal-value, the pinned 
value $\bar{v}$ is set to this (line 7).
Finally, if none of the above conditions were met, the pinned value remains unchanged going into the new period.
Finally, the node updates $p$ to match the period to start.

% ----------------------------------------------------------------------------------------------

\begin{algorithm}[H]
    \begin{algorithmic}[1]
    \Function{$\mathsf{GarbageCollect}$}{$r, p$}

    \State $V_{(r,p-1)} \gets \{ vt \in V | vt.r < r \lor (vt.r=r \land vt.p + 1 < p) \}$
    \State $P_{(r,p-1)} \gets \{ pp \in P | pp.r < r \lor (pp.r=r \land pp.p + 1 < p) \}$

    \State $V \gets V\diagdown V_{(r,p-1)}$
    \State $P \gets P\diagdown P_{(r,p-1)}$

    \EndFunction
    \end{algorithmic}
    \caption{\underline{GarbageCollect}}
\end{algorithm}

\noindent \textbf{Description:}\\
Garbage collection algorithm, for the finished $(r,p)$ context.
The procedure discards all votes in $V$ and proposals in $P$ where the round of emmision is less than the
new round, or the round of emmision is equal to the new round and the period of emmision is below the period
directly before the current one.

% ----------------------------------------------------------------------------------------------

\begin{algorithm}[H]
    \begin{algorithmic}[1]
    \Function{$\mathsf{RequestProposal}$}{$Proposal_{value} \ v$}
        //ver como hacer el request...como lo resuelve el nodo?
    \EndFunction
    \end{algorithmic}
    \caption{\underline{RequestProposal}}
\end{algorithm}

\noindent \textbf{Description:}\\

% ----------------------------------------------------------------------------------------------

\begin{algorithm}[H]
    \begin{algorithmic}[1]
    \Function{$\mathsf{PenalizePeer}$}{$PEER\_NETWORK\_ID$}
        //ver como resuelve el nodo la desconexion o blacklist de un peer
    \EndFunction
    \end{algorithmic}
    \caption{\underline{PenalizePeer}}
\end{algorithm}

\noindent \textbf{Description:}\\

% ----------------------------------------------------------------------------------------------

\begin{algorithm}[H]
    \begin{algorithmic}[1]
    \Function{$\mathsf{ResynchronizationAttempt}$}{}

    %P*? Sortition aca? deberia correrlo? no es claro como funcionaria aca

    \State $Val = \bot$

    \If{$\exists v | Bundle(r, p, soft, v) \subset V$}
        \State $\mathsf{Broadcast}(Bundle(r, p, soft, v))$
        \State $val = v$    
    \ElsIf{$\exists s_0 > cert | Bundle(r, p - 1, s_0, \bot) \subset V$}
        \State $\mathsf{Broadcast}(Bundle(r, p - 1, s_0, \bot))$
    \ElsIf{$\exists s_0, v | s_0 > cert \land v \neq \bot \land Bundle(r, p - 1, s_0, v) \subset V$}
        \State $\mathsf{Broadcast}(Bundle(r, p, s_0, v))$
        \State $val = v$
    \EndIf

    \If{$val \neq \bot \land Proposal(v) \in P$}
        \State $\mathsf{Broadcast}(Proposal(v))$
    \EndIf

    \EndFunction
    \end{algorithmic}
    \caption{\underline{ResynchronizationAttempt}}
\end{algorithm}

\noindent \textbf{Description:}\\
A resynchronization attempt, performed at the start of all recovery algorithms.
If a soft bundle has been observed for a proposal-value $v$, then the bundle is broadcast.
Otherwise, if a recovery step bundle for an empty proposal-value $\bot$ was observed in the previous period,
It's broadcast.
Else, if there is a recovery step $s_0$ and a non-empty proposal-value $v$ for which a bundle was observed in the previous
period, it's broadcast.
Finally, if any Bundles were broadcast for a proposal-value $v$, the corresponding proposal $Proposal(v)$ is broadcast
if it has been observed.

% ----------------------------------------------------------------------------------------------

\begin{algorithm}[H]
    \begin{algorithmic}[1]
    \Function{$ComputeSeed$}{$b$}
        \If{$B \neq empty\_block$} 
            \State $\mathsf{return} \ VRF_{get_{SK_a}(ctx, r)}(ctx.LastBlock.seed||r$)
        \Else
            \State $\mathsf{return} \ \mathsf{Hash}(ctx.LastBlock.seed||r)$
        \EndIf
    \EndFunction
    \end{algorithmic}
    \caption{\underline{ComputeSeed}}
\end{algorithm}


\noindent \textbf{Arguments:}
\begin{itemize}
    \item $b$ = the block whose seed is being computed
  \end{itemize}


\noindent \textbf{Description:}\\
This subroutine computes the required sortition seed for the given round number, 
which goes in the proposed block's metadata.
If the block is empty, the seed is a hash of the previous block's seed.
The $get_{SK_a}(ctx, r)$ helper function gets the relevant account's secret ephemeral keys (according to the signing scheme described in specs, the keys 160 rounds prior to $r$).
This roughly corresponds to the secret key from a round $b$ time before block $r-1-(r\;mod\;R)$, where $R$ is the sortition seed's renewal rate, $r$ is the current round's number,
and $b$ is the upper bound for the maximum ammount of time that the network might be compromised.\\

\noindent \textbf{Returns:}
\begin{itemize}
    \item the computed seed for the given block, ledger context and round
  \end{itemize}

% ----------------------------------------------------------------------------------------------

\begin{algorithm}[H]
    \begin{algorithmic}[1]
        \Function{$getSortitionSeed$}{$ctx, r, a_{pk}$}
        
            $\Return\;ctx.block[r-1-(r\;mod\;R)].seed$

        \EndFunction
    \end{algorithmic}
    \caption{\underline{getSortitionSeed}}
\end{algorithm}

\noindent \textbf{Arguments:}
\begin{itemize}
    \item $ctx$ = a helper structure to retrieve ledger context information (e.g. the last confirmed block)
    \item $round$ = current round number
    \item $a_{pk}$ = the account's public key for the look up table
  \end{itemize}


\noindent \textbf{Description:}\\
This helper function gets the relevant sortition seed for the current round $r$, according to the seed lookback parameter $R$.
Conceptually, it corresponds with the seed computed $R$ rounds prior to $r$, refreshed every $R$ rounds.

\noindent \textbf{Returns:}
\begin{itemize}
    \item a sortition seed to be used in the round $r$
  \end{itemize}

% ----------------------------------------------------------------------------------------------

\begin{algorithm}[H]
    \begin{algorithmic}[1]
        \Function{$getSortition_w$}{$ctx, round, a_{pk}$}

            $\Return\;ctx.balanceTable[r - (R + SL)][a_{pk}]$

        \EndFunction
    \end{algorithmic}
    \caption{\underline{getSortitionWeight}}
\end{algorithm}

\noindent \textbf{Arguments:}
\begin{itemize}
    \item $ctx$ = a helper structure to retrieve ledger context information (e.g. the last confirmed block)
    \item $r$ = current round number
    \item $a_{pk}$ = the account's public key for the look up table
  \end{itemize}


\noindent \textbf{Description:}\\
This helper function retrieves the stake $R + SL$ rounds prior to $r$, for an account
with public key $a_{pk}$

\noindent \textbf{Returns:}
\begin{itemize}
    \item the relevant account's stake
  \end{itemize}


% ----------------------------------------------------------------------------------------------


\begin{algorithm}[H]
    \begin{algorithmic}[1]
        \Function{$getSortition_W$}{$ctx, r$}
        
        $\Return \sum_{a_{pk}\;\in\;ctx.balanceTable[r - (R + SL)]}{balanceTable[r - (R + SL)][a_{pk}]}$

        \EndFunction
    \end{algorithmic}
    \caption{\underline{getSortitionTotalStake}}
\end{algorithm}

\noindent \textbf{Arguments:}
\begin{itemize}
    \item $ctx$ = a helper structure to retrieve ledger context information (e.g. the last confirmed block)
    \item $r$ = current round number
  \end{itemize}


\noindent \textbf{Description:}\\
This helper function returns the sum of all stake for $R + SL$ rounds prior to $r$.

\noindent \textbf{Returns:}
\begin{itemize}
    \item the total stake at play in the relevant round (according to lookback parameters)
  \end{itemize}

% ----------------------------------------------------------------------------------------------

\begin{algorithm}[H]
    \begin{algorithmic}[1]
    \Function{$\mathsf{Sortition}$}{$Account \ a, uint64 \ step$}
        \State $seed \gets L[r - \delta_s].seed$
        //ACLARAR QUE ESTE BALANCE ES EL DEL LOOKBACK (NO EL ACTUAL)
        \State $w \gets a.balance$ //$BT[a.address][r-\delta_s-\delta_b].balance$
        \State $W \gets \sum_{a \in A_{r-\delta_s-\delta_b}}a.balance$
        \State $\tau \gets \mathsf{CommitteeThreshold}(p)$
        \State $ \langle hash, \pi \rangle \gets \mathsf{VRF_{a_{sk}}}(seed||step)$
        \State $t \gets \frac{\tau}{W}$
        \State $j \gets 0$
        \While{$\frac{hash}{2^{hashlen}}\notin [ \sum_{k=0}^j\mathsf{B}(k;w,t), \sum_{k=0}^{j+1}\mathsf{B}(k;w,t))$}
            \State $j \gets j+1$
        \EndWhile
        \Return $credentials(hash, \pi, j)$
    \EndFunction
    \end{algorithmic}
    \caption{\underline{Sortition}}
\end{algorithm}


\noindent \textbf{Arguments:}
\begin{itemize}
    \item $Account \ a$, an online account's balance table record
    \item $uint64 \ step$, the step to run sortition for
\end{itemize}

\noindent \textbf{Description:}\\
The Sortition procedure is one of the most important subroutines in the main algorithm, as it is 
used in multiple stages and contexts.
Generally, it manages to pseudo-randomly but verifiably (through the use of a Verifiable Random 
Function) select a user with probability proportional
to their weight (i.e., stake) by returning a $j$ parameter, which indicates the number of times that 
specific user was chosen.
Algorithmically, every monetary unit the user has is considered a "sub-user", and then each one 
of them is selected with probability $p = \frac{\tau}{W}$,
where $\tau$ is the expected amount of users to be selected for the given role, and $W$ is the total
stake online for the relevant round.
The semi-open interval $[0,1)$ is then split into consecutive intervals using an accumulated 
binomial distribution, and wherever the fraction $\frac{hash}{2^{hashlen}}$
belongs to the interval, that's the ammount of chosen sub-users for the subroutine caller.\\

\noindent \textbf{Returns:}
\begin{itemize}
    \item an object of type $credentials$, containing the sortition hash and proof (output of VRF
    computation) and an unsigned integer $j$ representing the weight that player has in the committee,
    for the desired round, period and step.
  \end{itemize}

% ----------------------------------------------------------------------------------------------


\begin{algorithm}[H]
    \begin{algorithmic}[1]
    \Function{$\mathsf{VerifySortition}$}{$pk, seed, \tau, role, w, W$}
        \IfThen{$\neg \mathsf{VerifyVRF}_{pk}(hash, \pi, seed||role)$}{$\mathsf{return} \ 0$}
        \State $p \gets \frac{t}{W}$
        \State $j \gets 0$
        \While{$\frac{hash}{2^{hashlen}} \notin [\sum_{k=0}^j\mathsf{B}(k;w,p), \sum_{k=0}^{j+1}\mathsf{B}(k;w,p))$}
            \State $j++$
        \EndWhile
        \Return $j$
    \EndFunction
    \end{algorithmic}
    \caption{\underline{VerifySortition}}
\end{algorithm}

\noindent \textbf{Arguments:}
\begin{itemize}
    \item $pk$ = a user's public key (their address)
    \item $seed$ = the sortition seed to be used
    \item $\tau$ = the expected committee size for the given role
    \item $role$ = a flag specifying the role for the sortition to take place (e.g. block proposer)
    \item $w$ = the user's weight (i.e., its relevant stake)
    \item $W$ = the total relevant stake for the given round
  \end{itemize}

\noindent \textbf{Description:}\\
The sortition verification procedure takes Sortition's output and utilizes 
VRF properties to verify the validity of said output.
Once the check is passed, it repeats Sortition's sub-user selection procedure, 
and outputs the amount of times the user was chosen according to their respective 
observed stake.\\

\noindent \textbf{Returns:}
\begin{itemize}
    \item an integer $j$ that will be positive (larger than 0) if the user has been 
    selected, and it's size corresponds to the amount
    of sub-users for a given committee member
  \end{itemize}


\end{section}
% ----------------------------------------------------------------------------------------------
% \section*{Appendix: Notation}
\begin{section}{Appendix: Notation}


\begin{itemize}
    \item $credentials$, a data structure containing the results of running the sortition algorithm 
    for a specified account
    \item $sh$, the 64 byte sortition hash output by running $VRF_{a_{sk}}$ algorithm over a desired input.
    Usually wrapped inside a $credentials$ structure.
    \item $\pi$, the 32 byte sortition proof output by running $VRF_{a_{sk}}$ algorithm over a desired input.
    Usually wrapped inside a $credentials$ structure.
    \item $j$, an unsigned 64 bit integer, representing the weight of a given account's vote inside a specific committee
    (for a given round, period and step).
    Usually wrapped inside a $credentials$ structure.
    \item $\lambda_0$, time interval for the node to accept block proposals (when $p=0$), after which it 
    chooses the observed block with the highest priority (lowest hash).
    \item $\lambda$, same as $\lambda_0$ but for $p > 0$.
    \item $\delta_s$, sortition seed renewal rate, in number of rounds. Set to $2$ in 
    \href{https://github.com/algorandfoundation/specs}{specs.} as of July 2023.
    \item $\delta_b$, balance lookback interval, in number of rounds. Set to $320$ in 
    \href{https://github.com/algorandfoundation/specs}{specs.}

    % \item Public keys $a_{pk}$ for every account linked to the node (doubles as their respective addresses)
    % \item Public participation keys $a_{p\_partkey}$ for all accounts registered as online (private participation keys are kept
    % securely by respective users and should not be directly accesible by the node)
    % \item Two levels of ephemeral keys, signed according to the signing scheme described in \href{https://github.com/algorandfoundation/specs}{specs.} (where 
    % first level keys are signed with the participation keys, and second level (aka. leaf) ephemeral keys are signed with 
    % first level ephemeral keys). 
    % These keys are used for actual participation in the consensus (abstracted as $a_{sk}$ in the following code)
    % They are ephemeral because they live for a single round, after which they are deleted
    % \item A balance table $BT$ for all accounts linked to the node, for the round $SL + R$ rounds before the one 
    % currently running
\end{itemize}

\end{section}

% ----------------------------------------------------------------------------------------------

\bibliographystyle{alpha}
\bibliography{bibliography}

% ----------------------------------------------------------------------------------------------
\printindex
\end{document}