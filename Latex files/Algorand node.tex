\documentclass[10pt,a4paper]{article}
\usepackage[utf8]{inputenc} % para poder usar tildes en archivos UTF-8
\usepackage[spanish]{babel} % para que comandos como \today den el resultado en castellano
\usepackage{a4wide} % márgenes un poco más anchos que lo usual
\usepackage{caratula}
% \usepackage[left=3cm,right=3cm,bottom=3cm,top=3cm]{geometry}

% Comandos para simbolos matematicos.
\usepackage{amsmath, amssymb, tabularx}

% Comandos para referencias
\usepackage{natbib}

% Comandos para Figuras, Graficos, Tikz etc.
\usepackage{tikz}
\usepackage{epsfig}
\usepackage{pgfplots}
\usepackage{graphicx}
\usepackage{epsfig}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{svg}
\setsvg{inkscape=inkscape -z -D}

% Comandos para teoremas etc.
\usepackage{amsthm}
\newtheorem{theorem}{Teorema}
\newtheorem{lemma}[theorem]{Lema}
\newtheorem{proposition}[theorem]{Proposición}
\newtheorem{remark}{Observación}
\newtheorem{corollary}{Corolario}
% \newproof{proof}{Demostración}

% Comandos para algoritmos.
\usepackage[noend]{algpseudocode}
\usepackage{algorithm}
\algnewcommand{\IfThenElse}[3]{% \IfThenElse{<if>}{<then>}{<else>}
    \State \algorithmicif\ #1\ 
    \algorithmicthen\ #2\ 
    \algorithmicelse\ #3}
\algnewcommand{\IfThen}[2]{% \IfThenElse{<if>}{<then>}
    \State \algorithmicif\ #1\ \algorithmicthen\ #2}
\pgfplotsset{compat=1.18}

\begin{document}


\begin{algorithm}
    \begin{algorithmic}[1]
    \Function{$BlockCreation()$}{}
    
    \State $TODO$
    
    \EndFunction
    \end{algorithmic}
    \caption{\underline{Block creation}}
    \label{alg:fuerza_bruta}
\end{algorithm}

The algorand protocol specs don't ensure a specific way or internal order in which transactions are added to the block.
In fact, they don't force transactions to be added at all, being entirely possible for a node to propose an empty block.
More research is needed on how block data is put together.
Block metadata is well documented, but is added into it later in the block proposal stage.

\begin{algorithm}
    \begin{algorithmic}[1]
    \Function{$BlockProposal$}{$Block$ $B$, $Accounts$ $A$}
        \State $\lowestPriorityUser, lowestPriority$    

        \For{$a \in A$}
            \State $<sorthash, \pi, j>\gets Sortition(a.sk, seed, t, role, a.w[], W)$
            \If{$j > 0$}
                \State $priority \gets Min_{n \in [1,j]}{Hash(sorthash || n)}$
                \State $lowestPriorityUser \gets a$
                %es block proposer
                %VER exactamente todo lo pertinente al mensaje
                \State $GOSSIP\_MESSAGE(priority, SIGNED_{a.sk}(<sorthash, \pi>))$
            \EndIf
        \EndFor



        \State $msgs \gets incomingMsgs[round, step=0]$

        \While{$elapsed$ $time$ $< proposal$ $time$}
            \State $incomingMsgs.push(listen())$
        \EndWhile

        \State $lowestHashMsg \gets m\ |\ m.priority = Min_{m.priority\ \in\ incomingMsgs}{\{verifySortition(m.sorthash, m.pi, m.pk)\ \& ValidateMsg(m)}}$

        \State $seed \gets ComputeSeed(r, lowestHashMsg)$
        \State $FullBlockToPropose \gets empty_block(round)$

        \State $FullBlockToPropose.seed \gets seed$

        \While{$elapsed time < fullblock time$}
            \State $m \gets msgs.next()$
            \State $<priority, sorthash, \pi> \gets m$
        \EndWhile
            
    
    
    \EndFunction
    \end{algorithmic}
    \caption{\underline{Block proposal}}
\end{algorithm}

The block proposal stage (step 0 on specs) is the first stage of the consensus algorithm per se. Nodes loop through all their online accounts, running sortition to determine which accounts will be proposing the assembled block (if any).
It then proceeds to gossip the priority, sortition hash and proof of the designated accounts (signed with their leaf ephemeral keys according to the signature scheme described on specs).
Afterwards, it waits for a designated time to receive other block proposals, validates them and keeps the one with the lowest observed hash (maximum priority).
Once the time is reached, if the selected proposal came from this node, the seed is computed and added into the finished block's metadata. Then, the complete block is gossipped to the network.
In the most common case where the proposal is not the one selected locally by the node, it waits for another pre-designated time to receive the full block from the network.
In case of timeout in this last stage, it falls back to the empty block.

\begin{algorithm}
    \begin{algorithmic}[1]
    \Function{$SoftVote$}{}
    
    %\State $CommitteeVote(ctx, round, REDUCTION\_ONE, tstep, hblock)$
    \State $hblock \gets CountVotes(ctx, round, REDUCTION\_ONE, Tstep, tstep, lblock+lstep)$

    \State $empty\_hash \gets H(Empty(round, H(ctx.last\_block)))$
    \IfThenElse{$hblock = TIMEOUT$}
        {\State $CommitteeVote(ctx, round, REDUCTION\_TWO, tstep, empty\_hash)$}
        {\State $CommitteeVote(ctx, round, REDUCTION\_TWO, tstep, hblock1)$}
    \EndIfThenElse

    \State $hblock \gets CountVotes(ctx, round, REDUCTION\_TWO, Tstep, tstep, lblock+lstep)$ 

    \IfThenElse{$hblock = TIMEOUT$}{$\Return$ $empty\_hash$}{$\Return$ $hblock$}

    \EndFunction
    \end{algorithmic}
    \caption{\underline{Soft Vote}}
\end{algorithm}

The soft vote stage (step 1, or labeled as reduction in the ASBAC paper) aims to reduce any ammount of potentially conflicting proposed blocks in the stage prior into a binary choice, either a block proposed by a user or an empty one.
In the first sub-step, each commitee member gossips the proposed block, and then does a preliminary vote count while it waits for other nodes to catch up.
In the second sub-step, committee members vote for the hash that received at least the ammount of votes set by the threshold for this step, or the hash of the default empty block if no hash was observed to receive enough votes.
It relies heavily on the assumption that, if the block proposer was honest, most users will get to the soft vote stage with the same hblock parameter.
However if the proposer was dishonest, then no single hblock may be popular enough to cross the threshold (and therefore this stage will return an empty\_hash).
Therefore, there will at most be one non-empty block that can be returned by soft vote for all honest users.


\begin{algorithm}
    \begin{algorithmic}[1]
    \Function{$CertifyVote$}{$hblock$}

    \State $step \gets 2$
    \While{$step < 256$}
    {
        \\
        \State $<hblock, bConfirmed> \gets BLOCK\_STEP(hblock, step)$
        \If{$bConfirmed$}{ $\Return$ $hblock$}
        \EndIf
        \State $step++$\\
   
        \State $<hblock, bConfirmed> \gets EMPTY\_STEP(hblock,step)$
        \If{$bConfirmed$}{ $\Return$ $hblock$}
        \EndIf
        \State $step++$\\

        \State $CommonCoinFlipVote(hblock, step)$
        \State $step++$
    }
    \EndWhile

    \State $HangForever()$
    
    \EndFunction
    \end{algorithmic}
    \caption{\underline{CertifyVote}}
\end{algorithm}

The certify vote stage (which potentially encompasses steps 2 through 255) is the core of the BA* algorithm.
The main loop executes a maximum of 254 times (from step 2 to step 255, labeled \"cert\" and \"down\" respectively on the specs).
This is to avoid an attacker indefinitely postponing consensus in a compromised network, giving them a small chance to force consensus on their desired block with each iteration.
The main algorithm is comprised of three important procedures: the block step, where, if selected as a committee member, votes for the block selected in the soft voting stage and then attempts to confirm it by listening to other cast votes until a threshold is met.
If this step times out and no consensus is reached, it moves on to the empty step. Very similar in nature to the previous one, in this procedure a vote is cast for the value in hblock and then it attempts to confirm an empty block.
Finally, if no consensus is reached on the empty block, it arrives to the common coin procedure, where it attempts another vote and vote count for the empty block. If here, no consensus is reached, it uses the pseudo-randomness of the VRF hash output to "flip a coin" by looking at the last bit of the lowest sortition hash owned by observed committee members.
This makes it so even tho the coin flip is random, most users will observe the same outcome and will in turn set their hblock values according to the observed bit. In turn, this prevents an adversary from being able to easily predict beforehand what the next vote of a user would be if they were a committee user, and therefore the attacker can't force consensus 
sending their vote messages to targeted users in a scenario where the voting is split pretty evenly but no block has quite enough votes to push the threshold.

\begin{algorithm}
    \begin{algorithmic}[1]
    \Function{$BlockConfirmation$}{$hblock$}

    \State $r \gets CountVotes(ctx, round, FINAL, Tfinal, tfinal, lstep)$
    \IfThenElse{$r = hblock$}
    {
        \State \Return $<FINAL, BlockOfHash(hblock)>$ 
    }
    {
        \State \Return $<TENTATIVE, BlockOfHash(hblock)>$
    }
        
    \EndFunction
    \end{algorithmic}
    \caption{\underline{BlockConfirmation}}
\end{algorithm}



Finally, the proposed block (be it an empty block or a specific one proposed by a designated user) is confirmed and added to the ledger.
We introduce the notions of FINAL and TENTATIVE consensus.
Specifically, if a block is confirmed in the very first step of the certify vote stage, its vote is cast as FINAL.
If enough users reproduce this behavior, the vote count on line 2 for votes cast in this fashion is over the required threshold, and the consensus is labeled as FINAL.
This means that the block is simultaneously added to the ledger and confirmed, as well as immediately confirming any prior blocks that could have been labeled TENTATIVE.
If this node is not able to ensure that enough users considered the block represented by hblock as FINAL, the consensus is labeled as TENTATIVE, and it may be confirmed by a later FINAL block.
The BlockOfHash() function outputs the full block for the provided hash, either by returning a locally available copy or by requesting it from other users.







\end{document}