\documentclass[10pt,a4paper]{article}
\usepackage[utf8]{inputenc} % para poder usar tildes en archivos UTF-8
\usepackage{babel} % para que comandos como \today den el resultado en Ingles
\usepackage{a4wide} % márgenes un poco más anchos que lo usual

\usepackage{hyperref}


%\usepackage{caratula}
% \usepackage[left=3cm,right=3cm,bottom=3cm,top=3cm]{geometry}

\usepackage{float}

% Comandos para simbolos matematicos.
\usepackage{amsmath, amssymb}%, tabularx}

% Comandos para referencias
%\usepackage{natbib}

% Comandos para Figuras, Graficos, Tikz etc.
% \usepackage{tikz}
% \usepackage{epsfig}
% \usepackage{pgfplots}
% \usepackage{graphicx}
% \usepackage{epsfig}
% \usepackage{caption}
% \usepackage{subcaption}
% \usepackage{svg}
% \setsvg{inkscape=inkscape -z -D}

% Comandos para teoremas etc.
%\usepackage{amsthm}
% \newtheorem{theorem}{Teorema}
% \newtheorem{lemma}[theorem]{Lema}
% \newtheorem{proposition}[theorem]{Proposición}
% \newtheorem{remark}{Observación}
% \newtheorem{corollary}{Corolario}
% \newproof{proof}{Demostración}

% Comandos para algoritmos.
\usepackage[noend]{algpseudocode}
\usepackage{algorithm}
\algnewcommand{\IfThenElse}[3]{% \IfThenElse{<if>}{<then>}{<else>}
    \State \algorithmicif\ #1\ 
    \algorithmicthen\ #2\ 
    \algorithmicelse\ #3}
\algnewcommand{\IfThen}[2]{% \IfThenElse{<if>}{<then>}
    \State \algorithmicif\ #1\ \algorithmicthen\ #2}
%\pgfplotsset{compat=1.16}


\usepackage{marginnote}

\author{Argimiro, CoinFabrik}
\title{Algorand Protocol Description}

\begin{document}
\maketitle
\tableofcontents

% ---------------------------------------------------------------------------------------
\begin{section}{Introduction}
We aim to describe how the Algorand protocol works. 
This document is meant to reflect how the Algorand mainnet is behaving
today. We relied on Algorand's documents (\cite{DBLP:conf/sosp/GiladHMVZ17},
\cite{DBLP:journals/corr/Micali16} and 
\href{https://github.com/algorandfoundation/specs}{Algorand's official specifications})
but consulted the node's code and probed the network when information was unclear or 
unavailable.

Algorand is a proof-of-stake blockchain cryptocurrency protocol 
using a decentralized Byzantine Agreement protocol that leverages 
pure proof of stake for consensus. The protocol maintains a ledger
that is modified via consensus. In particular, this ledger encodes
how many ALGOs (the native token) holds each account.
Blocks encode the status of the ledger. Starting on the genesis
block (round 0) that encodes the first state of the network, 
on each round the participation nodes vote on what will the next
block be. Their voting power is proportional to the stake (in ALGOs) 
held by the accounts assoicated to the node.

At the genesis of the Algorand blockchain, 10Bn ALGO was minted. 
As of September 2022, circulating supply is approximately 6.9b ALGO, 
distributed through different forms of ecosystem support and 
community incentives. 
The remaining Algos are held by the Foundation in secure wallets 
assigned to 
Community and Governance Rewards (\%53), 
Ecosystem Support (\%36), and 
Foundation endowment (\%11).

A network is formed with two kind of nodes: relay and participation 
nodes. Participation nodes can connect only to relay nodes. 
They listen to one or more participation nodes and they may 
send a message to a relay node. Relay nodes simply listen to participation
nodes connected to them and relay the messages they receive.\marginpar{Explain 
how the network is formed}

In the following document we present a detailed pseudocode interpretation 
of the program run by an Algorand node managing at least one online (i.e., 
participating) account. We attempt to explain the different states the node 
can be in, as well as all kinds of events that cause transitions and network 
output. This work aims to provide a basis for an Algorand blockchain simulator 
currently in development. 

\end{section}


\begin{section}{Player accounts}

A player is a unique participant of the protocol. We will
use the terms player and account indistinctly throughout this document.
A player is uniquely identified by a 256-bit string I called an address.
Furthermore, they posess a certain balance (an unsigned 64 bit integer), 
and a pair of participation keys set up according to the key scheme. An account may be online, 
offline or nonparticipating.
An account is offline when it has not sent an online transaction, that creates
a participation key and a set of ephemeral keys to be used at each round and
destroyed at the end.
Also, an account has a set of VRF keys, computed at each round.
TODO: keep describing player. Describe register process, online / offline /nonpart attributions

\end{section}

\begin{section}{Ledger definition}
A ledger is a sequence of states which comprise the common information established by some instantiation of the Algorand protocol. 
Given a Ledger instance, its immutable characteristics are (...)
A ledger state then is defined by the following parameters:

A Ledger entry e (also known as block) is a data structure that models a ledger's state transition.
%TODO: PARAPHRASE AND FORMAT:
% The data in a block is divided between the block header and its block body. The block
% header contains the following components:
% • The block’s round, which matches the round of the state it is transitioning
% into. (The block with round 0 is special in that this block specifies not a
% transition but rather the entire initial state, which is called the genesis
% state. This block is correspondingly called the genesis block.) The round is
% stored under msgpack key rnd.
% • The block’s genesis identifier and genesis hash, which match the genesis
% identifier and hash of the states it transitions between. The genesis identifier
% is stored under msgpack key gen, and the genesis hash is stored under
% msgpack key gh.
% • The block’s upgrade vote, which results in the new upgrade state. The
% block also duplicates the upgrade state of the state it transitions into.
% The msgpack representation of the components of the upgrade vote are
% described in detail below.
% • The block’s timestamp, which matches the timestamp of the state it
% transitions into. The timestamp is stored under msgpack key ts.
% • The block’s seed, which matches the seed of the state it transitions into.
% The seed is stored under msgpack key seed.
% • The block’s reward updates, which results in the new reward state. The
% block also duplicates the reward state of the state it transitions into. The
% msgpack representation of the components of the reward updates are
% described in detail below.
% • A cryptographic commitment to the block’s transaction sequence, described
% below, stored under msgpack key txn.
% 4
% • A cryptographic commitment, using SHA256 hash function, to the block’s
% transaction sequence, described below, stored under msgpack key txn256.
% • The block’s previous hash, which is the cryptographic hash of the previous
% block in the sequence. (The previous hash of the genesis block is 0.) The
% previous hash is stored under msgpack key prev.
% • The block’s transaction counter, which is the total number of transactions
% issued prior to this block. This count starts from the first block with a
% protocol version that supported the transaction counter. The counter is
% stored in msgpack field tc.
% • The block’s expired participation accounts, which contains an optional slice
% of public keys of accounts. These accounts are expected to have their
% participation key expire by the end of the round (or was expired before
% the current round). The msgpack representation of the components are
% described in detail below. The slice is stored in msgpack key partupdrmv.
% The block’s expired participation accounts slice is valid as long as the participation
% keys of all the accounts in the slice are expired by the end of the round or were
% expired before, the accounts themselves would have been online at the end of
% the round if they were not included in the slice, and the number of elements
% in the slice is less or equal to 32. A block proposer may not include all such
% accounts in the slice and may even omit the slice completely.
% The block body is the block’s transaction sequence, which describes the sequence
% of updates (transactions) to the account state and box state.
% A block is valid if each component is also valid. (The genesis block is always
% valid). Applying a valid block to a state produces a new state by updating each
% of its components.
\end{section}

\begin{section}{Node as a State Machine}

We model each player as a finite state machine. In order to do so, we will first
define and explain all variables involved in a given state a player is able to be in or transition to.
A node, the network entity running the protocol, will then be "playing for" one or more online accounts that it manages.

Let round and period number, $r$ and $p$, be unsigned 64 bit integers. Let the 
step number, $s$, be an unsigned  8 bit integer.
For convenience and readability, the following aliases for step number are defined:
\begin{itemize}
    \item $s=0 \equiv proposal$
    \item $s=1 \equiv soft$
    \item $s=2 \equiv cert$
    \item $s \in [3,252] \equiv next_{s-3}$
    \item $s=253 \equiv late$
    \item $s=254 \equiv redo$
    \item $s=255 \equiv down$
\end{itemize}


A proposal-value is a tuple v = (I, p, Hash(e), Hash(Encoding(e))) where I is
an address (the “original proposer”), p is a period (the “original period”),
Hash is some cryptographic hash function (usually SHA512/256), Encoding is
performed in msgpack, and e is a given ledger entry (as described in the previous section).
The special proposal where all fields are the zero-string is called the bottom proposal $\bot$.



Consider now tuples of the form (I, r, p, s, v), where v is a value.
We will call this kind of construct a vote, noting it Vote(r, p, s, v), read as
a vote for value 'v' at round r, period p and step s.

We now consider ledger entries of the form (...).
A tuple of the form () is called a proposal or proposal payload, noted Proposal(v).

Given all of the above data types and constructs, a node can be modelled as 
a finite state machine. A state is given by a 3-tuple of integers, $(r, p, s)$, 
two sets $P$ and $V$ of objects which we will call observed $proposal$ and $vote$ values, 
a special value vprime which we call the pinned value (see recovery algorithms),
a Ledger $L$ and a balance table $BT$, a table of public addresses for all 
accounts holding any stake in the network, and their balances. A Ledger is an 
ordered chain of entries, and fundamentally it represents state changes in the balance table.
The round number can be thought of as an index into the ledger, where the event of observing
a new round cannot be decoupled from the event of adding an entry (block) to the ledger.




\end{section}
% ------------------------------------------------------------------------
\begin{section}{Main algorithm}


\begin{algorithm}[H]
    \begin{algorithmic}[1]
    \Function{$\mathsf{EventHandler}(Event \ ev)$}{}
    
    \If{$ev \ is \ TimeoutEvent$}
        \State $time \gets ev.time$
        \If{$time = 0$}
            \State $BlockProposal()$
        \ElsIf{$time = FilterTimeout(p)$}
            \State $SoftVote()$
        \ElsIf{$time = \max\{4\lambda, A\} \ \lor \ time = \max\{4\lambda, A\} + 2^{st-3}\lambda + r, st \in [4, 252], r \in [0, 2^{st-3}\lambda]$}
            \State $Recovery()$
        \ElsIf{$\exists k \in \mathbb{Z}, r \sim U(0, \lambda_f), time = k\lambda_f + r$}
            \State $FastRecovery()$
        \EndIf
    \Else %//Event is MessageEvent
        \State $msg \gets ev.msg$
        \If{$msg \ is \ Proposal \ p$}
            \State $HandleProposal(p)$
        \ElsIf{$msg \ is \ Vote \ v$}
            \State $HandleVote(v)$
        \ElsIf{$msg \ is \ Bundle \ b$}
            \State $HandleBundle(b)$
        \EndIf
    \EndIf

    \EndFunction
    \end{algorithmic}
    \caption{\underline{Main node algorithm}}
\end{algorithm}

Algorand nodes operate based on events, which are the only means 
through which the node state machine can transition and produce outputs. 
Whenever an event is received, the node will produce a state change and
will typically generate an output that will be broadcasted or relayed to other nodes on the network.

There are two types of events: Timeout events and Message events. Timeout events are produced when 
the node's internal clock reaches a certain time since the start of the current period, while 
Message events are generated in response to messages sent by other network actors.

The main algorithm describes how the event handling mechanism works. 
If the event is a timeout and a new period has just started, the node will run the block proposal step. 
After a certain amount of time, the node will attempt to soft vote, selecting the best received proposal 
value based on the lowest proposer hash criteria and broadcasting its votes to the network if selected as part of the soft voting committee.

If the event is a message reception, the node will handle it according to its context. 
For example, a soft vote outside of the soft voting step could produce a next vote, 
but it could not produce a certification vote without a period change and another round of voting.

After a certain amount of time, the node will start the recovery steps and next vote a value or an empty block 
if it observes the required threshold votes. Finally, after another specified amount of time, the block will 
attempt a FastRecovery.

More details on the specifics of each handler can be found in their respective subsections.



% on that (r, p), we define a node state. A state transition can only be triggered by one of two kinds of events:

% TIMEOUT EVENTS:
% -Events that are triggered after a certain time has elapsed after the start of a new period.
% Filter Timeout:
% Consider the following function,
% filterTimeout(p) = 2*lambda0 if p == 0, 2*lambda otherwise
% Then, when observing a timeout of filterTimeout(p) (where p is the period of the current node state),
% a Node runs the soft vote routine, producing as output a soft vote for the proposal with the lowest credential
% (further detailed in the soft vote section)

% Next_0 Timeout:
% On observing a timeout of max{4lambda, uppercaselambda}, which can only happen if the node does not manage to certify
% in the interval (filtertimeout(p), max{}) (see message events, soft bundle and cert bundle), a node sets step = next_0.
% In this stage, it attempts to start a new period taking the following actions:
% %nextvote actions here...

% Next_st Timeout:
% On observing a timeout of max{} + lambda*2^st + uniform random sample, a node sets step = st (4 <= st <= 252).
% Behavior is similar to next_0.

% Fast recovery Timeout:
% On observing a timeout of k*lambdaF + uniform_random_sample, for any k positive integer, the node goes into fast recovery mode.
% Then it executes late, redo and down in succesion.
% Whenever a node runs out of Next_st, given that st is bounded, the fast recovery will be attempted on every k*lambdaF until 
% the network has recovered from a partition or attack.


% MESSAGE EVENTS:
% -Events triggered after observing a certain message.
% There's 3 kinds of messages: votes, proposal payloads, and bundles (soft and cert).
% %describe all messages that can be observed

% On transition, the node outputs a set of messages to the network.

% There's 256 possible steps inside a period, each with their own characteristics.
% Step 0 is the proposal step, where nodes iterate over their managed accounts, propose a block and propagate it (detailed below).
% Step 1 is triggered when soft timeout is reached. Here a block is soft voted based on the proposer's credentials.
% Step 2 is then started, where nodes are listening for messages containing soft votes until next timeout.
% If a soft bundle is observed for a certain value, a certification vote is emmitted.
% Steps 3 to 255 are recovery steps. 3 to 252 are called "next", and try to achieve quorum on the start of a new period.
% Steps 253 to 255 are called "late", "redo" and "down", and are associated with fast recovery.
% The fast recovery protocol is called once every time a fast recovery timeout is triggered.

% Assume right now that a given node is fixed, we are at round $r$,
% this node has access to a set of accounts $a\in A$. 
% Moreover, the account owner has computed for each round a round 
% leaf ephemeral key $a_{sk}$. Assume also the node has access to contextual
% information about the ledger state, that being the current last confirmed block,
% the last $n > 322$ confirmed blocks, balance and ephemeral keys of all 
% online accounts in that interval of rounds. For the sake of clarity and readability, 
% we abstract access to that data through a context structure ($ctx$ in code), accesible
% at all times by the node.
% The main algorithm goes over the following stages on every round.
% \begin{itemize}
%     \item {\bf block creation:} the node assembles a block with a set of
%         transactions and metadata.
%     \item {\bf block proposal:} the node runs the Verifiable Random Function 
%         (VRF for short) algorithm to decide whether it should participate in 
%         the next stage. If it gets selected, then it is sends the block proposal 
%         to the other nodes together with the result of the VRF run.
%     \item {\bf soft vote:} the node undergos two rounds of voting to 
%         reduce all posible block options to a dicotomy: either a block 
%         proposed by a chosen online network user or an empty block.
%         \marginpar{With this description the next round is superfluous}
%     \item {\bf certify vote:} the node undergoes a series of $n$ voting rounds
%         ($253 \geq n \geq 1$) to certify either the block received by the 
%         prior stage or an empty block. If $n = 1$, the consensus is said 
%         to be FINAL. Otherwise, the consensus will be TENTATIVE.
%     \item {\bf block confirmation:} the block chosen in the certification 
%         stage is added to the ledger, as FINAL or TENTATIVE depending on 
%         the amount of users observing it as either (as defined by the 
%         threshold parameters for each kind of consensus).\marginpar{What is 
%         the effect of a block being tentative?}
% \end{itemize} 

    

% On top of that, each node may run in favour of different accounts. To do this,
% it needs the following parameters. 
% Let $A=\{a\}$ be a collection of accounts $a$.\\ \\
% \noindent \textbf{Account parameters}:
%     \item Public keys $a_{pk}$ for every account linked to the node (doubles as their respective addresses)
%     \item Public participation keys $a_{p\_partkey}$ for all accounts registered as online (private participation keys are kept
%     securely by respective users and should not be directly accesible by the node)
%     \item Two levels of ephemeral keys, signed according to the signing scheme described in \href{https://github.com/algorandfoundation/specs}{specs.} (where 
%     first level keys are signed with the participation keys, and second level (aka. leaf) ephemeral keys are signed with 
%     first level ephemeral keys). 
%     These keys are used for actual participation in the consensus (abstracted as $a_{sk}$ in the following code)
%     They are ephemeral because they live for a single round, after which they are deleted
%     \item A balance table $BalanceTable$ for all accounts linked to the node, for the round $SL + R$ rounds before the one 
%     currently running

% \end{subsection}

% --------------------------------------------------------------------
% \begin{subsection}{Block Creation}\label{ssect:blockcreation}

% \begin{algorithm}
%     \begin{algorithmic}[1]
%     \Function{$\mathsf{BlockCreation}$}{$transactionPool$}
%     \State Pick transactions from transactionPool
%     \State \Return $\mathrm{Block}$    
%     \EndFunction
%     \end{algorithmic}
%     \caption{\underline{Block creation}}
% \end{algorithm}

% \noindent \textbf{Arguments:}
% \begin{itemize}
%     \item The local pending transaction pool, which should be accesible to the node\\
%   \end{itemize}

% \noindent \textbf{Description:}\\
% After confirming a block (and before the genesis block is confirmed) nodes listen to 
% transactions that are sent to the {\tt algod REST API} and relay these transactions\marginpar{How does the Algorand client send transactions
% to the transaction pool?}. 
% At one point, the participation node starts assembling a block.
% The Algorand protocol specs (\cite{DBLP:conf/sosp/GiladHMVZ17}) do not ensure 
% a specific way or internal order in which transactions are added to the block.
% The node will validate the signature and execute the transactions in the Algorand
% Virtual Machine (AVM for short) \marginpar{How does this work? Do accounts need to hold
% ALGO? So the genesis block already assigned some ALGOs to some accounts without any
% block-recorded transaction, right?}
% Most of the block metadata is added in this stage, with the exception of the seed
% which is computed during the block proposal stage (\ref{ssect:blockproposal}).
% Notwithstanding, the official node implementation follows one (undocumented)
% algorithm, yet when a node sends a proposal, the official node implementation
% does not check the order of the transactions or whether a particular transaction
% has been included.

% \medskip
% \noindent \textbf{Returns:} \newline
% A full block, consisting in a variable number of transactions\marginpar{the block 
% holds the state, right? not the transactions executied alone}, 
% and the following metadata.
% \begin{itemize}
%     \item A round number, $r$.
%     \item The genesis identifier. That is, an ID that identifies univocally the 
%         genesis block for this blockchain. For example, Mainnet and Testnet will
%         have different genesis identifiers.
%     \item upgrade vote.
%     \item A timestamp specifying when was the block created.
%     \item seed\marginpar{pero como se calcula cada uno de estos bichos?}
%     \item reward updates
%     \item crytographic commitment to transaction sequence\marginpar{what is this?}
%     \item crytographic commitment to txn sequence SHA256.
%     \item previous block hash\marginpar{how are these computed?}.
%     \item txn counter.
%     \item newly expired participation keys.\marginpar{are these also voted?
%     who gets to decide which keys expire and how}
%   \end{itemize}

% \end{subsection}
% --------------------------------------------------------------------
\begin{subsection}{Block Proposal}\label{ssect:blockproposal}

    \begin{algorithm}
        \begin{algorithmic}[1]
        \Function{$BlockProposal$}{}

            \State $ResynchronizationAttempt()$

            \For{$a \in A$}
                \State $\langle sorthash, \pi, j\rangle\gets 
                \mathsf{Sortition}(
                    a_{sk}, 
                    \mathsf{getSortitionSeed}(ctx, r), 
                    t, 
                    proposal, $ \newline
                    ${}$ ${\hskip 5.2cm}\mathsf{getSortition}_w(ctx, r, a_{pk}), 
                    \mathsf{getSortition_W}(ctx, r)
                )$
                \If{$j > 0$}
                    \If{$p = 0 \lor \exists s^\prime > 2 \textfractionsolidus Bundle(r, p-1, s^\prime, \bot) \subset V$}
                        \State $e \gets AssembleBlock()$
                        %\State $priority \gets \min_{1\le n < j}\{\mathsf{Hash}(sorthash || n)\}$
                        %\State $\mathsf{GOSSIP\_MSG}(a.pk, Signed_{a.sk}(priority, \langle sorthash, \pi\rangle))$
                        \State $v \gets Proposal_{value}(e)$
                        \State $Broadcast(Vote(I, r, p, proposal, v))$
                        \State $Broadcast(e)$
                    \Else
                        \State $v \gets v_0 | \exists s, Bundle(r,p-1,s,v_0) \subset V$
                        \State $Broadcast(Vote(I, r, p, proposal, v))$
                        \If{$Proposal(v) \in P$}
                            \State $Broadcast(Proposal(v))$
                        \EndIf
                    \EndIf
                \EndIf
            \EndFor
        \EndFunction
        \end{algorithmic}
        \caption{\underline{Block proposal}}
    \end{algorithm}

\newpage

\noindent \textbf{Description:}\\
The node manages multiple accounts and executes a "play" for each account, 
as each account represents a distinct player in the system. The node runs a 
sortition process for the proposal step of each account. If the account is selected 
to propose (i.e., if the account has more than 0 votes for the specific context), 
the node proceeds with the proposal step and period.

If the check on line 5 passes (i.e., if it is the first period or an empty block
 has been observed during the recovery step of the previous period), 
 the node assembles a new block (e), calculates the proposal value (v), 
 and broadcasts a vote for v on step 0 along with the full block (e).

If the check on line 5 fails (i.e., it is not the first period and no 
empty block was observed during the recovery step of the previous period), 
the period change must have been triggered by observing a bundle for a specific value $v_0$. 
The node broadcasts a vote for this value.

If the actual proposal (i.e., the full ledger entry) is available, the node then broadcasts it 
in a separate message.


\end{subsection}
% ---------------------------------------------------------------------------------------------------
\begin{subsection}{Soft Vote}\label{ssect:softvote}

\begin{algorithm}[H]
    \begin{algorithmic}[1]
    \Function{$SoftVote$}{}
    \State $lowestObservedHash \gets \infty$
    \State $v \gets \bot$ 


    \For{$vote \in V, vote.step = proposal$}
        \State $priorityHash \gets \min_{i \in [0, j)} Hash(vote.sorthash || i)$
        \If{$priorityHash < lowestObservedHash$}
            \State $lowestObservedHash \gets priorityHash$
            \State $v \gets vote.v$
        \EndIf    
    \EndFor

    \For{$a \in Accounts$}
        \State $<j, hash, \pi> \gets sortition(a, soft)$
        \If{$j > 0 \land lowestObservedHash < \infty$}
            \State $Broadcast(Vote(r, p, soft, v))$
            \If{$Proposal(v) \in P$}
                \State $Broadcast(Proposal(v))$
            \EndIf
        \EndIf
    \EndFor

    \EndFunction
    \end{algorithmic}
    \caption{\underline{Soft Vote}}
\end{algorithm}

\noindent \textbf{Description:}\\
The soft vote routine (also known as "filtering") is triggered after a SV timeout since the beginning of a period.
Of all received proposal votes, the node finds the one that minimizes the priority function.
The priority function is computed, for each voting unit of each proposer, as the minimum Hash(sorthash || i), where sorthash is
the proposer's sortition output hash, i is an integer in between 1 (inclusive) and the j value output by
the proposer's sortition run (exclusive).
If no valid votes were observed by the node, there is no output and the algorithm ends here.
If a value with minimum priority is found, every account managed by the node runs sortition to be part of 
the soft vote committee.
If selected, the vote is broadcast. If the ledger entry associated to that value has also been observed, it is broadcast
separately but immediately after.

\end{subsection}
% --------------------------------------------------------------------
% \begin{subsection}{Vote Certification}\label{ssect:certifyvote}
%     \begin{algorithm}[H]
%         \begin{algorithmic}[H]
%         \Function{$\mathsf{CertifyVote}$}{$blockHash$}
%         \State $localBlockHash \gets blockHash$
    
%         \State $step \gets 2$
%         \While{$step < 256$}
%             \\
%             \State $\langle blockHash, bConfirmed \rangle \gets \mathsf{BLOCK\_STEP}(blockHash, localBlockHash, step)$
%             \If{$bConfirmed$}{ $\Return$ $blockHash$}
%             \EndIf
%             \State $step++$\\
       
%             \State $ \langle blockHash, bConfirmed \rangle \gets \mathsf{EMPTY\_STEP}(blockHash,step)$
%             \If{$bConfirmed$}{ $\Return$ $blockHash$}
%             \EndIf
%             \State $step++$\\
    
%             \State $\mathsf{CommonCoinFlipVote}(blockHash, step)$
%             \State $step++$
%         \EndWhile \\
        
%         \While{$True$} \State $NOP$ ${}$ {\hskip 1cm} //await asynchronous recovery
%         \EndWhile

%         \EndFunction
%         \end{algorithmic}
%         \caption{\underline{CertifyVote}}
%     \end{algorithm}
    
% \noindent \textbf{Arguments:}
% \begin{itemize}
%     \item A block hash, $BlockHash$, received from the previous stage (soft vote)
%   \end{itemize}

% \noindent \textbf{Description:}\\
% The certify vote stage is the core of the voting algorithm.
% The main loop executes a maximum of 254 times (from step 2 to step 255, called ``cert'' and ``down'' 
% respectively on the \href{https://github.com/algorandfoundation/specs}{specs.}).
% This is to avoid an attacker indefinitely postponing consensus in a compromised network, giving them a 
% small chance to force consensus on their desired block with each iteration.

% The {\sf CertifyVote} algorithm comprises three important procedures: 
% \begin{enumerate}
%     \item the block step, where, if selected as a committee member, votes for the block selected in 
%     the soft voting stage and then attempts to confirm it by listening to other cast votes until a 
%     threshold is met. If this step times out and no consensus is reached, it moves on to the empty 
%     step. 
%     \item Very similar in nature to the previous one, in this procedure a vote is cast for the 
%     value in {\em blockHash} and then it attempts to confirm an empty block.
%     \item if no consensus is reached on the empty block, it arrives to the common coin procedure, 
%     where it attempts another vote and vote count for the empty block. 
%     If here, no consensus is reached, it uses the pseudo-randomness of the VRF hash output to ``flip a coin" 
%     by looking at the last bit of the lowest sortition hash owned by observed committee members.
%     This makes it so even though the coin flip is random, most users will observe the same outcome and will 
%     in turn set their {\em blockHash} values according to the observed bit. 
%     In turn, this prevents an adversary from being able to easily predict beforehand what the next vote 
%     of a user would be if they were a committee user, and therefore the attacker cannot force consensus 
%     sending their vote messages to targeted users in a scenario where the voting is split pretty evenly 
%     but no block has quite enough votes to push the threshold.
% \end{enumerate}
% If no consensus is reached before the step counter reaches {\em MAX\_STEPS}, 
% the program stops in an infinite loop and awaits for the asynchronous recovery
% protocol to kick in.\\

% \noindent \textbf{Returns:}
% \begin{itemize}
%     \item A block hash certified by a majority of users, to be confirmed and added to the ledger in the next stage as TENTATIVE or FINAL depending
%     on the observed voting share
%   \end{itemize}


% \end{subsection}
% --------------------------------------------------------------------
% \begin{subsection}{Block Confirmation}\label{ssect:blockconfirmation}

% \begin{algorithm}[H]
%     \begin{algorithmic}[H]
%     \Function{$BlockConfirmation$}{$blockHash$}

%     \State $r \gets \mathsf{CountVotes}(ctx, round, FINAL, T_{final}, \tau_{final}, lstep)$
%     \If{$r = blockHash$}
%         \State \Return $\langle FINAL, BlockOfHash(blockHash)\rangle$ 
%     \Else
%     {
%         \State \Return $\langle TENTATIVE, BlockOfHash(blockHash)\rangle $
%     }
%     \EndIf
%     \EndFunction
%     \end{algorithmic}
%     \caption{\underline{BlockConfirmation}}
% \end{algorithm}


% \noindent \textbf{Arguments:}
% \begin{itemize}
%     \item A block hash, $BlockHash$ received from the previous stage (Sect.~\ref{ssect:certifyvote})
%   \end{itemize}

% \noindent \textbf{Description:}\\
% Finally, the proposed block (be it an empty block or a specific one 
% proposed by a designated user) is confirmed and added to the ledger.
% We introduce the notions of FINAL and TENTATIVE consensus.
% Specifically, if a block is confirmed in the very first step of the
% certify vote stage, its vote is cast as FINAL.
% If enough users reproduce this behavior, the vote count on line 2 for 
% votes cast in this fashion is over the required threshold, and the 
% consensus is labeled as FINAL.
% This means that the block is simultaneously added to the ledger and 
% confirmed, as well as immediately confirming any prior blocks that 
% could have been labeled TENTATIVE.
% If this node is not able to ensure that enough users considered the 
% block represented by hblock as FINAL, the consensus is labeled as 
% TENTATIVE, and it may be confirmed by a later FINAL block.
% The $\mathsf{BlockOfHash}()$ function outputs the full block for the provided 
% hash, either by returning a locally available copy or by requesting 
% it from other users.

% \noindent \textbf{Returns:}
% \begin{itemize}
%     \item A full block to be added to the ledger, along with a flag indicating if
%     the consensus achieved is TENTATIVE or FINAL in nature
%   \end{itemize}

% \end{subsection}

% --------------------------------------------------------------------

\begin{subsection}{HandleProposal}\label{ssect:HandleProposal}

    \begin{algorithm}[H]
        \begin{algorithmic}[1]
        \Function{$HandleProposal$}{$Proposal \ e$}

            \State $v \gets Proposal_{value}(e)$ \\

            \If{$\sigma(S, r+1, 0) = v$}
                \State $Relay(e)$
            \EndIf \\

            %Ignores it if it is invalid.
            %Ignores it if Proposal(v) ∈ P.
            \If{$isValid(e) \land e \notin P \land v \in \{\sigma(S, r, p), v, \mu(S, r, p)\}$}
                \State $Relay(e)$
                \State $P \gets P \cup \{e\}$ \\  %observe it

                %produce output 
                \If{$IsCommitable(v) \land s \leq cert$}
                    \For{$a \in A$}
                        \State $\langle sorthash, \pi, j\rangle\gets 
                        \mathsf{Sortition}(
                        a_{sk}, 
                        \mathsf{getSortitionSeed}(ctx, r), 
                        t, 
                        cert, $ \newline
                        ${}$ ${\hskip 5.2cm}\mathsf{getSortition}_w(ctx, r, a_{pk}), 
                        \mathsf{getSortition_W}(ctx, r)
                        )$
                        \If{$j > 0$}
                            \State $Broadcast(Vote(a.I, r, p, cert, v))$
                        \EndIf
                    \EndFor    
                \EndIf

            \EndIf
            %Relays Proposal(v), observes it, and then produces any consequent output,
            %if v ∈ {σ(S, r, p), v, µ ¯ (S, r, p)}.
            %Otherwise, ignores it

        \EndFunction
        \end{algorithmic}
        \caption{\underline{HandleProposal}}
    \end{algorithm}
    
    
    \noindent \textbf{Description:}\\
The proposal handler is activated when a message event for a full proposal (aka. a ledger entry, e) is received by the node.
There's two parts to the algorithm. First, a series of checkups are performed (...)
Afterwards, and assuming the proposal is valid and not to be ignored, a check for commitability of the proposal value is performed.
If the value is commitable (that is, there is a soft bundle for it - more on that on IsCommitable() -), and the current step number
is cert (2) or less, we run sortition for the account for a membership of the certification committee.
If selected, a certification vote is broadcast.
    
\end{subsection}

% --------------------------------------------------------------------

\begin{subsection}{HandleVote}\label{ssect:HandleVote}

    \begin{algorithm}[H]
        \begin{algorithmic}[1]
        \Function{$HandleVote$}{$Vote \ vt$}

            \If{$\neg VerifyVote(vt) \lor
            (s=0 \land vt \in V) \lor 
            (s=0 \land IsEquiv(vt)) \lor
             (s>0 \land IsSecondEquiv(vt))
            \lor vt.r \notin [r,r+1] 
            \lor (vt.r = r+1 \land (vt.p > 0 \lor vt.s \in (next_0, late))) \lor 
            (vt.r = r \land 
                (vt.p \notin [p-1, p+1] \lor 
                vt.p = p+1 \lor
                (vt.p = p \land vt.s \in (next_0, late) \land vt.s \notin [s-1, s+1]) \lor 
                (vt.p = p-1 \land vt.s \in (next_0, late) \land vt.s \notin [\hbar{s}-1, \hbar{s}+1]) ))$
            }
                \State $\Return$ //the vote is ignored
            \EndIf \\

            //if we got here, the vote is to be relayed and observed
            \State $Relay(vt)$
            \State $V \gets V \cup vt$

            \If{$vt.s = proposal$}
                //reproposal payload
                %TODO: necesita ser miembro de comite aca? Yo pensaria que si porque es un broadcast, no un relay
                \State $Broadcast(Proposal(vt.v))$

            \ElsIf{$vt.s = soft \land \mathsf{IsCommitable}(vt.v) \land s \leq cert$}
                %TODO ACA: for account, run sortition
                    \State $Broadcast(Vote(r,p,cert,vt.v))$
            
            \ElsIf{$vt.s = cert \land Bundle(r,p,cert,vt.v) \subset V$}
                \State $Commit(Proposal(vt.v))$

            \ElsIf{$vt.s \in [next_0, next_{250}] \land \exists v | Bundle(r,p,vt.s,v) \subset V$}
                %TODO: ver si arrancar nuevo periodo
                %si arranca nuevo periodo, ver si pinnear un valor
                
            \EndIf

        \EndFunction
        \end{algorithmic}
        \caption{\underline{HandleVote}}
    \end{algorithm}
    
    
    \noindent \textbf{Description:}\\
The vote handler is called whenever a node receives a vote of any kind.

    
\end{subsection}

% --------------------------------------------------------------------

\begin{subsection}{HandleBundle}\label{ssect:HandleBundle}

    \begin{algorithm}[H]
        \begin{algorithmic}[1]
        \Function{$HandleBundle$}{$Bundle b$}

            \If{$VerifyBundle(b) \land b.r = r \land b.p \geq p-1$}
                \For{$vote \in b$}
                    \State $HandleVote(vote)$
                \EndFor
            \EndIf

        \EndFunction
        \end{algorithmic}
        \caption{\underline{HandleBundle}}
    \end{algorithm}
    
    
    \noindent \textbf{Description:}\\
This handler is called when a message containing a bundle is received.
If the bundle is verified (which implies verifying the validity of every vote separately),
the round of all votes in it matches the node's current round and its period is at least the previous one (p - 1), 
then each vote in the bundle is processed independantly.
Functionally, receiving a bundle is the same as receiving a set of votes sequentially.

\end{subsection}

% --------------------------------------------------------------------

\begin{subsection}{Recovery Attempt}\label{ssect:Recovery}

    \begin{algorithm}[H]
        \begin{algorithmic}[1]
        \Function{$Recovery$}{}

        \State $s \gets next_s$
        \State $ResynchronizationAttempt()$
    
        \For{$Account a \in A$}
            \State $\langle sorthash, \pi, j\rangle\gets 
            \mathsf{Sortition}(
            a_{sk}, 
            \mathsf{getSortitionSeed}(ctx, r), 
            t, 
            next_s, $ \newline
            ${}$ ${\hskip 5.2cm}\mathsf{getSortition}_w(ctx, r, a_{pk}), 
            \mathsf{getSortition_W}(ctx, r)
            )$
            \If{$j > 0$}
                \If{$\exists v | IsCommitable(v)$}
                    \State $GOSSIP(Vote(I, r, p, next_s, v))$
                \ElsIf{$\nexists s_0 > cert | Bundle(r, p - 1, s_0, \bot) \subseteq V \wedge$ \newline 
                ${}$ ${\hskip 2.1cm} \exists s_1 > cert | Bundle(r, p - 1, s_1, \bar{v}) \subseteq V$}
                    \State $GOSSIP(Vote(I, r, p, next_s, \bar{v}))$
                \Else
                    \State $GOSSIP(Vote(I, r, p, next_s, \bot))$
                \EndIf
            \EndIf    
        \EndFor


        \EndFunction
        \end{algorithmic}
        \caption{\underline{Recovery}}
    \end{algorithm}
    
    
    \noindent \textbf{Description:}\\
    
\end{subsection}


% --------------------------------------------------------------------
\begin{subsection}{Fast Recovery Attempt}\label{ssect:FastRecovery}

    \begin{algorithm}[H]
        \begin{algorithmic}[1]
        \Function{$FastRecovery$}{}

        \State $ResynchronizationAttempt()$
    
        \For{$Account \ a \in A$}
            \If{$IsCommitable(v)$}
                \State $\langle sorthash, \pi, j\rangle\gets 
                \mathsf{Sortition}(
                a_{sk}, 
                \mathsf{getSortitionSeed}(ctx, r), 
                t, 
                'late', $ \newline
                ${}$ ${\hskip 5.2cm}\mathsf{getSortition}_w(ctx, r, a_{pk}), 
                \mathsf{getSortition_W}(ctx, r)
                )$
                \If{$j > 0$}
                    \State $GOSSIP(Vote(I, r, p, late, v))$
                \EndIf
            \ElsIf{$\nexists s_0 > cert | Bundle(r, p - 1, s_0, \bot) \subseteq V \wedge$ \newline 
            ${}$ ${\hskip 2.1cm} \exists s_1 > cert | Bundle(r, p - 1, s_1, \bar{v}) \subseteq V$}
                    \State $\langle sorthash, \pi, j\rangle\gets 
                    \mathsf{Sortition}(
                    a_{sk}, 
                    \mathsf{getSortitionSeed}(ctx, r), 
                    t, 
                    'redo', $ \newline
                    ${}$ ${\hskip 5.2cm}\mathsf{getSortition}_w(ctx, r, a_{pk}), 
                    \mathsf{getSortition_W}(ctx, r)
                    )$
                    \If{$j > 0$}
                        \State $GOSSIP()$
                    \EndIf
            \Else
                
            \EndIf    
        \EndFor


        \EndFunction
        \end{algorithmic}
        \caption{\underline{FastRecovery}}
    \end{algorithm}
    
    
\noindent \textbf{Description:}\\
The fast recovery algorithm is executed periodically every integer multiple of $\lambda_F$
seconds. In it, nodes of the network make an attempt to reestablish normal functioning
of the network by broadcasting, in the hopes of observing, any kind of consensus.
Firstly, and same as in the previous mentioned "next" recovery stages, a resynchronization attempt
is made (broadcasting freshest bundle or value if there is any, see ResynchronizationAttempt() in the next section).


\end{subsection}


% ------------------------------------------------------------------------------------
\end{section}
% ------------------------------------------------------------------------------------
% ------------------------------------------------------------------------------------
\begin{section}{Subroutines}\label{sect:soubroutines}

\begin{algorithm}[H]
    \begin{algorithmic}[1]
    \Function{$\mathsf{IsCommitable}$}{$Proposal_{value} v$}

    \State $return \ Proposal(v) \in P \land Bundle(r,p,soft,v) \subset V$

    \EndFunction
    \end{algorithmic}
    \caption{\underline{IsCommitable}}
\end{algorithm}


\noindent \textbf{Arguments:}
\begin{itemize}
    \item $v$ = a proposal value (as we know from a previous section, computed as a function of a ledger entry in consideration).
  \end{itemize}

\noindent \textbf{Description:}\\
A boolean helper subroutine that returns $True$ if, for the input value $v$,
a ledger entry $e = Proposal(v)$ has been observed by the player and is available in the current state,
and a soft bundle of votes $b$ has been observerd, where for every vote $vt \in b$ 
either $vt.v = v$ or $vt$ is an equivocation vote (in which case it counts as a "wildcard" towards 
any value; in particular $v$ in this case). Otherwise, the subroutine returns $False$.

% Messages $m$ are structured ....\marginpar{completar que es un msj, que es mpk, etc}
% The function $\mathsf{ProcessMsg}$ returns....

% ----------------------------------------------------------------------------------------------

% \begin{algorithm}[H]
%     \begin{algorithmic}[H]
%     \Function{$\mathsf{CommitteeVote}$}{$ctx, round, step, T, \tau, \lambda$}
%         \State $role \gets \langle {committee},round,step\rangle$
%         \State $\langle sorthash,\pi,j\rangle \gets \mathsf{Sortition}(user.sk,ctx.seed,\tau ,role,ctx.weight[user.pk],ctx.W)$
%         \text{// only committee members originate a message}
%         \If{$j > 0$}
%             \State $\mathsf{GOSSIP\_MSG}(user.pk, \mathsf{Signed}_{user.sk} (round,step,sorthash,\pi,\mathsf{Hash}(ctx.last_{block}),value))$
%         \EndIf
%     \EndFunction
%     \end{algorithmic}
%     \caption{\underline{CommitteeVote}}
% \end{algorithm}

% ----------------------------------------------------------------------------------------------

\begin{algorithm}[H]
    \begin{algorithmic}[1]
    \Function{$\mathsf{ResynchronizationAttempt}$}{}

    \State $Val = \bot$

    \If{$\exists v | Bundle(r, p, soft, v) \subset V$}
        \State $Broadcast(Bundle(r, p, soft, v))$
        \State $val = v$    
    \ElsIf{$\exists s_0 > cert | Bundle(r, p - 1, s_0, \bot) \subset V$}
        \State $Broadcast(Bundle(r, p, s_0, \bot))$
    \ElsIf{$\exists s_0 > cert, v \neq \bot | Bundle(r, p - 1, s_0, v) \subset V$}
        \State $Broadcast(Bundle(r, p, s_0, v))$
        \State $val = v$   
    \EndIf

    \If{$val \neq \bot and Proposal(v) \in P$}
        \State $Broadcast(Proposal(v))$
    \EndIf

    \EndFunction
    \end{algorithmic}
    \caption{\underline{ResynchronizationAttempt}}
\end{algorithm}

\noindent \textbf{Description:}\\

% ----------------------------------------------------------------------------------------------

\begin{algorithm}[H]
    \begin{algorithmic}[1]
    \Function{$ComputeSeed$}{$ctx, r, B$}
        \If{$B \neq empty\_block$} 
            \State $\Return$ $VRF_{get_{SK_a}(ctx, r)}(ctx.LastBlock.seed||r$)
        \Else
            \State $\Return$ $\mathsf{Hash}(ctx.LastBlock.seed||r)$
        \EndIf
    \EndFunction
    \end{algorithmic}
    \caption{\underline{ComputeSeed}}
\end{algorithm}


\noindent \textbf{Arguments:}
\begin{itemize}
    \item $ctx$ = a helper structure to retrieve ledger context information (e.g. the last confirmed block)
    \item $r$ = current round number
    \item $B$ = the block whose seed is being computed
  \end{itemize}


\noindent \textbf{Description:}\\
This subroutine computes the required sortition seed for the given round number, 
which goes in the proposed block's metadata.
If the block is empty, the seed is a hash of the previous block's seed.
The $get_{SK_a}(ctx, r)$ helper function gets the relevant account's secret ephemeral keys (according to the signing scheme described in specs, the keys 160 rounds prior to $r$).
This roughly corresponds to the secret key from a round $b$ time before block $r-1-(r\;mod\;R)$, where $R$ is the sortition seed's renewal rate, $r$ is the current round's number,
and $b$ is the upper bound for the maximum ammount of time that the network might be compromised.\\

\noindent \textbf{Returns:}
\begin{itemize}
    \item the computed seed for the given block, ledger context and round
  \end{itemize}

% ----------------------------------------------------------------------------------------------

\begin{algorithm}[H]
    \begin{algorithmic}[1]
        \Function{$getSortitionSeed$}{$ctx, r, a_{pk}$}
        
            $\Return\;ctx.block[r-1-(r\;mod\;R)].seed$

        \EndFunction
    \end{algorithmic}
    \caption{\underline{getSortitionSeed}}
\end{algorithm}

\noindent \textbf{Arguments:}
\begin{itemize}
    \item $ctx$ = a helper structure to retrieve ledger context information (e.g. the last confirmed block)
    \item $round$ = current round number
    \item $a_{pk}$ = the account's public key for the look up table
  \end{itemize}


\noindent \textbf{Description:}\\
This helper function gets the relevant sortition seed for the current round $r$, according to the seed lookback parameter $R$.
Conceptually, it corresponds with the seed computed $R$ rounds prior to $r$, refreshed every $R$ rounds.

\noindent \textbf{Returns:}
\begin{itemize}
    \item a sortition seed to be used in the round $r$
  \end{itemize}

% ----------------------------------------------------------------------------------------------

\begin{algorithm}[H]
    \begin{algorithmic}[1]
        \Function{$getSortition_w$}{$ctx, round, a_{pk}$}

            $\Return\;ctx.balanceTable[r - (R + SL)][a_{pk}]$

        \EndFunction
    \end{algorithmic}
    \caption{\underline{getSortitionWeight}}
\end{algorithm}

\noindent \textbf{Arguments:}
\begin{itemize}
    \item $ctx$ = a helper structure to retrieve ledger context information (e.g. the last confirmed block)
    \item $r$ = current round number
    \item $a_{pk}$ = the account's public key for the look up table
  \end{itemize}


\noindent \textbf{Description:}\\
This helper function retrieves the stake $R + SL$ rounds prior to $r$, for an account
with public key $a_{pk}$

\noindent \textbf{Returns:}
\begin{itemize}
    \item the relevant account's stake
  \end{itemize}


% ----------------------------------------------------------------------------------------------


\begin{algorithm}[H]
    \begin{algorithmic}[1]
        \Function{$getSortition_W$}{$ctx, r$}
        
        $\Return \sum_{a_{pk}\;\in\;ctx.balanceTable[r - (R + SL)]}{balanceTable[r - (R + SL)][a_{pk}]}$

        \EndFunction
    \end{algorithmic}
    \caption{\underline{getSortitionTotalStake}}
\end{algorithm}

\noindent \textbf{Arguments:}
\begin{itemize}
    \item $ctx$ = a helper structure to retrieve ledger context information (e.g. the last confirmed block)
    \item $r$ = current round number
  \end{itemize}


\noindent \textbf{Description:}\\
This helper function returns the sum of all stake for $R + SL$ rounds prior to $r$.

\noindent \textbf{Returns:}
\begin{itemize}
    \item the total stake at play in the relevant round (according to lookback parameters)
  \end{itemize}

% ----------------------------------------------------------------------------------------------

\begin{algorithm}[H]
    \begin{algorithmic}[1]
    \Function{$\mathsf{Sortition}$}{$sk, seed, \tau, role, w, W$}
        \State $ \langle hash, \pi \rangle \gets \mathsf{VRF}(seed||role)$
        \State $p \gets \frac{t}{W}$
        \State $j \gets 0$
        \While{$\frac{hash}{2^{hashlen}}\notin [ \sum_{k=0}^j\mathsf{B}(k;w,p), \sum_{k=0}^{j+1}\mathsf{B}(k;w,p))$}
            \State $j++$
        \EndWhile
        \Return $ \langle hash,\pi,j \rangle$
    \EndFunction
    \end{algorithmic}
    \caption{\underline{Sortition}}
\end{algorithm}


\noindent \textbf{Arguments:}
\begin{itemize}
    \item $sk$ = a user's secret key (an ephemeral key for the given round, according to key specs)
    \item $seed$ = the sortition seed to be used
    \item $\tau$ = the expected committee size for the given role
    \item $role$ = a flag specifying the role for the sortition to take place (e.g. block proposer)
    \item $w$ = the user's weight (i.e., its relevant stake)
    \item $W$ = the total relevant stake for the given round
\end{itemize}

\noindent \textbf{Description:}\\
The Sortition procedure is one of the most important subroutines in the main algorithm, as it is 
used in multiple stages and contexts.
Generally, it manages to pseudo-randomly but verifiably (through the use of a Verifiable Random 
Function) select a user with probability proportional
to their weight (i.e., stake) by returning a j parameter, which indicates the number of times that 
specific user was chosen.
Algorithmically, every monetary unit the user has is considered a "sub-user", and then each one 
of them is selected with probability $p = \frac{\tau}{W}$,
where $\tau$ is the expected amount of users to be selected for the given role.
The semi-open interval $[0,1)$ is then split into consecutive intervals using an accumulated 
binomial distribution, and wherever the fraction $\frac{hash}{2^{hashlen}}$
belongs to the interval, that's the ammount of chosen sub-users for the subroutine caller.\\

\noindent \textbf{Returns:}
\begin{itemize}
    \item an integer $j$ that will be positive (larger than 0) if the user has been selected, 
    and its size corresponds to the amount of sub-users for a given committee member
  \end{itemize}


% ----------------------------------------------------------------------------------------------
\begin{algorithm}[H]
    \begin{algorithmic}[1]
    \Function{$\mathsf{Commit}$}{$LedgerEntry \ e$}

        \State $L \gets L || e$
        \State $GarbageCollect()$
        \State $r \gets r+1$
        \State $UpdateBalanceTable()$

    \EndFunction
    \end{algorithmic}
    \caption{\underline{Commit}}
\end{algorithm}

\noindent \textbf{Arguments:}
\begin{itemize}
    \item $LedgerEntry e$ = a ledger entry deemed to be commitable by the consensus mechanism.
    That is, $e$ is a valid entry for $L$, and a valid certification bundle has been observed for 
    its corresponding value (the unique value $v$ for which $Proposal_{value}(e) = v$)
\end{itemize}

\noindent \textbf{Description:}\\
This subroutine commits an entry $e$ to the ledger. The entry passed as argument is appended to the ledger $L$,
the current state is garbage collected, a new round is observed and the balance table and general
account records are updated with whatever transaction information was present in $e$.

% ----------------------------------------------------------------------------------------------

\begin{algorithm}[H]
    \begin{algorithmic}[1]
    \Function{$\mathsf{GarbageCollect}$}{}

    %garbage collect current state
    \State $s \gets proposal$
    \State $P \gets P - {\forall e \in P, e.r=r, e.p = p}$
    %TODO FINISH!


    \EndFunction
    \end{algorithmic}
    \caption{\underline{GarbageCollect}}
\end{algorithm}

\noindent \textbf{Description:}\\


% ----------------------------------------------------------------------------------------------


\begin{algorithm}[H]
    \begin{algorithmic}[1]
    \Function{$\mathsf{VerifySortition}$}{$pk, seed, \tau, role, w, W$}
        \IfThen{$\neg \mathsf{VerifyVRF}_{pk}(hash, \pi, seed||role)$}{$\Return 0$}
        \State $p \gets \frac{t}{W}$
        \State $j \gets 0$
        \While{$\frac{hash}{2^{hashlen}} \notin [\sum_{k=0}^j\mathsf{B}(k;w,p), \sum_{k=0}^{j+1}\mathsf{B}(k;w,p))$}
            \State $j++$
        \EndWhile
        \Return $j$
    \EndFunction
    \end{algorithmic}
    \caption{\underline{VerifySortition}}
\end{algorithm}

\noindent \textbf{Arguments:}
\begin{itemize}
    \item $pk$ = a user's public key (their address)
    \item $seed$ = the sortition seed to be used
    \item $\tau$ = the expected committee size for the given role
    \item $role$ = a flag specifying the role for the sortition to take place (e.g. block proposer)
    \item $w$ = the user's weight (i.e., its relevant stake)
    \item $W$ = the total relevant stake for the given round
  \end{itemize}

\noindent \textbf{Description:}\\
The sortition verification procedure takes Sortition's output and utilizes 
VRF properties to verify the validity of said output.
Once the check is passed, it repeats Sortition's sub-user selection procedure, 
and outputs the amount of times the user was chosen according to their respective 
observed stake.\\

\noindent \textbf{Returns:}
\begin{itemize}
    \item an integer $j$ that will be positive (larger than 0) if the user has been 
    selected, and it's size corresponds to the amount
    of sub-users for a given committee member
  \end{itemize}


\end{section}
% ----------------------------------------------------------------------------------------------
\section*{Appendix: Notation}


\begin{itemize}
    \item $R$ = sortition seed renewal rate (in number of rounds). 
    Set to 2 in the \href{https://github.com/algorandfoundation/specs}{specs.}
    as of December 2022
    \item $\tau_{step}$ = expected number of members on a regular step committee
    \item $\tau_{final}$ = expected number of members on a final consensus achieving committee
    \item $T_{step}$ = fraction of expected members for a voting committee on a given step
    \item $T_{final}$ = fraction of expected members for a voting committee on the final step (step = 2). 
    If observed, achieves final consensus on the given block hash
    \item $\lambda_{proposal}$ = time interval for the node to accept block proposals, after
    which it chooses the observed block with the highest priority (lowest hash) 
    \item $\lambda_{block}$ = waiting time for the full block to be received once decided by vote.
    If no full block is received, the node falls back to the empty block.
    \item $SL$ = the account balances lookback interval, in number of rounds (integer). 
    Set to 320 in \href{https://github.com/algorandfoundation/specs}{specs.}
    \item Public keys $a_{pk}$ for every account linked to the node (doubles as their respective addresses)
    \item Public participation keys $a_{p\_partkey}$ for all accounts registered as online (private participation keys are kept
    securely by respective users and should not be directly accesible by the node)
    \item Two levels of ephemeral keys, signed according to the signing scheme described in \href{https://github.com/algorandfoundation/specs}{specs.} (where 
    first level keys are signed with the participation keys, and second level (aka. leaf) ephemeral keys are signed with 
    first level ephemeral keys). 
    These keys are used for actual participation in the consensus (abstracted as $a_{sk}$ in the following code)
    They are ephemeral because they live for a single round, after which they are deleted
    \item A balance table $BalanceTable$ for all accounts linked to the node, for the round $SL + R$ rounds before the one 
    currently running
\end{itemize}


% ----------------------------------------------------------------------------------------------

\bibliographystyle{alpha}
\bibliography{bibliography}


\end{document}